var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
const styles = "";
const dnd5e = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "spell,feat,class,subclass"
    },
    {
      "path": "system.weaponType",
      "filters": "natural"
    }
  ],
  "ITEM_TRANSFORMER": async (itemData, actor = false) => {
    ["equipped", "proficient", "prepared"].forEach((key) => {
      if (itemData?.system?.[key] !== void 0) {
        delete itemData.system[key];
      }
    });
    setProperty(itemData, "system.attunement", Math.min(CONFIG.DND5E.attunementTypes.REQUIRED, itemData?.system?.attunement ?? 0));
    if (itemData.type === "spell") {
      try {
        const scroll = await Item.implementation.createScrollFromSpell(itemData);
        itemData = scroll.toObject();
      } catch (err) {
      }
    }
    return itemData;
  },
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "DND5E.CurrencyPP",
      img: "icons/commodities/currency/coin-inset-snail-silver.webp",
      abbreviation: "{#}PP",
      data: {
        path: "system.currency.pp"
      },
      primary: false,
      exchangeRate: 10
    },
    {
      type: "attribute",
      name: "DND5E.CurrencyGP",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}GP",
      data: {
        path: "system.currency.gp"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "DND5E.CurrencyEP",
      img: "icons/commodities/currency/coin-inset-copper-axe.webp",
      abbreviation: "{#}EP",
      data: {
        path: "system.currency.ep"
      },
      primary: false,
      exchangeRate: 0.5
    },
    {
      type: "attribute",
      name: "DND5E.CurrencySP",
      img: "icons/commodities/currency/coin-engraved-moon-silver.webp",
      abbreviation: "{#}SP",
      data: {
        path: "system.currency.sp"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "DND5E.CurrencyCP",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}CP",
      data: {
        path: "system.currency.cp"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const pf1 = {
  "VERSION": "1.0.3",
  "ACTOR_CLASS_TYPE": "npc",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "attack,buff,class,feat,race,spell"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "PF1.CurrencyPlatinumP",
      img: "systems/pf1/icons/items/inventory/coins-silver.jpg",
      abbreviation: "{#}PP",
      data: {
        path: "system.currency.pp"
      },
      primary: false,
      exchangeRate: 10
    },
    {
      type: "attribute",
      name: "PF1.CurrencyGoldP",
      img: "systems/pf1/icons/items/inventory/coin-gold.jpg",
      abbreviation: "{#}G",
      data: {
        path: "system.currency.gp"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "PF1.CurrencySilverP",
      img: "systems/pf1/icons/items/inventory/coin-silver.jpg",
      abbreviation: "{#}SP",
      data: {
        path: "system.currency.sp"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "PF1.CurrencyCopperP",
      img: "systems/pf1/icons/items/inventory/coin-copper.jpg",
      abbreviation: "{#}C",
      data: {
        path: "system.currency.cp"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const pf2e = {
  "VERSION": "1.0.1",
  "ACTOR_CLASS_TYPE": "loot",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "action,spell,melee,lore,heritage,feat,effect,class,background,ancestry"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type", "system.temporary.value"],
  "CURRENCIES": [
    {
      type: "item",
      name: "Platinum Pieces",
      img: "systems/pf2e/icons/equipment/treasure/currency/platinum-pieces.webp",
      abbreviation: "{#}PP",
      data: {
        uuid: "Compendium.pf2e.equipment-srd.JuNPeK5Qm1w6wpb4"
      },
      primary: false,
      exchangeRate: 10
    },
    {
      type: "item",
      name: "Gold Pieces",
      img: "systems/pf2e/icons/equipment/treasure/currency/gold-pieces.webp",
      abbreviation: "{#}GP",
      data: {
        uuid: "Compendium.pf2e.equipment-srd.B6B7tBWJSqOBz5zz"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "item",
      name: "Silver Pieces",
      img: "systems/pf2e/icons/equipment/treasure/currency/silver-pieces.webp",
      abbreviation: "{#}SP",
      data: {
        uuid: "Compendium.pf2e.equipment-srd.5Ew82vBF9YfaiY9f"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "item",
      name: "Copper Pieces",
      img: "systems/pf2e/icons/equipment/treasure/currency/copper-pieces.webp",
      abbreviation: "{#}CP",
      data: {
        uuid: "Compendium.pf2e.equipment-srd.lzJ8AVhRcbFul5fh"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const ds4 = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "spell,talent,racialAbility,language,alphabet,specialCreatureAbility"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "DS4.CharacterCurrencyGold",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}G",
      data: {
        path: "system.currency.gold"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "DS4.CharacterCurrencySilver",
      img: "icons/commodities/currency/coin-inset-snail-silver.webp",
      abbreviation: "{#}S",
      data: {
        path: "system.currency.silver"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "DS4.CharacterCurrencyCopper",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}C",
      data: {
        path: "system.currency.copper"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const d35e = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "npc",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "spell,feat,class,race,attack,full-attack,buff,aura,alignment,enhancement,damage-type,material"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "DND5E.CurrencyPP",
      img: "icons/commodities/currency/coin-inset-snail-silver.webp",
      abbreviation: "{#}PP",
      data: {
        path: "system.currency.pp"
      },
      primary: false,
      exchangeRate: 10
    },
    {
      type: "attribute",
      name: "DND5E.CurrencyGP",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}GP",
      data: {
        path: "system.currency.gp"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "DND5E.CurrencySP",
      img: "icons/commodities/currency/coin-engraved-moon-silver.webp",
      abbreviation: "{#}SP",
      data: {
        path: "system.currency.sp"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "DND5E.CurrencyCP",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}CP",
      data: {
        path: "system.currency.cp"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const sfrpg = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "npc2",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "attack,buff,class,feat,race,spell"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "SFRPG.Currencies.Credits",
      img: "systems/sfrpg/icons/equipment/goods/credstick.webp",
      abbreviation: "{#}C",
      data: {
        path: "system.currency.credit"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "SFRPG.Currencies.UPBs",
      img: "systems/sfrpg/icons/equipment/goods/upb.webp",
      abbreviation: "{#} UBP",
      data: {
        path: "system.currency.upb"
      },
      primary: false,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const swade = {
  "VERSION": "1.0.3",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "edge,hindrance,skill,power,ability"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "SWADE.Currency",
      img: "icons/svg/coins.svg",
      abbreviation: "{#}T",
      data: {
        path: "system.details.currency"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const tormenta20 = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.qtd",
  "ITEM_PRICE_ATTRIBUTE": "system.price.gc",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "magia,poder,classe"
    },
    {
      "path": "system.tipoUso",
      "filters": "nat"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Ouro",
      img: "icons/commodities/currency/coin-embossed-insect-gold.webp",
      abbreviation: "{#}O",
      data: {
        path: "system.dinheiro.to"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "Prata",
      img: "icons/commodities/currency/coin-embossed-unicorn-silver.webp",
      abbreviation: "{#}P",
      data: {
        path: "system.dinheiro.tp"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "Cobre",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}C",
      data: {
        path: "system.dinheiro.tc"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const wfrp4e = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity.value",
  "ITEM_PRICE_ATTRIBUTE": "system.price.gc",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "career,container,critical,disease,injury,mutation,prayer,psychology,talent,skill,spell,trait,extendedTest,vehicleMod,cargo"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "item",
      name: "Gold Crown",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}GP",
      data: {
        uuid: "Compendium.wfrp4e.basic.UHArNq3Vuu7Mj5AB"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "item",
      name: "Silver Pieces",
      img: "icons/commodities/currency/coin-engraved-moon-silver.webp",
      abbreviation: "{#}SP",
      data: {
        uuid: "Compendium.wfrp4e.basic.AtRuawWCHjgQxzdn"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "item",
      name: "Brass Penny",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}CP",
      data: {
        uuid: "Compendium.wfrp4e.basic.1BdNwUF0SfiCotWB"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ],
  "CSS_OVERRIDES": {
    "--item-piles-even-color": "#554d40",
    "--item-piles-odd-color": "#2f2920",
    "--item-piles-input-text-color": "#fff"
  }
};
const splittermond = {
  "VERSION": "1.0.4",
  "ACTOR_CLASS_TYPE": "npc",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "spell,strength,weakness,mastery,species,culture,ancestry,education,resource,npcfeature,moonsign,language,culturelore,statuseffect,spelleffect,npcattack"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type", "system.sufferedDamage", "system.quality"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Solare",
      img: "icons/commodities/currency/coins-assorted-mix-copper.webp",
      abbreviation: "{#}S",
      data: {
        path: "system.currency.S"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "Lunare",
      img: "icons/commodities/currency/coins-assorted-mix-silver.webp",
      abbreviation: "{#}L",
      data: {
        path: "system.currency.L"
      },
      primary: false,
      exchangeRate: 0.01
    },
    {
      type: "attribute",
      name: "Telare",
      img: "icons/commodities/currency/coins-assorted-mix-platinum.webp",
      abbreviation: "{#}T",
      data: {
        path: "system.currency.T"
      },
      primary: false,
      exchangeRate: 1e-4
    }
  ]
};
const twodsix = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "traveller",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "skills"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type", "techLevel"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Credits",
      img: "systems/twodsix/assets/icons/id-card.svg",
      abbreviation: "Cr {#}",
      data: {
        path: "system.finances.cash"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const forbiddenLands = {
  "VERSION": "1.0.1",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.cost",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "criticalInjury,monsterAttack,monsterTalent"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Gold",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}GP",
      data: {
        path: "system.currency.gold"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "Silver",
      img: "icons/commodities/currency/coin-engraved-moon-silver.webp",
      abbreviation: "{#}SP",
      data: {
        path: "system.currency.silver"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "Copper",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}CP",
      data: {
        path: "system.currency.copper"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const icrpg = {
  "VERSION": "1.0.3",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "ability"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Coin",
      img: "icons/svg/coins.svg",
      abbreviation: "{#}C",
      data: {
        path: "system.coin.value"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const swse = {
  "VERSION": "1.0.2",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "affiliation,background,class,beast quality,destiny,feat,forcePower,forceRegimen,forceSecret,forceTechnique,species,talent,template,trait,vehicleSystem"
    }
  ],
  "ITEM_SIMILARITIES": ["type", "name", "strippable", "hasPrerequisites", "modifiable", "hasLevels"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Credits",
      img: "icons/svg/coins.svg",
      abbreviation: "{#}C",
      data: {
        path: "system.common.credits"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const fallout = {
  "VERSION": "1.0.3",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.cost",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "skill,perk,special_ability"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "FALLOUT.UI.CAPS",
      img: "icons/commodities/currency/coins-engraved-copper.webp",
      abbreviation: "{#}C",
      data: {
        path: "system.currency.caps"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const cyberpunkRedCore = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price.market",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "role,skill,criticalInjury"
    },
    {
      "path": "system.type",
      "filters": "cyberwareInternal,cyberwareExternal,fashionware"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "CPR.characterSheet.rightPane.eurobucks.eurobucks",
      img: "icons/svg/coins.svg",
      abbreviation: "{#}\u20AC$",
      data: {
        path: "system.wealth.value"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const knave = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.coppers",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "spell"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": []
};
const t2k4e = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.qty",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "specialty,injury"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": []
};
const yzecoriolis = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "npc",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.cost",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "injury, shipProblem, shipCriticalDamage, shipLogbook"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "YZECORIOLIS.Birr",
      img: "icons/commodities/currency/coin-inset-insect-gold.webp",
      abbreviation: "{#}B",
      data: {
        path: "system.birr"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const kamigakari = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "talent,attackOption,race,style,facade,bond"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "KG.Money",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}G",
      data: {
        path: "system.attributes.money"
      },
      primary: true,
      exchangeRate: 1
    }
  ],
  "CURRENCY_DECIMAL_DIGITS": 0.01
};
const symbaroum = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "monster",
  "ITEM_QUANTITY_ATTRIBUTE": "system.number",
  "ITEM_PRICE_ATTRIBUTE": "system.cost",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "ability,boon,burden,mysticalPower,ritual,trait"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "Thaler",
      img: "icons/commodities/currency/coins-assorted-mix-copper.webp",
      abbreviation: "{#}T",
      data: {
        path: "system.money.thaler"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "Shilling",
      img: "icons/commodities/currency/coins-assorted-mix-silver.webp",
      abbreviation: "{#}S",
      data: {
        path: "system.money.shilling"
      },
      primary: false,
      exchangeRate: 0.1
    },
    {
      type: "attribute",
      name: "Orteg",
      img: "icons/commodities/currency/coins-assorted-mix-platinum.webp",
      abbreviation: "{#}O",
      data: {
        path: "system.money.orteg"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const wwn = {
  "VERSION": "1.0.0",
  "ACTOR_CLASS_TYPE": "character",
  "ITEM_QUANTITY_ATTRIBUTE": "system.quantity",
  "ITEM_PRICE_ATTRIBUTE": "system.price",
  "ITEM_FILTERS": [
    {
      "path": "type",
      "filters": "ability, art, asset, focus, skill, spell"
    }
  ],
  "ITEM_SIMILARITIES": ["name", "type"],
  "CURRENCIES": [
    {
      type: "attribute",
      name: "WWN.items.PP.long",
      img: "icons/commodities/currency/coin-inset-snail-silver.webp",
      abbreviation: "{#}PP",
      data: {
        path: "system.currency.pp"
      },
      primary: false,
      exchangeRate: 50
    },
    {
      type: "attribute",
      name: "WWN.items.GP.long",
      img: "icons/commodities/currency/coin-embossed-crown-gold.webp",
      abbreviation: "{#}GP",
      data: {
        path: "system.currency.gp"
      },
      primary: false,
      exchangeRate: 10
    },
    {
      type: "attribute",
      name: "WWN.items.EP.long",
      img: "icons/commodities/currency/coin-inset-copper-axe.webp",
      abbreviation: "{#}EP",
      data: {
        path: "system.currency.ep"
      },
      primary: false,
      exchangeRate: 5
    },
    {
      type: "attribute",
      name: "WWN.items.SP.long",
      img: "icons/commodities/currency/coin-engraved-moon-silver.webp",
      abbreviation: "{#}SP",
      data: {
        path: "system.currency.sp"
      },
      primary: true,
      exchangeRate: 1
    },
    {
      type: "attribute",
      name: "WWN.items.CP.long",
      img: "icons/commodities/currency/coin-engraved-waves-copper.webp",
      abbreviation: "{#}CP",
      data: {
        path: "system.currency.cp"
      },
      primary: false,
      exchangeRate: 0.01
    }
  ]
};
const SYSTEMS = {
  SUPPORTED_SYSTEMS: {
    "dnd5e": dnd5e,
    "pf1": pf1,
    "pf2e": pf2e,
    "ds4": ds4,
    "d35e": d35e,
    "sfrpg": sfrpg,
    "swade": swade,
    "tormenta20": tormenta20,
    "wfrp4e": wfrp4e,
    "splittermond": splittermond,
    "twodsix": twodsix,
    "forbidden-lands": forbiddenLands,
    "icrpg": icrpg,
    "swse": swse,
    "fallout": fallout,
    "cyberpunk-red-core": cyberpunkRedCore,
    "knave": knave,
    "t2k4e": t2k4e,
    "yzecoriolis": yzecoriolis,
    "kamigakari": kamigakari,
    "wwn": wwn,
    "symbaroum": symbaroum
  },
  DEFAULT_SETTINGS: {
    ACTOR_CLASS_TYPE: "",
    ITEM_QUANTITY_ATTRIBUTE: "",
    ITEM_PRICE_ATTRIBUTE: "",
    ITEM_FILTERS: [],
    ITEM_SIMILARITIES: [],
    CURRENCIES: [],
    CURRENCY_DECIMAL_DIGITS: 1e-5
  },
  get HAS_SYSTEM_SUPPORT() {
    return !!this.SUPPORTED_SYSTEMS?.[game.system.id.toLowerCase()];
  },
  get DATA() {
    return this.SUPPORTED_SYSTEMS?.[game.system.id.toLowerCase()] ?? this.DEFAULT_SETTINGS;
  }
};
const SETTINGS = {
  OUTPUT_TO_CHAT: "outputToChat",
  INVERT_SHEET_OPEN: "invertSheetOpen",
  HIDE_ACTOR_HEADER_TEXT: "hideActorHeaderText",
  HIDE_ACTOR_HEADER_BUTTON: "hideActorHeaderButton",
  PRELOAD_FILES: "preloadFiles",
  DEBUG: "debug",
  DEBUG_HOOKS: "debugHooks",
  ENABLE_DROPPING_ITEMS: "enableDroppingItems",
  ENABLE_TRADING: "enableTrading",
  ENABLE_GIVING_ITEMS: "enableGivingItems",
  SHOW_TRADE_BUTTON: "showTradeButton",
  DELETE_EMPTY_PILES: "deleteEmptyPiles",
  INSPECT_ITEMS_IN_TRADE: "inspectItemsInTrade",
  POPULATION_TABLES_FOLDER: "populationTablesFolder",
  CURRENCIES: "currencies",
  CURRENCY_DECIMAL_DIGITS: "currencyDecimalDigits",
  ITEM_FILTERS: "itemFilters",
  ACTOR_CLASS_TYPE: "actorClassType",
  ITEM_QUANTITY_ATTRIBUTE: "itemQuantityAttribute",
  ITEM_PRICE_ATTRIBUTE: "itemPriceAttribute",
  ITEM_SIMILARITIES: "itemSimilarities",
  PRICE_PRESETS: "pricePresets",
  DEFAULT_ITEM_PILE_JOURNAL_ID: "defaultItemPileJournalID",
  DEFAULT_ITEM_PILE_ACTOR_ID: "defaultItemPileActorID",
  SYSTEM_FOUND: "systemFound",
  SYSTEM_NOT_FOUND_WARNING_SHOWN: "systemNotFoundWarningShown",
  PRECONFIGURED_SYSTEM: "preconfiguredSystem",
  SYSTEM_VERSION: "systemVersion",
  MIGRATION_VERSION: "migrationVersion",
  GET_DEFAULT() {
    return foundry.utils.deepClone(SETTINGS.DEFAULTS());
  },
  GET_SYSTEM_DEFAULTS() {
    return Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).filter((entry) => {
      return entry[1].system;
    }));
  },
  DEFAULTS: () => ({
    [SETTINGS.CURRENCIES]: {
      name: "ITEM-PILES.Settings.Currencies.Title",
      label: "ITEM-PILES.Settings.Currencies.Label",
      hint: "ITEM-PILES.Settings.Currencies.Hint",
      icon: "fa fa-money-bill-alt",
      application: "currencies",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.CURRENCIES ?? SYSTEMS.DEFAULT_SETTINGS.CURRENCIES,
      type: Object
    },
    [SETTINGS.CURRENCY_DECIMAL_DIGITS]: {
      name: "ITEM-PILES.Settings.CurrencyDecimalDigits.Title",
      hint: "ITEM-PILES.Settings.CurrencyDecimalDigits.Hint",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.CURRENCY_DECIMAL_DIGITS ?? SYSTEMS.DEFAULT_SETTINGS.CURRENCY_DECIMAL_DIGITS,
      step: 1e-5,
      min: 0,
      max: 1,
      type: Number
    },
    [SETTINGS.ITEM_FILTERS]: {
      name: "ITEM-PILES.Settings.ItemFilters.Title",
      label: "ITEM-PILES.Settings.ItemFilters.Label",
      hint: "ITEM-PILES.Settings.ItemFilters.Hint",
      icon: "fa fa-filter",
      application: "item-filters",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.ITEM_FILTERS ?? SYSTEMS.DEFAULT_SETTINGS.ITEM_FILTERS,
      type: Array
    },
    [SETTINGS.ITEM_SIMILARITIES]: {
      name: "ITEM-PILES.Settings.ItemSimilarities.Title",
      label: "ITEM-PILES.Settings.ItemSimilarities.Label",
      hint: "ITEM-PILES.Settings.ItemSimilarities.Hint",
      icon: "fa fa-equals",
      application: "item-similarities",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.ITEM_SIMILARITIES ?? SYSTEMS.DEFAULT_SETTINGS.ITEM_SIMILARITIES,
      type: Array
    },
    [SETTINGS.PRICE_PRESETS]: {
      name: "ITEM-PILES.Settings.PricePresets.Title",
      label: "ITEM-PILES.Settings.PricePresets.Label",
      hint: "ITEM-PILES.Settings.PricePresets.Hint",
      scope: "world",
      icon: "fa fa-tags",
      application: "price-presets",
      config: false,
      system: true,
      default: [],
      type: Array
    },
    [SETTINGS.ACTOR_CLASS_TYPE]: {
      name: "ITEM-PILES.Settings.ActorClass.Title",
      hint: "ITEM-PILES.Settings.ActorClass.Hint",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.ACTOR_CLASS_TYPE,
      type: String
    },
    [SETTINGS.ITEM_QUANTITY_ATTRIBUTE]: {
      name: "ITEM-PILES.Settings.Quantity.Title",
      hint: "ITEM-PILES.Settings.Quantity.Hint",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.ITEM_QUANTITY_ATTRIBUTE,
      type: String
    },
    [SETTINGS.ITEM_PRICE_ATTRIBUTE]: {
      name: "ITEM-PILES.Settings.Price.Title",
      hint: "ITEM-PILES.Settings.Price.Hint",
      scope: "world",
      config: false,
      system: true,
      default: SYSTEMS.DATA.ITEM_PRICE_ATTRIBUTE,
      type: String
    },
    [SETTINGS.SYSTEM_VERSION]: {
      scope: "world",
      config: false,
      default: "0.0.0",
      type: String
    },
    [SETTINGS.DEFAULT_ITEM_PILE_ACTOR_ID]: {
      scope: "world",
      config: false,
      default: "",
      type: String
    },
    [SETTINGS.DEFAULT_ITEM_PILE_JOURNAL_ID]: {
      scope: "world",
      config: false,
      default: "",
      type: String
    },
    [SETTINGS.SYSTEM_FOUND]: {
      scope: "world",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN]: {
      scope: "world",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.PRECONFIGURED_SYSTEM]: {
      scope: "world",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.MIGRATION_VERSION]: {
      scope: "world",
      config: false,
      default: "0.0.0",
      type: String
    },
    [SETTINGS.OUTPUT_TO_CHAT]: {
      name: "ITEM-PILES.Settings.OutputToChat.Title",
      hint: "ITEM-PILES.Settings.OutputToChat.Hint",
      scope: "world",
      config: false,
      default: 1,
      choices: [
        "ITEM-PILES.Settings.OutputToChat.Off",
        "ITEM-PILES.Settings.OutputToChat.Public",
        "ITEM-PILES.Settings.OutputToChat.SelfGM",
        "ITEM-PILES.Settings.OutputToChat.Blind"
      ],
      type: Number
    },
    [SETTINGS.INSPECT_ITEMS_IN_TRADE]: {
      name: "ITEM-PILES.Settings.InspectItemsTrade.Title",
      hint: "ITEM-PILES.Settings.InspectItemsTrade.Hint",
      scope: "world",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.POPULATION_TABLES_FOLDER]: {
      name: "ITEM-PILES.Settings.PopulationTablesFolder.Title",
      hint: "ITEM-PILES.Settings.PopulationTablesFolder.Hint",
      scope: "world",
      config: false,
      default: "root",
      type: String
    },
    [SETTINGS.DELETE_EMPTY_PILES]: {
      name: "ITEM-PILES.Settings.DeleteEmptyPiles.Title",
      hint: "ITEM-PILES.Settings.DeleteEmptyPiles.Hint",
      scope: "world",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.ENABLE_DROPPING_ITEMS]: {
      name: "ITEM-PILES.Settings.EnableDroppingItems.Title",
      hint: "ITEM-PILES.Settings.EnableDroppingItems.Hint",
      scope: "world",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.ENABLE_TRADING]: {
      name: "ITEM-PILES.Settings.EnableTrading.Title",
      hint: "ITEM-PILES.Settings.EnableTrading.Hint",
      scope: "world",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.ENABLE_GIVING_ITEMS]: {
      name: "ITEM-PILES.Settings.EnableGivingItems.Title",
      hint: "ITEM-PILES.Settings.EnableGivingItems.Hint",
      scope: "world",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.SHOW_TRADE_BUTTON]: {
      name: "ITEM-PILES.Settings.ShowTradeButton.Title",
      hint: "ITEM-PILES.Settings.ShowTradeButton.Hint",
      scope: "world",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.INVERT_SHEET_OPEN]: {
      name: "ITEM-PILES.Settings.InvertSheetOpen.Title",
      hint: "ITEM-PILES.Settings.InvertSheetOpen.Hint",
      scope: "client",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.HIDE_ACTOR_HEADER_TEXT]: {
      name: "ITEM-PILES.Settings.HideHeaderButtonText.Title",
      hint: "ITEM-PILES.Settings.HideHeaderButtonText.Hint",
      scope: "client",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.HIDE_ACTOR_HEADER_BUTTON]: {
      name: "ITEM-PILES.Settings.HideHeaderButton.Title",
      hint: "ITEM-PILES.Settings.HideHeaderButton.Hint",
      scope: "client",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.PRELOAD_FILES]: {
      name: "ITEM-PILES.Settings.PreloadFiles.Title",
      hint: "ITEM-PILES.Settings.PreloadFiles.Hint",
      scope: "client",
      config: false,
      default: true,
      type: Boolean
    },
    [SETTINGS.DEBUG]: {
      name: "ITEM-PILES.Settings.Debug.Title",
      hint: "ITEM-PILES.Settings.Debug.Hint",
      scope: "client",
      config: false,
      default: false,
      type: Boolean
    },
    [SETTINGS.DEBUG_HOOKS]: {
      name: "ITEM-PILES.Settings.DebugHooks.Title",
      hint: "ITEM-PILES.Settings.DebugHooks.Hint",
      scope: "client",
      config: false,
      default: false,
      type: Boolean
    }
  })
};
const module_name = "item-piles";
const module_path = `modules/${module_name}/`;
const baseFlag = `flags.${module_name}.`;
const CONSTANTS = {
  MODULE_NAME: module_name,
  PATH: module_path,
  FLAGS: {
    PILE: baseFlag + "data",
    SHARING: baseFlag + "sharing",
    ITEM: baseFlag + "item",
    PUBLIC_TRADE_ID: baseFlag + "publicTradeId",
    TRADE_USERS: baseFlag + "tradeUsers",
    TEMPORARY_ITEM: baseFlag + "temporary_item"
  },
  ITEM_DEFAULTS: {
    hidden: false,
    notForSale: false,
    infiniteQuantity: false,
    displayQuantity: "default",
    free: false,
    keepZeroQuantity: false,
    disableNormalCost: false,
    cantBeSoldToMerchants: false,
    isService: false,
    macro: "",
    customCategory: "",
    prices: []
  },
  PILE_DEFAULTS: {
    enabled: false,
    distance: 1,
    macro: "",
    deleteWhenEmpty: "default",
    canInspectItems: true,
    displayItemTypes: false,
    description: "",
    overrideItemFilters: false,
    overrideCurrencies: false,
    displayOne: false,
    showItemName: false,
    overrideSingleItemScale: false,
    singleItemScale: 1,
    shareItemsEnabled: false,
    shareCurrenciesEnabled: true,
    takeAllEnabled: false,
    splitAllEnabled: true,
    activePlayers: false,
    isContainer: false,
    closed: false,
    locked: false,
    closedImage: "",
    closedImages: [],
    emptyImage: "",
    emptyImages: [],
    openedImage: "",
    openedImages: [],
    lockedImage: "",
    lockedImages: [],
    closeSound: "",
    closeSounds: [],
    openSound: "",
    openSounds: [],
    lockedSound: "",
    lockedSounds: [],
    unlockedSound: "",
    unlockedSounds: [],
    isMerchant: false,
    merchantImage: "",
    isClosed: false,
    infiniteQuantity: false,
    infiniteCurrencies: true,
    purchaseOnly: false,
    hideNewItems: false,
    keepZeroQuantity: false,
    onlyAcceptBasePrice: true,
    displayQuantity: "yes",
    buyPriceModifier: 1,
    sellPriceModifier: 0.5,
    itemTypePriceModifiers: [],
    actorPriceModifiers: [],
    openTimes: {
      enabled: false,
      status: "open",
      open: {
        hour: 9,
        minute: 0
      },
      close: {
        hour: 18,
        minute: 0
      }
    }
  }
};
Object.freeze(CONSTANTS);
const debounceManager = {
  debounces: {},
  setDebounce(id, method) {
    if (this.debounces[id]) {
      return this.debounces[id];
    }
    this.debounces[id] = debounce(function(...args) {
      delete debounceManager.debounces[id];
      return method(...args);
    }, 50);
    return this.debounces[id];
  }
};
const hooks = {
  run: true,
  _hooks: {},
  async runWithout(callback) {
    this.run = false;
    await callback();
    this.run = true;
  },
  call(hook, ...args) {
    if (!this.run)
      return;
    return Hooks.call(hook, ...args);
  },
  callAll(hook, ...args) {
    if (!this.run)
      return;
    return Hooks.callAll(hook, ...args);
  },
  on(hook, callback) {
    Hooks.on(hook, (...args) => {
      if (!this.run)
        return;
      callback(...args);
    });
  }
};
function isFunction(inFunc) {
  return inFunc && ({}.toString.call(inFunc) === "[object Function]" || {}.toString.call(inFunc) === "[object AsyncFunction]");
}
__name(isFunction, "isFunction");
function wait$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
__name(wait$1, "wait$1");
function getSetting(key) {
  return game.settings.get(CONSTANTS.MODULE_NAME, key);
}
__name(getSetting, "getSetting");
function setSetting(key, value) {
  if (value === void 0)
    throw new Error("setSetting | value must not be undefined!");
  return game.settings.set(CONSTANTS.MODULE_NAME, key, value);
}
__name(setSetting, "setSetting");
function debug(msg, args = "") {
  if (game.settings.get(CONSTANTS.MODULE_NAME, "debug")) {
    console.log(`DEBUG | Item Piles | ${msg}`, args);
  }
}
__name(debug, "debug");
function custom_notify(message) {
  message = `Item Piles | ${message}`;
  ui.notifications.notify(message, { console: false });
  console.log(message.replace("<br>", "\n"));
}
__name(custom_notify, "custom_notify");
function custom_warning(warning, notify = false) {
  warning = `Item Piles | ${warning}`;
  if (notify) {
    ui.notifications.warn(warning, { console: false });
  }
  console.warn(warning.replace("<br>", "\n"));
}
__name(custom_warning, "custom_warning");
function custom_error(error, notify = true) {
  error = `Item Piles | ${error}`;
  if (notify) {
    ui.notifications.error(error, { console: false });
  }
  return new Error(error.replace("<br>", "\n"));
}
__name(custom_error, "custom_error");
function isRealNumber(inNumber) {
  return !isNaN(inNumber) && typeof inNumber === "number" && isFinite(inNumber);
}
__name(isRealNumber, "isRealNumber");
function isActiveGM(user) {
  return user.active && user.isGM;
}
__name(isActiveGM, "isActiveGM");
function getActiveGMs() {
  return game.users.filter(isActiveGM);
}
__name(getActiveGMs, "getActiveGMs");
function isResponsibleGM() {
  if (!game.user.isGM) {
    return false;
  }
  return !getActiveGMs().some((other) => other.id < game.user.id);
}
__name(isResponsibleGM, "isResponsibleGM");
function isGMConnected() {
  return !!Array.from(game.users).find((user) => user.isGM && user.active);
}
__name(isGMConnected, "isGMConnected");
function roundToDecimals(num, decimals) {
  return Number(Math.round(num + "e" + decimals) + "e-" + decimals);
}
__name(roundToDecimals, "roundToDecimals");
async function getFiles(inFile, { applyWildCard = false, softFail = false } = {}) {
  let source = "data";
  const browseOptions = { wildcard: applyWildCard };
  if (/\.s3\./.test(inFile)) {
    source = "s3";
    const { bucket, keyPrefix } = FilePicker.parseS3URL(inFile);
    if (bucket) {
      browseOptions.bucket = bucket;
      inFile = keyPrefix;
    }
  }
  try {
    return (await FilePicker.browse(source, inFile, browseOptions)).files;
  } catch (err) {
    if (softFail)
      return false;
    throw custom_error("Sequencer", `getFiles | ${err}`);
  }
}
__name(getFiles, "getFiles");
function random_float_between(min, max) {
  const random = Math.random();
  const _max = Math.max(max, min);
  const _min = Math.min(max, min);
  return random * (_max - _min) + _min;
}
__name(random_float_between, "random_float_between");
function random_int_between(min, max) {
  return Math.floor(random_float_between(min, max));
}
__name(random_int_between, "random_int_between");
function random_array_element(inArray, { recurse = false } = {}) {
  let choice = inArray[random_int_between(0, inArray.length)];
  if (recurse && Array.isArray(choice)) {
    return random_array_element(choice, { recurse: true });
  }
  return choice;
}
__name(random_array_element, "random_array_element");
function getActor(target) {
  if (target instanceof Actor)
    return target;
  if (stringIsUuid(target)) {
    target = fromUuidSync(target);
  }
  target = getDocument(target);
  return target?.actor ?? target;
}
__name(getActor, "getActor");
function getToken(documentUuid) {
  const document2 = fromUuidSync(documentUuid);
  return document2 instanceof TokenDocument ? document2.object : document2;
}
__name(getToken, "getToken");
function getDocument(target) {
  if (stringIsUuid(target)) {
    target = fromUuidSync(target);
  }
  return target?.document ?? target;
}
__name(getDocument, "getDocument");
function stringIsUuid(inId) {
  return typeof inId === "string" && (inId.match(/\./g) || []).length && !inId.endsWith(".");
}
__name(stringIsUuid, "stringIsUuid");
function getUuid(target) {
  if (stringIsUuid(target))
    return target;
  const document2 = getDocument(target);
  return document2?.uuid ?? false;
}
__name(getUuid, "getUuid");
function findSimilarItem(items, findItem) {
  const itemSimilarities = game.itempiles.API.ITEM_SIMILARITIES;
  const findItemId = findItem instanceof Item ? findItem.id : findItem._id;
  return items.find((item) => {
    const itemId = item instanceof Item ? item.id : item._id ?? item.id;
    if (itemId && findItemId && itemId === findItemId) {
      return true;
    }
    const itemData = item instanceof Item ? item.toObject() : item;
    for (const path of itemSimilarities) {
      if (getProperty(itemData, path) !== getProperty(findItem, path) || !hasProperty(itemData, path) ^ !hasProperty(findItem, path)) {
        return false;
      }
    }
    return true;
  });
}
__name(findSimilarItem, "findSimilarItem");
function setSimilarityProperties(obj, item) {
  const itemData = item instanceof Item ? item.toObject() : item;
  setProperty(obj, "_id", itemData._id);
  game.itempiles.API.ITEM_SIMILARITIES.forEach((prop) => {
    setProperty(obj, prop, getProperty(itemData, prop));
  });
  return obj;
}
__name(setSimilarityProperties, "setSimilarityProperties");
let itemTypesWithQuantities = false;
function getItemTypesWithQuantities() {
  if (!itemTypesWithQuantities) {
    itemTypesWithQuantities = new Set(game.system.template.Item.types.filter((type) => {
      const itemTemplate = {
        system: foundry.utils.deepClone(game.system.template.Item[type])
      };
      if (itemTemplate.system?.templates?.length) {
        const templates = foundry.utils.duplicate(itemTemplate.system.templates);
        for (let template of templates) {
          itemTemplate.system = foundry.utils.mergeObject(
            itemTemplate.system,
            foundry.utils.duplicate(game.system.template.Item.templates[template])
          );
        }
      }
      return hasItemQuantity(itemTemplate);
    }));
  }
  return itemTypesWithQuantities;
}
__name(getItemTypesWithQuantities, "getItemTypesWithQuantities");
function canItemStack(item) {
  const itemData = item instanceof Item ? item.toObject() : item;
  return getItemTypesWithQuantities().has(itemData.type);
}
__name(canItemStack, "canItemStack");
function getItemQuantity(item) {
  const itemData = item instanceof Item ? item.toObject() : item;
  return Number(getProperty(itemData, game.itempiles.API.ITEM_QUANTITY_ATTRIBUTE) ?? 0);
}
__name(getItemQuantity, "getItemQuantity");
function hasItemQuantity(item) {
  const itemData = item instanceof Item ? item.toObject() : item;
  return hasProperty(itemData, game.itempiles.API.ITEM_QUANTITY_ATTRIBUTE);
}
__name(hasItemQuantity, "hasItemQuantity");
function setItemQuantity(itemData, quantity, requiresExistingQuantity = false) {
  if (!requiresExistingQuantity || getItemTypesWithQuantities().has(itemData.type)) {
    setProperty(itemData, game.itempiles.API.ITEM_QUANTITY_ATTRIBUTE, quantity);
  }
  return itemData;
}
__name(setItemQuantity, "setItemQuantity");
function getItemCost(item) {
  const itemData = item instanceof Item ? item.toObject() : item;
  return getProperty(itemData, game.itempiles.API.ITEM_PRICE_ATTRIBUTE) ?? 0;
}
__name(getItemCost, "getItemCost");
function getTokensAtLocation(position) {
  const tokens = [...canvas.tokens.placeables].filter((token) => token.mesh.visible);
  return tokens.filter((token) => {
    return position.x >= token.x && position.x < token.x + token.document.width * canvas.grid.size && position.y >= token.y && position.y < token.y + token.document.height * canvas.grid.size;
  });
}
__name(getTokensAtLocation, "getTokensAtLocation");
function distance_between_rect(p1, p2) {
  const x1 = p1.x;
  const y1 = p1.y;
  const x1b = p1.x + p1.w;
  const y1b = p1.y + p1.h;
  const x2 = p2.x;
  const y2 = p2.y;
  const x2b = p2.x + p2.w;
  const y2b = p2.y + p2.h;
  const left = x2b < x1;
  const right = x1b < x2;
  const bottom = y2b < y1;
  const top = y1b < y2;
  if (top && left) {
    return distance_between({ x: x1, y: y1b }, { x: x2b, y: y2 });
  } else if (left && bottom) {
    return distance_between({ x: x1, y: y1 }, { x: x2b, y: y2b });
  } else if (bottom && right) {
    return distance_between({ x: x1b, y: y1 }, { x: x2, y: y2b });
  } else if (right && top) {
    return distance_between({ x: x1b, y: y1b }, { x: x2, y: y2 });
  } else if (left) {
    return x1 - x2b;
  } else if (right) {
    return x2 - x1b;
  } else if (bottom) {
    return y1 - y2b;
  } else if (top) {
    return y2 - y1b;
  }
  return 0;
}
__name(distance_between_rect, "distance_between_rect");
function distance_between(a, b) {
  return new Ray(a, b).distance;
}
__name(distance_between, "distance_between");
function grids_between_tokens(a, b) {
  return Math.floor(distance_between_rect(a, b) / canvas.grid.size) + 1;
}
__name(grids_between_tokens, "grids_between_tokens");
function tokens_close_enough(a, b, maxDistance) {
  const distance = grids_between_tokens(a, b);
  return maxDistance >= distance;
}
__name(tokens_close_enough, "tokens_close_enough");
async function runMacro(macroId, macroData) {
  let macro;
  if (macroId.startsWith("Compendium")) {
    let packArray = macroId.split(".");
    let compendium = game.packs.get(`${packArray[1]}.${packArray[2]}`);
    if (!compendium) {
      throw custom_error(`Compendium ${packArray[1]}.${packArray[2]} was not found`);
    }
    let findMacro = (await compendium.getDocuments()).find((m) => m.name === packArray[3] || m.id === packArray[3]);
    if (!findMacro) {
      throw custom_error(`The "${packArray[3]}" macro was not found in Compendium ${packArray[1]}.${packArray[2]}`);
    }
    macro = new Macro(findMacro?.toObject());
    macro.ownership.default = CONST.DOCUMENT_PERMISSION_LEVELS.OWNER;
  } else {
    macro = game.macros.getName(macroId);
    if (!macro) {
      throw custom_error(`Could not find macro with name "${macroId}"`);
    }
  }
  let result = false;
  try {
    result = await macro.execute(macroData);
  } catch (err) {
    custom_warning(`Error when executing macro ${macroId}!
${err}`, true);
  }
  return result;
}
__name(runMacro, "runMacro");
function getUserCharacter() {
  if (game.user.character) {
    return game.user.character;
  }
  if (game.user.isGM) {
    return false;
  }
  return game.actors.filter((actor) => {
    return actor.ownership?.[game.user.id] === CONST.DOCUMENT_PERMISSION_LEVELS.OWNER && actor.prototypeToken.actorLink;
  }).sort((a, b) => {
    return b._stats.modifiedTime - a._stats.modifiedTime;
  })?.[0] ?? false;
}
__name(getUserCharacter, "getUserCharacter");
function getPlayersForItemPile(target) {
  const targetActor = getActor(target);
  if (!isValidItemPile(targetActor))
    return [];
  const pileData = getActorFlagData(targetActor);
  return Array.from(game.users).filter((u) => (u.active || !pileData.activePlayers) && u.character);
}
__name(getPlayersForItemPile, "getPlayersForItemPile");
function getItemPileSharingData(target) {
  const targetActor = getActor(target);
  return foundry.utils.duplicate(getProperty(targetActor, CONSTANTS.FLAGS.SHARING) ?? {});
}
__name(getItemPileSharingData, "getItemPileSharingData");
function updateItemPileSharingData(target, incomingSharingData) {
  const targetActor = getActor(target);
  const currentSharingData = getItemPileSharingData(targetActor);
  const newSharingData = foundry.utils.mergeObject(currentSharingData, incomingSharingData);
  return targetActor.update({
    [CONSTANTS.FLAGS.SHARING]: newSharingData
  });
}
__name(updateItemPileSharingData, "updateItemPileSharingData");
function clearItemPileSharingData(target) {
  const targetActor = getActor(target);
  return targetActor.update({
    [CONSTANTS.FLAGS.SHARING]: null
  });
}
__name(clearItemPileSharingData, "clearItemPileSharingData");
async function setItemPileSharingData(sourceUuid, targetUuid, { items = [], attributes: attributes2 = [] } = {}) {
  const sourceActor = getActor(sourceUuid);
  const targetActor = getActor(targetUuid);
  const sourceIsItemPile = isValidItemPile(sourceActor);
  const targetIsItemPile = isValidItemPile(targetActor);
  if (sourceIsItemPile && targetIsItemPile)
    return;
  if (items.length) {
    items = items.map((itemData) => {
      setItemQuantity(itemData.item, Math.abs(itemData.quantity));
      return itemData.item;
    });
  }
  if (!Array.isArray(attributes2) && typeof attributes2 === "object") {
    attributes2 = Object.entries(attributes2).map((entry) => {
      return {
        path: entry[0],
        quantity: Math.abs(entry[1])
      };
    });
  }
  if (sourceIsItemPile) {
    if (isItemPileEmpty(sourceIsItemPile)) {
      return clearItemPileSharingData(sourceIsItemPile);
    }
    const sharingData2 = addToItemPileSharingData(sourceActor, targetActor.uuid, { items, attributes: attributes2 });
    return updateItemPileSharingData(sourceActor, sharingData2);
  }
  const sharingData = removeFromItemPileSharingData(targetActor, sourceActor.uuid, { items, attributes: attributes2 });
  return updateItemPileSharingData(targetActor, sharingData);
}
__name(setItemPileSharingData, "setItemPileSharingData");
function addToItemPileSharingData(itemPile, actorUuid, {
  sharingData = false,
  items = [],
  attributes: attributes2 = []
} = {}) {
  const pileData = getActorFlagData(itemPile);
  const pileCurrencies = getActorCurrencies(itemPile, { getAll: true });
  const filteredItems = items.filter((item) => !pileCurrencies.some((currency) => item.id !== currency.id));
  const currencies = items.filter((item) => !pileCurrencies.some((currency) => item.id === currency.id));
  let pileSharingData = {};
  if (!sharingData && (pileData.shareItemsEnabled && filteredItems.length || pileData.shareCurrenciesEnabled && (attributes2.length || currencies.length))) {
    pileSharingData = getItemPileSharingData(itemPile);
  }
  if (pileData.shareItemsEnabled && filteredItems.length || pileData.shareCurrenciesEnabled && currencies.length) {
    if (!pileSharingData.items) {
      pileSharingData.items = [];
    }
    for (const item of filteredItems.concat(currencies)) {
      let existingItem = findSimilarItem(pileSharingData.items, item);
      if (!existingItem) {
        let itemIndex = pileSharingData.items.push(setSimilarityProperties({
          actors: [{ uuid: actorUuid, quantity: 0 }]
        }, item));
        existingItem = pileSharingData.items[itemIndex - 1];
      } else if (!existingItem.actors) {
        existingItem.actors = [];
        existingItem._id = item.id;
      }
      let actorData = existingItem.actors.find((data) => data.uuid === actorUuid);
      const itemQuantity = getItemQuantity(item);
      if (!actorData) {
        if (itemQuantity > 0) {
          existingItem.actors.push({ uuid: actorUuid, quantity: itemQuantity });
        }
      } else {
        actorData.quantity += itemQuantity;
        if (actorData.quantity <= 0) {
          existingItem.actors.splice(existingItem.actors.indexOf(actorData), 1);
        }
        if (existingItem.actors.length === 0) {
          pileSharingData.items.splice(pileSharingData.items.indexOf(existingItem), 1);
        }
      }
    }
  }
  if (pileData.shareCurrenciesEnabled && attributes2.length) {
    if (!pileSharingData.attributes) {
      pileSharingData.attributes = [];
    }
    for (const attribute of attributes2) {
      let existingCurrency = pileSharingData.attributes.find((sharingCurrency) => sharingCurrency.path === attribute.path);
      if (!existingCurrency) {
        let itemIndex = pileSharingData.attributes.push({
          path: attribute.path,
          actors: [{ uuid: actorUuid, quantity: 0 }]
        });
        existingCurrency = pileSharingData.attributes[itemIndex - 1];
      } else {
        if (!existingCurrency.actors) {
          existingCurrency.actors = [];
        }
      }
      let actorData = existingCurrency.actors.find((data) => data.uuid === actorUuid);
      if (!actorData) {
        if (attribute.quantity > 0) {
          existingCurrency.actors.push({ uuid: actorUuid, quantity: attribute.quantity });
        }
      } else {
        actorData.quantity += attribute.quantity;
        if (actorData.quantity <= 0) {
          existingCurrency.actors.splice(existingCurrency.actors.indexOf(actorData), 1);
        }
        if (existingCurrency.actors.length === 0) {
          pileSharingData.attributes.splice(pileSharingData.attributes.indexOf(existingCurrency), 1);
        }
      }
    }
  }
  return pileSharingData;
}
__name(addToItemPileSharingData, "addToItemPileSharingData");
function removeFromItemPileSharingData(itemPile, actorUuid, { items = [], attributes: attributes2 = [] } = {}) {
  items = items.map((item) => {
    setItemQuantity(item, getItemQuantity(item) * -1);
    return item;
  });
  attributes2 = attributes2.map((attribute) => {
    attribute.quantity = attribute.quantity * -1;
    return attribute;
  });
  return addToItemPileSharingData(itemPile, actorUuid, { items, attributes: attributes2 });
}
__name(removeFromItemPileSharingData, "removeFromItemPileSharingData");
function getItemSharesLeftForActor(pile, item, recipient, {
  currentQuantity = null,
  floor = null,
  players = null,
  shareData = null
} = {}) {
  if (item instanceof String) {
    item = pile.items.get(item);
  }
  let previouslyTaken = 0;
  let recipientUuid = getUuid(recipient);
  currentQuantity = currentQuantity ?? Math.abs(getItemQuantity(item));
  let totalShares = currentQuantity;
  shareData = shareData ?? getItemPileSharingData(pile);
  if (shareData?.items?.length) {
    const foundItem = findSimilarItem(shareData.items, item);
    if (foundItem) {
      totalShares = foundItem.actors.reduce((acc, actor) => acc + actor.quantity, currentQuantity);
      const quantityTakenBefore = foundItem.actors.find((actor) => actor.uuid === recipientUuid);
      previouslyTaken = quantityTakenBefore ? quantityTakenBefore.quantity : 0;
    }
  }
  players = players ?? getPlayersForItemPile(pile).length;
  let totalActorShare = totalShares / players;
  if (!Number.isInteger(totalActorShare) && !floor) {
    totalActorShare += 1;
  }
  return Math.max(0, Math.min(currentQuantity, Math.floor(totalActorShare - previouslyTaken)));
}
__name(getItemSharesLeftForActor, "getItemSharesLeftForActor");
function getAttributeSharesLeftForActor(pile, path, recipient, {
  currentQuantity = null,
  floor = null,
  players = null,
  shareData = null
} = {}) {
  let previouslyTaken = 0;
  let recipientUuid = getUuid(recipient);
  currentQuantity = currentQuantity ?? Number(getProperty(pile, path) ?? 0);
  let totalShares = currentQuantity;
  shareData = shareData ?? getItemPileSharingData(pile);
  if (shareData?.attributes?.length) {
    const existingCurrency = shareData.attributes.find((storedCurrency) => storedCurrency.path === path);
    if (existingCurrency) {
      totalShares = existingCurrency.actors.reduce((acc, actor) => acc + actor.quantity, currentQuantity);
      const quantityTakenBefore = existingCurrency?.actors?.find((actor) => actor.uuid === recipientUuid);
      previouslyTaken = quantityTakenBefore ? quantityTakenBefore.quantity : 0;
    }
  }
  players = players ?? getPlayersForItemPile(pile).length;
  let totalActorShare = totalShares / players;
  if (!Number.isInteger(totalActorShare) && !floor) {
    totalActorShare += 1;
  }
  return Math.max(0, Math.min(currentQuantity, Math.floor(totalActorShare - previouslyTaken)));
}
__name(getAttributeSharesLeftForActor, "getAttributeSharesLeftForActor");
const prefix = /* @__PURE__ */ __name((string) => (strings, ...expressions) => `${string}-${strings.reduce((a, c, i) => a + expressions[i - 1] + c)}`, "prefix");
const module = prefix(CONSTANTS.MODULE_NAME);
const HOOKS = {
  READY: module`ready`,
  RESET_SETTINGS: module`resetSettings`,
  PRE_TRANSFER_EVERYTHING: module`preTransferEverything`,
  TRANSFER_EVERYTHING: module`transferEverything`,
  PRE_OPEN_INTERFACE: module`preOpenInterface`,
  OPEN_INTERFACE: module`openInterface`,
  PRE_CLOSE_INTERFACE: module`preCloseInterface`,
  CLOSE_INTERFACE: module`closeInterface`,
  PILE: {
    PRE_CREATE: module`preCreateItemPile`,
    CREATE: module`createItemPile`,
    PRE_UPDATE: module`preUpdateItemPile`,
    UPDATE: module`updateItemPile`,
    PRE_DELETE: module`preDeleteItemPile`,
    DELETE: module`deleteItemPile`,
    PRE_CLOSE: module`preCloseItemPile`,
    CLOSE: module`closeItemPile`,
    PRE_OPEN: module`preOpenItemPile`,
    OPEN: module`openItemPile`,
    PRE_LOCK: module`preLockItemPile`,
    LOCK: module`lockItemPile`,
    PRE_UNLOCK: module`preUnlockItemPile`,
    UNLOCK: module`unlockItemPile`,
    PRE_RATTLE: module`preRattleItemPile`,
    RATTLE: module`rattleItemPile`,
    PRE_TURN_INTO: module`preTurnIntoItemPiles`,
    TURN_INTO: module`turnIntoItemPiles`,
    PRE_REVERT_FROM: module`preRevertFromItemPiles`,
    REVERT_FROM: module`revertFromItemPiles`,
    PRE_SPLIT_INVENTORY: module`preSplitItemPileContent`,
    SPLIT_INVENTORY: module`splitItemPileContent`
  },
  ITEM: {
    PRE_DROP_DETERMINED: module`preDropItemDetermined`,
    PRE_DROP: module`preDropItem`,
    DROP: module`dropItem`,
    PRE_TRANSFER: module`preTransferItems`,
    TRANSFER: module`transferItems`,
    PRE_ADD: module`preAddItems`,
    ADD: module`addItems`,
    PRE_REMOVE: module`preRemoveItems`,
    REMOVE: module`removeItems`,
    PRE_TRANSFER_ALL: module`preTransferAllItems`,
    TRANSFER_ALL: module`transferAllItems`,
    PRE_CALC_TRADE: module`preCalculateTradeItems`,
    PRE_TRADE: module`preTradeItems`,
    TRADE: module`tradeItems`
  },
  CURRENCY: {
    PRE_TRANSFER: module`preTransferCurrencies`,
    TRANSFER: module`transferCurrencies`,
    PRE_ADD: module`preAddCurrencies`,
    ADD: module`addCurrencies`,
    PRE_REMOVE: module`preRemoveCurrencies`,
    REMOVE: module`removeCurrencies`,
    PRE_TRANSFER_ALL: module`preTransferAllCurrencies`,
    TRANSFER_ALL: module`transferAllCurrencies`
  },
  ATTRIBUTE: {
    PRE_TRANSFER: module`preTransferAttributes`,
    TRANSFER: module`transferAttributes`,
    PRE_SET: module`preSetAttributes`,
    SET: module`setAttributes`,
    PRE_ADD: module`preAddAttributes`,
    ADD: module`addAttributes`,
    PRE_REMOVE: module`preRemoveAttributes`,
    REMOVE: module`removeAttributes`,
    PRE_TRANSFER_ALL: module`preTransferAllAttributes`,
    TRANSFER_ALL: module`transferAllAttributes`
  },
  TRADE: {
    STARTED: module`tradeStarted`,
    COMPLETE: module`tradeComplete`
  }
};
function noop() {
}
__name(noop, "noop");
const identity = /* @__PURE__ */ __name((x) => x, "identity");
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
__name(assign, "assign");
function run(fn) {
  return fn();
}
__name(run, "run");
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
__name(blank_object, "blank_object");
function run_all(fns) {
  fns.forEach(run);
}
__name(run_all, "run_all");
function is_function(thing) {
  return typeof thing === "function";
}
__name(is_function, "is_function");
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
__name(safe_not_equal, "safe_not_equal");
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
__name(src_url_equal, "src_url_equal");
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
__name(is_empty, "is_empty");
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
__name(subscribe, "subscribe");
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
__name(get_store_value, "get_store_value");
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
__name(component_subscribe, "component_subscribe");
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
__name(create_slot, "create_slot");
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
__name(get_slot_context, "get_slot_context");
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
__name(get_slot_changes, "get_slot_changes");
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
__name(update_slot_base, "update_slot_base");
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
__name(get_all_dirty_from_scope, "get_all_dirty_from_scope");
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
__name(exclude_internal_props, "exclude_internal_props");
function null_to_empty(value) {
  return value == null ? "" : value;
}
__name(null_to_empty, "null_to_empty");
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
__name(set_store_value, "set_store_value");
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
__name(action_destroyer, "action_destroyer");
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
__name(run_tasks, "run_tasks");
function loop$1(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
__name(loop$1, "loop$1");
function append(target, node) {
  target.appendChild(node);
}
__name(append, "append");
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
__name(get_root_for_style, "get_root_for_style");
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
__name(append_empty_stylesheet, "append_empty_stylesheet");
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
__name(append_stylesheet, "append_stylesheet");
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
__name(insert, "insert");
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
__name(detach, "detach");
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
__name(destroy_each, "destroy_each");
function element(name) {
  return document.createElement(name);
}
__name(element, "element");
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
__name(svg_element, "svg_element");
function text(data) {
  return document.createTextNode(data);
}
__name(text, "text");
function space() {
  return text(" ");
}
__name(space, "space");
function empty() {
  return text("");
}
__name(empty, "empty");
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
__name(listen, "listen");
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
__name(prevent_default, "prevent_default");
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
__name(stop_propagation, "stop_propagation");
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
__name(attr, "attr");
function to_number(value) {
  return value === "" ? null : +value;
}
__name(to_number, "to_number");
function children(element2) {
  return Array.from(element2.childNodes);
}
__name(children, "children");
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
__name(set_data, "set_data");
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
__name(set_input_value, "set_input_value");
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
__name(set_style, "set_style");
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
__name(select_option, "select_option");
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
__name(select_value, "select_value");
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
__name(toggle_class, "toggle_class");
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
__name(custom_event, "custom_event");
class HtmlTag {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
__name(HtmlTag, "HtmlTag");
function construct_svelte_component(component, props) {
  return new component(props);
}
__name(construct_svelte_component, "construct_svelte_component");
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
__name(hash, "hash");
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
__name(create_style_information, "create_style_information");
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
__name(create_rule, "create_rule");
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next2 = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
  );
  const deleted = previous.length - next2.length;
  if (deleted) {
    node.style.animation = next2.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
__name(delete_rule, "delete_rule");
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
__name(clear_rules, "clear_rules");
function create_animation(node, from, fn, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    start: start_time = now() + delay,
    end = start_time + duration,
    tick: tick2 = noop,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  __name(start, "start");
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  __name(stop, "stop");
  loop$1((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick2(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick2(t, 1 - t);
    }
    return true;
  });
  start();
  tick2(0, 1);
  return stop;
}
__name(create_animation, "create_animation");
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}
__name(fix_position, "fix_position");
function add_transform(node, a) {
  const b = node.getBoundingClientRect();
  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}
__name(add_transform, "add_transform");
let current_component;
function set_current_component(component) {
  current_component = component;
}
__name(set_current_component, "set_current_component");
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
__name(get_current_component, "get_current_component");
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
__name(onMount, "onMount");
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
__name(onDestroy, "onDestroy");
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
__name(createEventDispatcher, "createEventDispatcher");
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
__name(setContext, "setContext");
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
__name(getContext, "getContext");
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
__name(bubble, "bubble");
const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
__name(schedule_update, "schedule_update");
function tick() {
  schedule_update();
  return resolved_promise;
}
__name(tick, "tick");
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
__name(add_render_callback, "add_render_callback");
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
__name(add_flush_callback, "add_flush_callback");
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
__name(flush, "flush");
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
__name(update, "update");
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
__name(wait, "wait");
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
__name(dispatch, "dispatch");
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
__name(group_outros, "group_outros");
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
__name(check_outros, "check_outros");
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
__name(transition_in, "transition_in");
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
__name(transition_out, "transition_out");
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  let config = fn(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  __name(cleanup, "cleanup");
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick2(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop$1((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(t, 1 - t);
        }
      }
      return running;
    });
  }
  __name(go, "go");
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config)) {
        config = config();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
__name(create_in_transition, "create_in_transition");
function create_out_transition(node, fn, params) {
  let config = fn(node, params);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop$1((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  __name(go, "go");
  if (is_function(config)) {
    wait().then(() => {
      config = config();
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
__name(create_out_transition, "create_out_transition");
function create_bidirectional_transition(node, fn, params, intro) {
  let config = fn(node, params);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  __name(clear_animation, "clear_animation");
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  __name(init2, "init");
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop$1((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  __name(go, "go");
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config();
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
__name(create_bidirectional_transition, "create_bidirectional_transition");
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
__name(destroy_block, "destroy_block");
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
__name(outro_and_destroy_block, "outro_and_destroy_block");
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
__name(fix_and_outro_and_destroy_block, "fix_and_outro_and_destroy_block");
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next2, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next2);
    lookup.set(block.key, block);
    next2 = block.first;
    n--;
  }
  __name(insert2, "insert");
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next2 = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  return new_blocks;
}
__name(update_keyed_each, "update_keyed_each");
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
__name(get_spread_update, "get_spread_update");
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
__name(get_spread_object, "get_spread_object");
function bind$1(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
__name(bind$1, "bind$1");
function create_component(block) {
  block && block.c();
}
__name(create_component, "create_component");
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
__name(mount_component, "mount_component");
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
__name(destroy_component, "destroy_component");
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
__name(make_dirty, "make_dirty");
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
__name(init, "init");
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
__name(SvelteComponent, "SvelteComponent");
const subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
__name(readable, "readable");
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set, "set");
  function update2(fn) {
    set(fn(value));
  }
  __name(update2, "update");
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe2, "subscribe");
  return { set, update: update2, subscribe: subscribe2 };
}
__name(writable, "writable");
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = /* @__PURE__ */ __name(() => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    }, "sync");
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return /* @__PURE__ */ __name(function stop() {
      run_all(unsubscribers);
      cleanup();
    }, "stop");
  });
}
__name(derived, "derived");
const s_UUIDV4_REGEX = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
function uuidv4() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ (globalThis.crypto || globalThis.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}
__name(uuidv4, "uuidv4");
uuidv4.isValid = (uuid) => s_UUIDV4_REGEX.test(uuid);
function getStackingContext(node) {
  if (!node || node.nodeName === "HTML") {
    return { node: document.documentElement, reason: "root" };
  }
  if (node.nodeName === "#document-fragment") {
    return getStackingContext(node.host);
  }
  const computedStyle = globalThis.getComputedStyle(node);
  if (computedStyle.position === "fixed" || computedStyle.position === "sticky") {
    return { node, reason: `position: ${computedStyle.position}` };
  }
  if (computedStyle.zIndex !== "auto" && computedStyle.position !== "static") {
    return { node, reason: `position: ${computedStyle.position}; z-index: ${computedStyle.zIndex}` };
  }
  if (computedStyle.opacity !== "1") {
    return { node, reason: `opacity: ${computedStyle.opacity}` };
  }
  if (computedStyle.transform !== "none") {
    return { node, reason: `transform: ${computedStyle.transform}` };
  }
  if (computedStyle.mixBlendMode !== "normal") {
    return { node, reason: `mixBlendMode: ${computedStyle.mixBlendMode}` };
  }
  if (computedStyle.filter !== "none") {
    return { node, reason: `filter: ${computedStyle.filter}` };
  }
  if (computedStyle.perspective !== "none") {
    return { node, reason: `perspective: ${computedStyle.perspective}` };
  }
  if (computedStyle.clipPath !== "none") {
    return { node, reason: `clip-path: ${computedStyle.clipPath} ` };
  }
  const mask = computedStyle.mask || computedStyle.webkitMask;
  if (mask !== "none" && mask !== void 0) {
    return { node, reason: `mask:  ${mask}` };
  }
  const maskImage = computedStyle.maskImage || computedStyle.webkitMaskImage;
  if (maskImage !== "none" && maskImage !== void 0) {
    return { node, reason: `mask-image: ${maskImage}` };
  }
  const maskBorder = computedStyle.maskBorder || computedStyle.webkitMaskBorder;
  if (maskBorder !== "none" && maskBorder !== void 0) {
    return { node, reason: `mask-border: ${maskBorder}` };
  }
  if (computedStyle.isolation === "isolate") {
    return { node, reason: `isolation: ${computedStyle.isolation}` };
  }
  if (computedStyle.willChange === "transform" || computedStyle.willChange === "opacity") {
    return { node, reason: `willChange: ${computedStyle.willChange}` };
  }
  if (computedStyle.webkitOverflowScrolling === "touch") {
    return { node, reason: "-webkit-overflow-scrolling: touch" };
  }
  if (computedStyle.zIndex !== "auto") {
    const parentStyle = globalThis.getComputedStyle(node.parentNode);
    if (parentStyle.display === "flex" || parentStyle.display === "inline-flex") {
      return { node, reason: `flex-item; z-index: ${computedStyle.zIndex}` };
    } else if (parentStyle.grid !== "none / none / none / row / auto / auto") {
      return { node, reason: `child of grid container; z-index: ${computedStyle.zIndex}` };
    }
  }
  const contain = computedStyle.contain;
  if (["layout", "paint", "strict", "content"].indexOf(contain) > -1 || contain.indexOf("paint") > -1 || contain.indexOf("layout") > -1) {
    return { node, reason: `contain: ${contain}` };
  }
  return getStackingContext(node.parentNode);
}
__name(getStackingContext, "getStackingContext");
const s_REGEX = /(\d+)\s*px/;
function styleParsePixels(value) {
  if (typeof value !== "string") {
    return void 0;
  }
  const isPixels = s_REGEX.test(value);
  const number = parseInt(value);
  return isPixels && Number.isFinite(number) ? number : void 0;
}
__name(styleParsePixels, "styleParsePixels");
const applicationShellContract = ["elementRoot"];
Object.freeze(applicationShellContract);
function isApplicationShell(component) {
  if (component === null || component === void 0) {
    return false;
  }
  let compHasContract = true;
  let protoHasContract = true;
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(component, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      compHasContract = false;
    }
  }
  const prototype = Object.getPrototypeOf(component);
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      protoHasContract = false;
    }
  }
  return compHasContract || protoHasContract;
}
__name(isApplicationShell, "isApplicationShell");
function isHMRProxy(comp) {
  const instanceName = comp?.constructor?.name;
  if (typeof instanceName === "string" && (instanceName.startsWith("Proxy<") || instanceName === "ProxyComponent")) {
    return true;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  return typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent");
}
__name(isHMRProxy, "isHMRProxy");
function isSvelteComponent(comp) {
  if (comp === null || comp === void 0 || typeof comp !== "function") {
    return false;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  if (typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent")) {
    return true;
  }
  return typeof window !== void 0 ? typeof comp.prototype.$destroy === "function" && typeof comp.prototype.$on === "function" : typeof comp.render === "function";
}
__name(isSvelteComponent, "isSvelteComponent");
async function outroAndDestroy(instance2) {
  return new Promise((resolve) => {
    if (instance2.$$.fragment && instance2.$$.fragment.o) {
      group_outros();
      transition_out(instance2.$$.fragment, 0, 0, () => {
        instance2.$destroy();
        resolve();
      });
      check_outros();
    } else {
      instance2.$destroy();
      resolve();
    }
  });
}
__name(outroAndDestroy, "outroAndDestroy");
function parseSvelteConfig(config, thisArg = void 0) {
  if (typeof config !== "object") {
    throw new TypeError(`parseSvelteConfig - 'config' is not an object:
${JSON.stringify(config)}.`);
  }
  if (!isSvelteComponent(config.class)) {
    throw new TypeError(
      `parseSvelteConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.hydrate !== void 0 && typeof config.hydrate !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.intro !== void 0 && typeof config.intro !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'intro' is not a boolean for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.target !== void 0 && typeof config.target !== "string" && !(config.target instanceof HTMLElement) && !(config.target instanceof ShadowRoot) && !(config.target instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.anchor !== void 0 && typeof config.anchor !== "string" && !(config.anchor instanceof HTMLElement) && !(config.anchor instanceof ShadowRoot) && !(config.anchor instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.context !== void 0 && typeof config.context !== "function" && !(config.context instanceof Map) && typeof config.context !== "object") {
    throw new TypeError(
      `parseSvelteConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.selectorTarget !== void 0 && typeof config.selectorTarget !== "string") {
    throw new TypeError(
      `parseSvelteConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.options !== void 0 && typeof config.options !== "object") {
    throw new TypeError(
      `parseSvelteConfig - 'options' is not an object for config:
${JSON.stringify(config)}.`
    );
  }
  if (config.options !== void 0) {
    if (config.options.injectApp !== void 0 && typeof config.options.injectApp !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.options.injectEventbus !== void 0 && typeof config.options.injectEventbus !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(config)}.`
      );
    }
    if (config.options.selectorElement !== void 0 && typeof config.options.selectorElement !== "string") {
      throw new TypeError(
        `parseSvelteConfig - 'selectorElement' is not a string for config:
${JSON.stringify(config)}.`
      );
    }
  }
  const svelteConfig = { ...config };
  delete svelteConfig.options;
  let externalContext = {};
  if (typeof svelteConfig.context === "function") {
    const contextFunc = svelteConfig.context;
    delete svelteConfig.context;
    const result = contextFunc.call(thisArg);
    if (typeof result === "object") {
      externalContext = { ...result };
    } else {
      throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(config)}`);
    }
  } else if (svelteConfig.context instanceof Map) {
    externalContext = Object.fromEntries(svelteConfig.context);
    delete svelteConfig.context;
  } else if (typeof svelteConfig.context === "object") {
    externalContext = svelteConfig.context;
    delete svelteConfig.context;
  }
  svelteConfig.props = s_PROCESS_PROPS(svelteConfig.props, thisArg, config);
  if (Array.isArray(svelteConfig.children)) {
    const children2 = [];
    for (let cntr = 0; cntr < svelteConfig.children.length; cntr++) {
      const child = svelteConfig.children[cntr];
      if (!isSvelteComponent(child.class)) {
        throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${cntr}] for config:
${JSON.stringify(config)}`);
      }
      child.props = s_PROCESS_PROPS(child.props, thisArg, config);
      children2.push(child);
    }
    if (children2.length > 0) {
      externalContext.children = children2;
    }
    delete svelteConfig.children;
  } else if (typeof svelteConfig.children === "object") {
    if (!isSvelteComponent(svelteConfig.children.class)) {
      throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(config)}`);
    }
    svelteConfig.children.props = s_PROCESS_PROPS(svelteConfig.children.props, thisArg, config);
    externalContext.children = [svelteConfig.children];
    delete svelteConfig.children;
  }
  if (!(svelteConfig.context instanceof Map)) {
    svelteConfig.context = /* @__PURE__ */ new Map();
  }
  svelteConfig.context.set("external", externalContext);
  return svelteConfig;
}
__name(parseSvelteConfig, "parseSvelteConfig");
function s_PROCESS_PROPS(props, thisArg, config) {
  if (typeof props === "function") {
    const result = props.call(thisArg);
    if (typeof result === "object") {
      return result;
    } else {
      throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(config)}`);
    }
  } else if (typeof props === "object") {
    return props;
  } else if (props !== void 0) {
    throw new Error(
      `parseSvelteConfig - 'props' is not a function or an object for config:
${JSON.stringify(config)}`
    );
  }
  return {};
}
__name(s_PROCESS_PROPS, "s_PROCESS_PROPS");
function hasGetter(object, accessor) {
  if (object === null || object === void 0) {
    return false;
  }
  const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);
  if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {
    return true;
  }
  for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {
    const descriptor = Object.getOwnPropertyDescriptor(o, accessor);
    if (descriptor !== void 0 && descriptor.get !== void 0) {
      return true;
    }
  }
  return false;
}
__name(hasGetter, "hasGetter");
function hasPrototype(target, Prototype) {
  if (typeof target !== "function") {
    return false;
  }
  if (target === Prototype) {
    return true;
  }
  for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {
    if (proto === Prototype) {
      return true;
    }
  }
  return false;
}
__name(hasPrototype, "hasPrototype");
const s_TAG_OBJECT = "[object Object]";
function deepMerge(target = {}, ...sourceObj) {
  if (Object.prototype.toString.call(target) !== s_TAG_OBJECT) {
    throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);
  }
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT) {
      throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);
    }
  }
  return _deepMerge(target, ...sourceObj);
}
__name(deepMerge, "deepMerge");
function isIterable(value) {
  if (value === null || value === void 0 || typeof value !== "object") {
    return false;
  }
  return typeof value[Symbol.iterator] === "function";
}
__name(isIterable, "isIterable");
function isObject(value) {
  return value !== null && typeof value === "object";
}
__name(isObject, "isObject");
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
__name(isPlainObject, "isPlainObject");
function safeAccess(data, accessor, defaultValue = void 0) {
  if (typeof data !== "object") {
    return defaultValue;
  }
  if (typeof accessor !== "string") {
    return defaultValue;
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (typeof data[access[cntr]] === "undefined" || data[access[cntr]] === null) {
      return defaultValue;
    }
    data = data[access[cntr]];
  }
  return data;
}
__name(safeAccess, "safeAccess");
function safeSet(data, accessor, value, operation = "set", createMissing = true) {
  if (typeof data !== "object") {
    throw new TypeError(`safeSet Error: 'data' is not an 'object'.`);
  }
  if (typeof accessor !== "string") {
    throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`);
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (Array.isArray(data)) {
      const number = +access[cntr];
      if (!Number.isInteger(number) || number < 0) {
        return false;
      }
    }
    if (cntr === access.length - 1) {
      switch (operation) {
        case "add":
          data[access[cntr]] += value;
          break;
        case "div":
          data[access[cntr]] /= value;
          break;
        case "mult":
          data[access[cntr]] *= value;
          break;
        case "set":
          data[access[cntr]] = value;
          break;
        case "set-undefined":
          if (typeof data[access[cntr]] === "undefined") {
            data[access[cntr]] = value;
          }
          break;
        case "sub":
          data[access[cntr]] -= value;
          break;
      }
    } else {
      if (createMissing && typeof data[access[cntr]] === "undefined") {
        data[access[cntr]] = {};
      }
      if (data[access[cntr]] === null || typeof data[access[cntr]] !== "object") {
        return false;
      }
      data = data[access[cntr]];
    }
  }
  return true;
}
__name(safeSet, "safeSet");
function _deepMerge(target = {}, ...sourceObj) {
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    const obj = sourceObj[cntr];
    for (const prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        if (prop.startsWith("-=")) {
          delete target[prop.slice(2)];
          continue;
        }
        target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object && obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];
      }
    }
  }
  return target;
}
__name(_deepMerge, "_deepMerge");
function getUUIDFromDataTransfer(data, { actor = true, compendium = true, world = true, types = void 0 } = {}) {
  if (typeof data !== "object") {
    return void 0;
  }
  if (Array.isArray(types) && !types.includes(data.type)) {
    return void 0;
  }
  let uuid = void 0;
  if (typeof data.uuid === "string") {
    const isCompendium = data.uuid.startsWith("Compendium");
    if (isCompendium && compendium) {
      uuid = data.uuid;
    } else if (world) {
      uuid = data.uuid;
    }
  } else {
    if (actor && world && data.actorId && data.type) {
      uuid = `Actor.${data.actorId}.${data.type}.${data.data._id}`;
    } else if (typeof data.id === "string") {
      if (compendium && typeof data.pack === "string") {
        uuid = `Compendium.${data.pack}.${data.id}`;
      } else if (world) {
        uuid = `${data.type}.${data.id}`;
      }
    }
  }
  return uuid;
}
__name(getUUIDFromDataTransfer, "getUUIDFromDataTransfer");
class DynReducerUtils {
  static arrayEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (a === null || b === null) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let cntr = a.length; --cntr >= 0; ) {
      if (a[cntr] !== b[cntr]) {
        return false;
      }
    }
    return true;
  }
  static hashString(str, seed = 0) {
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    for (let ch, i = 0; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }
  static hashUnknown(value) {
    if (value === null || value === void 0) {
      return 0;
    }
    let result = 0;
    switch (typeof value) {
      case "boolean":
        result = value ? 1 : 0;
        break;
      case "bigint":
        result = Number(BigInt.asIntN(64, value));
        break;
      case "function":
        result = this.hashString(value.name);
        break;
      case "number":
        result = Number.isFinite(value) ? value : 0;
        break;
      case "object":
        break;
      case "string":
        result = this.hashString(value);
        break;
      case "symbol":
        result = this.hashString(Symbol.keyFor(value));
        break;
    }
    return result;
  }
  static hasPrototype(target, Prototype) {
    if (typeof target !== "function") {
      return false;
    }
    if (target === Prototype) {
      return true;
    }
    for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {
      if (proto === Prototype) {
        return true;
      }
    }
    return false;
  }
  static isIterable(data) {
    return data !== null && data !== void 0 && typeof data === "object" && typeof data[Symbol.iterator] === "function";
  }
}
__name(DynReducerUtils, "DynReducerUtils");
class AdapterDerived {
  #hostData;
  #DerivedReducerCtor;
  #parentIndex;
  #derived = /* @__PURE__ */ new Map();
  #destroyed = false;
  constructor(hostData, parentIndex, DerivedReducerCtor) {
    this.#hostData = hostData;
    this.#parentIndex = parentIndex;
    this.#DerivedReducerCtor = DerivedReducerCtor;
    Object.freeze(this);
  }
  create(options) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.create error: this instance has been destroyed.`);
    }
    let name;
    let rest = {};
    let ctor;
    const DerivedReducerCtor = this.#DerivedReducerCtor;
    if (typeof options === "string") {
      name = options;
      ctor = DerivedReducerCtor;
    } else if (typeof options === "function" && DynReducerUtils.hasPrototype(options, DerivedReducerCtor)) {
      ctor = options;
    } else if (typeof options === "object" && options !== null) {
      ({ name, ctor = DerivedReducerCtor, ...rest } = options);
    } else {
      throw new TypeError(`AdapterDerived.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!DynReducerUtils.hasPrototype(ctor, DerivedReducerCtor)) {
      throw new TypeError(`AdapterDerived.create error: 'ctor' is not a '${DerivedReducerCtor?.name}'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`AdapterDerived.create error: 'name' is not a string.`);
    }
    const derivedReducer = new ctor(this.#hostData, this.#parentIndex, rest);
    this.#derived.set(name, derivedReducer);
    return derivedReducer;
  }
  clear() {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.destroy();
    }
    this.#derived.clear();
  }
  delete(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.delete error: this instance has been destroyed.`);
    }
    const reducer = this.#derived.get(name);
    if (reducer) {
      reducer.destroy();
    }
    return this.#derived.delete(name);
  }
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.clear();
    this.#hostData = [null];
    this.#parentIndex = null;
    this.#destroyed = true;
  }
  get(name) {
    if (this.#destroyed) {
      throw Error(`AdapterDerived.get error: this instance has been destroyed.`);
    }
    return this.#derived.get(name);
  }
  update(force = false) {
    if (this.#destroyed) {
      return;
    }
    for (const reducer of this.#derived.values()) {
      reducer.index.update(force);
    }
  }
}
__name(AdapterDerived, "AdapterDerived");
class AdapterFilters {
  #filtersData;
  #indexUpdate;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  constructor(indexUpdate, filtersAdapter) {
    this.#indexUpdate = indexUpdate;
    this.#filtersData = filtersAdapter;
    Object.freeze(this);
  }
  get length() {
    return this.#filtersData.filters.length;
  }
  *[Symbol.iterator]() {
    if (this.#filtersData.filters.length === 0) {
      return;
    }
    for (const entry of this.#filtersData.filters) {
      yield { ...entry };
    }
  }
  add(...filters) {
    let subscribeCount = 0;
    for (const filter of filters) {
      const filterType = typeof filter;
      if (filterType !== "function" && (filterType !== "object" || filter === null)) {
        throw new TypeError(`AdapterFilters error: 'filter' is not a function or object.`);
      }
      let data = void 0;
      let subscribeFn = void 0;
      if (filterType === "function") {
        data = {
          id: void 0,
          filter,
          weight: 1
        };
        subscribeFn = filter.subscribe;
      } else if (filterType === "object") {
        if ("filter" in filter) {
          if (typeof filter.filter !== "function") {
            throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
          }
          if (filter.weight !== void 0 && typeof filter.weight !== "number" || (filter.weight < 0 || filter.weight > 1)) {
            throw new TypeError(`AdapterFilters error: 'weight' attribute is not a number between '0 - 1' inclusive.`);
          }
          data = {
            id: filter.id !== void 0 ? filter.id : void 0,
            filter: filter.filter,
            weight: filter.weight || 1
          };
          subscribeFn = filter.filter.subscribe ?? filter.subscribe;
        } else {
          throw new TypeError(`AdapterFilters error: 'filter' attribute is not a function.`);
        }
      }
      const index = this.#filtersData.filters.findIndex((value) => {
        return data.weight < value.weight;
      });
      if (index >= 0) {
        this.#filtersData.filters.splice(index, 0, data);
      } else {
        this.#filtersData.filters.push(data);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn(this.#indexUpdate);
        if (typeof unsubscribe !== "function") {
          throw new TypeError("AdapterFilters error: Filter has subscribe function, but no unsubscribe function is returned.");
        }
        if (this.#mapUnsubscribe.has(data.filter)) {
          throw new Error("AdapterFilters error: Filter added already has an unsubscribe function registered.");
        }
        this.#mapUnsubscribe.set(data.filter, unsubscribe);
        subscribeCount++;
      }
    }
    if (subscribeCount < filters.length) {
      this.#indexUpdate();
    }
  }
  clear() {
    this.#filtersData.filters.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
    this.#indexUpdate();
  }
  remove(...filters) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    for (const data of filters) {
      const actualFilter = typeof data === "function" ? data : data !== null && typeof data === "object" ? data.filter : void 0;
      if (!actualFilter) {
        continue;
      }
      for (let cntr = this.#filtersData.filters.length; --cntr >= 0; ) {
        if (this.#filtersData.filters[cntr].filter === actualFilter) {
          this.#filtersData.filters.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualFilter)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualFilter);
          }
        }
      }
    }
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
  removeBy(callback) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterFilters error: 'callback' is not a function.`);
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data) => {
      const remove = callback.call(callback, { ...data });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
  removeById(...ids) {
    const length = this.#filtersData.filters.length;
    if (length === 0) {
      return;
    }
    this.#filtersData.filters = this.#filtersData.filters.filter((data) => {
      let remove = 0;
      for (const id of ids) {
        remove |= data.id === id ? 1 : 0;
      }
      if (!!remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.filter)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.filter);
        }
      }
      return !remove;
    });
    if (length !== this.#filtersData.filters.length) {
      this.#indexUpdate();
    }
  }
}
__name(AdapterFilters, "AdapterFilters");
class AdapterIndexer {
  derivedAdapter;
  filtersData;
  hostData;
  hostUpdate;
  indexData;
  sortData;
  sortFn;
  destroyed = false;
  constructor(hostData, hostUpdate, parentIndexer) {
    this.hostData = hostData;
    this.hostUpdate = hostUpdate;
    this.indexData = { index: null, hash: null, reversed: false, parent: parentIndexer };
  }
  get active() {
    return this.filtersData.filters.length > 0 || this.sortData.compareFn !== null || this.indexData.parent?.active === true;
  }
  get length() {
    return this.indexData.index ? this.indexData.index.length : 0;
  }
  get reversed() {
    return this.indexData.reversed;
  }
  set reversed(reversed) {
    this.indexData.reversed = reversed;
  }
  calcHashUpdate(oldIndex, oldHash, force = false) {
    const actualForce = typeof force === "boolean" ? force : false;
    let newHash = null;
    const newIndex = this.indexData.index;
    if (newIndex) {
      for (let cntr = newIndex.length; --cntr >= 0; ) {
        newHash ^= DynReducerUtils.hashUnknown(newIndex[cntr]) + 2654435769 + (newHash << 6) + (newHash >> 2);
      }
    }
    this.indexData.hash = newHash;
    if (actualForce || (oldHash === newHash ? !DynReducerUtils.arrayEquals(oldIndex, newIndex) : true)) {
      this.hostUpdate();
    }
  }
  destroy() {
    if (this.destroyed) {
      return;
    }
    this.indexData.index = null;
    this.indexData.hash = null;
    this.indexData.reversed = null;
    this.indexData.parent = null;
    this.destroyed = true;
  }
  initAdapters(filtersData, sortData, derivedAdapter) {
    this.filtersData = filtersData;
    this.sortData = sortData;
    this.derivedAdapter = derivedAdapter;
    this.sortFn = this.createSortFn();
  }
}
__name(AdapterIndexer, "AdapterIndexer");
class AdapterSort {
  #sortData;
  #indexUpdate;
  #unsubscribe;
  constructor(indexUpdate, sortData) {
    this.#indexUpdate = indexUpdate;
    this.#sortData = sortData;
    Object.freeze(this);
  }
  clear() {
    const oldCompareFn = this.#sortData.compareFn;
    this.#sortData.compareFn = null;
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    if (typeof oldCompareFn === "function") {
      this.#indexUpdate();
    }
  }
  set(data) {
    if (typeof this.#unsubscribe === "function") {
      this.#unsubscribe();
      this.#unsubscribe = void 0;
    }
    let compareFn = void 0;
    let subscribeFn = void 0;
    switch (typeof data) {
      case "function":
        compareFn = data;
        subscribeFn = data.subscribe;
        break;
      case "object":
        if (data === null) {
          break;
        }
        if (typeof data.compare !== "function") {
          throw new TypeError(`AdapterSort error: 'compare' attribute is not a function.`);
        }
        compareFn = data.compare;
        subscribeFn = data.compare.subscribe ?? data.subscribe;
        break;
    }
    if (typeof compareFn === "function") {
      this.#sortData.compareFn = compareFn;
    } else {
      const oldCompareFn = this.#sortData.compareFn;
      this.#sortData.compareFn = null;
      if (typeof oldCompareFn === "function") {
        this.#indexUpdate();
      }
      return;
    }
    if (typeof subscribeFn === "function") {
      this.#unsubscribe = subscribeFn(this.#indexUpdate);
      if (typeof this.#unsubscribe !== "function") {
        throw new Error(`AdapterSort error: sort has 'subscribe' function, but no 'unsubscribe' function is returned.`);
      }
    } else {
      this.#indexUpdate();
    }
  }
}
__name(AdapterSort, "AdapterSort");
class IndexerAPI {
  #indexData;
  active;
  length;
  update;
  constructor(adapterIndexer) {
    this.#indexData = adapterIndexer.indexData;
    this.update = adapterIndexer.update.bind(adapterIndexer);
    Object.defineProperties(this, {
      active: { get: () => adapterIndexer.active },
      length: { get: () => adapterIndexer.length }
    });
    Object.freeze(this);
  }
  get hash() {
    return this.#indexData.hash;
  }
  *[Symbol.iterator]() {
    const indexData = this.#indexData;
    if (!indexData.index) {
      return;
    }
    const reversed = indexData.reversed;
    const length = indexData.index.length;
    if (reversed) {
      for (let cntr = length; --cntr >= 0; ) {
        yield indexData.index[cntr];
      }
    } else {
      for (let cntr = 0; cntr < length; cntr++) {
        yield indexData.index[cntr];
      }
    }
  }
}
__name(IndexerAPI, "IndexerAPI");
class DerivedAPI {
  clear;
  create;
  delete;
  destroy;
  get;
  constructor(adapterDerived) {
    this.clear = adapterDerived.clear.bind(adapterDerived);
    this.create = adapterDerived.create.bind(adapterDerived);
    this.delete = adapterDerived.delete.bind(adapterDerived);
    this.destroy = adapterDerived.destroy.bind(adapterDerived);
    this.get = adapterDerived.get.bind(adapterDerived);
    Object.freeze(this);
  }
}
__name(DerivedAPI, "DerivedAPI");
class Indexer extends AdapterIndexer {
  createSortFn() {
    return (a, b) => this.sortData.compareFn(this.hostData[0].get(a), this.hostData[0].get(b));
  }
  reduceImpl() {
    const data = [];
    const map = this.hostData[0];
    if (!map) {
      return data;
    }
    const filters = this.filtersData.filters;
    let include = true;
    const parentIndex = this.indexData.parent;
    if (DynReducerUtils.isIterable(parentIndex) && parentIndex.active) {
      for (const key of parentIndex) {
        const value = map.get(key);
        include = true;
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data.push(key);
        }
      }
    } else {
      for (const key of map.keys()) {
        include = true;
        const value = map.get(key);
        for (let filCntr = 0, filLength = filters.length; filCntr < filLength; filCntr++) {
          if (!filters[filCntr].filter(value)) {
            include = false;
            break;
          }
        }
        if (include) {
          data.push(key);
        }
      }
    }
    return data;
  }
  update(force = false) {
    if (this.destroyed) {
      return;
    }
    const oldIndex = this.indexData.index;
    const oldHash = this.indexData.hash;
    const map = this.hostData[0];
    const parentIndex = this.indexData.parent;
    if (this.filtersData.filters.length === 0 && !this.sortData.compareFn || this.indexData.index && map?.size !== this.indexData.index.length) {
      this.indexData.index = null;
    }
    if (this.filtersData.filters.length > 0) {
      this.indexData.index = this.reduceImpl();
    }
    if (!this.indexData.index && parentIndex?.active) {
      this.indexData.index = [...parentIndex];
    }
    if (this.sortData.compareFn && map instanceof Map) {
      if (!this.indexData.index) {
        this.indexData.index = this.indexData.index = [...map.keys()];
      }
      this.indexData.index.sort(this.sortFn);
    }
    this.calcHashUpdate(oldIndex, oldHash, force);
    this.derivedAdapter?.update(force);
  }
}
__name(Indexer, "Indexer");
class DerivedMapReducer {
  #map;
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  constructor(map, parentIndex, options) {
    this.#map = map;
    this.#index = new Indexer(this.#map, this.#updateSubscribers.bind(this), parentIndex);
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DerivedMapReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    let filters = void 0;
    let sort = void 0;
    if (options !== void 0 && ("filters" in options || "sort" in options)) {
      if (options.filters !== void 0) {
        if (DynReducerUtils.isIterable(options.filters)) {
          filters = options.filters;
        } else {
          throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'filters' attribute is not iterable.`);
        }
      }
      if (options.sort !== void 0) {
        if (typeof options.sort === "function") {
          sort = options.sort;
        } else if (typeof options.sort === "object" && options.sort !== null) {
          sort = options.sort;
        } else {
          throw new TypeError(`DerivedMapReducer error (DataDerivedOptions): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  get data() {
    return this.#map[0];
  }
  get derived() {
    return this.#derivedPublicAPI;
  }
  get filters() {
    return this.#filters;
  }
  get index() {
    return this.#indexPublicAPI;
  }
  get destroyed() {
    return this.#destroyed;
  }
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.index.length : map ? map.size : 0;
  }
  get reversed() {
    return this.#reversed;
  }
  get sort() {
    return this.#sort;
  }
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DerivedMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  destroy() {
    this.#destroyed = true;
    this.#map = [null];
    this.#index.update(true);
    this.#subscriptions.length = 0;
    this.#derived.destroy();
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  initialize() {
  }
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
}
__name(DerivedMapReducer, "DerivedMapReducer");
class DynMapReducer {
  #map = [null];
  #derived;
  #derivedPublicAPI;
  #filters;
  #filtersData = { filters: [] };
  #index;
  #indexPublicAPI;
  #reversed = false;
  #sort;
  #sortData = { compareFn: null };
  #subscriptions = [];
  #destroyed = false;
  constructor(data) {
    let dataMap = void 0;
    let filters = void 0;
    let sort = void 0;
    if (data === null) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data !== void 0 && typeof data !== "object" && !(data instanceof Map)) {
      throw new TypeError(`DynMapReducer error: 'data' is not an object or Map.`);
    }
    if (data !== void 0 && data instanceof Map) {
      dataMap = data;
    } else if (data !== void 0 && ("data" in data || "filters" in data || "sort" in data)) {
      if (data.data !== void 0 && !(data.data instanceof Map)) {
        throw new TypeError(`DynMapReducer error (DataDynMap): 'data' attribute is not a Map.`);
      }
      dataMap = data.data;
      if (data.filters !== void 0) {
        if (DynReducerUtils.isIterable(data.filters)) {
          filters = data.filters;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'filters' attribute is not iterable.`);
        }
      }
      if (data.sort !== void 0) {
        if (typeof data.sort === "function") {
          sort = data.sort;
        } else if (typeof data.sort === "object" && data.sort !== null) {
          sort = data.sort;
        } else {
          throw new TypeError(`DynMapReducer error (DataDynMap): 'sort' attribute is not a function or object.`);
        }
      }
    }
    if (dataMap) {
      this.#map[0] = dataMap;
    }
    this.#index = new Indexer(this.#map, this.#updateSubscribers.bind(this));
    this.#indexPublicAPI = new IndexerAPI(this.#index);
    this.#filters = new AdapterFilters(this.#indexPublicAPI.update, this.#filtersData);
    this.#sort = new AdapterSort(this.#indexPublicAPI.update, this.#sortData);
    this.#derived = new AdapterDerived(this.#map, this.#indexPublicAPI, DerivedMapReducer);
    this.#derivedPublicAPI = new DerivedAPI(this.#derived);
    this.#index.initAdapters(this.#filtersData, this.#sortData, this.#derived);
    if (filters) {
      this.filters.add(...filters);
    }
    if (sort) {
      this.sort.set(sort);
    }
    this.initialize();
  }
  get data() {
    return this.#map[0];
  }
  get derived() {
    return this.#derivedPublicAPI;
  }
  get filters() {
    return this.#filters;
  }
  get index() {
    return this.#indexPublicAPI;
  }
  get destroyed() {
    return this.#destroyed;
  }
  get length() {
    const map = this.#map[0];
    return this.#index.active ? this.#indexPublicAPI.length : map ? map.size : 0;
  }
  get reversed() {
    return this.#reversed;
  }
  get sort() {
    return this.#sort;
  }
  set reversed(reversed) {
    if (typeof reversed !== "boolean") {
      throw new TypeError(`DynMapReducer.reversed error: 'reversed' is not a boolean.`);
    }
    this.#reversed = reversed;
    this.#index.reversed = reversed;
    this.index.update(true);
  }
  destroy() {
    if (this.#destroyed) {
      return;
    }
    this.#destroyed = true;
    this.#derived.destroy();
    this.#map = [null];
    this.index.update(true);
    this.#subscriptions.length = 0;
    this.#index.destroy();
    this.#filters.clear();
    this.#sort.clear();
  }
  initialize() {
  }
  setData(data, replace = false) {
    if (data !== null && !(data instanceof Map)) {
      throw new TypeError(`DynMapReducer.setData error: 'data' is not iterable.`);
    }
    if (typeof replace !== "boolean") {
      throw new TypeError(`DynMapReducer.setData error: 'replace' is not a boolean.`);
    }
    const map = this.#map[0];
    if (!(map instanceof Map) || replace) {
      this.#map[0] = data instanceof Map ? data : null;
    } else if (data instanceof Map && map instanceof Map) {
      const removeKeySet = new Set(map.keys());
      for (const key of data.keys()) {
        map.set(key, data.get(key));
        if (removeKeySet.has(key)) {
          removeKeySet.delete(key);
        }
      }
      for (const key of removeKeySet) {
        map.delete(key);
      }
    } else if (data === null) {
      this.#map[0] = null;
    }
    this.index.update(true);
  }
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updateSubscribers() {
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](this);
    }
  }
  *[Symbol.iterator]() {
    const map = this.#map[0];
    if (this.#destroyed || map === null || map?.size === 0) {
      return;
    }
    if (this.#index.active) {
      for (const key of this.index) {
        yield map.get(key);
      }
    } else {
      if (this.reversed) {
        const values = [...map.values()];
        for (let cntr = values.length; --cntr >= 0; ) {
          yield values[cntr];
        }
      } else {
        for (const value of map.values()) {
          yield value;
        }
      }
    }
  }
}
__name(DynMapReducer, "DynMapReducer");
function isUpdatableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.update === "function";
  }
  return false;
}
__name(isUpdatableStore, "isUpdatableStore");
function isWritableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.set === "function";
  }
  return false;
}
__name(isWritableStore, "isWritableStore");
function subscribeIgnoreFirst(store, update2) {
  let firedFirst = false;
  return store.subscribe((value) => {
    if (!firedFirst) {
      firedFirst = true;
    } else {
      update2(value);
    }
  });
}
__name(subscribeIgnoreFirst, "subscribeIgnoreFirst");
function writableDerived(origins, derive, reflect, initial) {
  var childDerivedSetter, originValues, blockNextDerive = false;
  var reflectOldValues = "withOld" in reflect;
  var wrappedDerive = /* @__PURE__ */ __name((got, set) => {
    childDerivedSetter = set;
    if (reflectOldValues) {
      originValues = got;
    }
    if (!blockNextDerive) {
      let returned = derive(got, set);
      if (derive.length < 2) {
        set(returned);
      } else {
        return returned;
      }
    }
    blockNextDerive = false;
  }, "wrappedDerive");
  var childDerived = derived(origins, wrappedDerive, initial);
  var singleOrigin = !Array.isArray(origins);
  var sendUpstream = /* @__PURE__ */ __name((setWith) => {
    if (singleOrigin) {
      blockNextDerive = true;
      origins.set(setWith);
    } else {
      setWith.forEach((value, i) => {
        blockNextDerive = true;
        origins[i].set(value);
      });
    }
    blockNextDerive = false;
  }, "sendUpstream");
  if (reflectOldValues) {
    reflect = reflect.withOld;
  }
  var reflectIsAsync = reflect.length >= (reflectOldValues ? 3 : 2);
  var cleanup = null;
  function doReflect(reflecting) {
    if (cleanup) {
      cleanup();
      cleanup = null;
    }
    if (reflectOldValues) {
      var returned = reflect(reflecting, originValues, sendUpstream);
    } else {
      var returned = reflect(reflecting, sendUpstream);
    }
    if (reflectIsAsync) {
      if (typeof returned == "function") {
        cleanup = returned;
      }
    } else {
      sendUpstream(returned);
    }
  }
  __name(doReflect, "doReflect");
  var tryingSet = false;
  function update2(fn) {
    var isUpdated, mutatedBySubscriptions, oldValue, newValue;
    if (tryingSet) {
      newValue = fn(get_store_value(childDerived));
      childDerivedSetter(newValue);
      return;
    }
    var unsubscribe = childDerived.subscribe((value) => {
      if (!tryingSet) {
        oldValue = value;
      } else if (!isUpdated) {
        isUpdated = true;
      } else {
        mutatedBySubscriptions = true;
      }
    });
    newValue = fn(oldValue);
    tryingSet = true;
    childDerivedSetter(newValue);
    unsubscribe();
    tryingSet = false;
    if (mutatedBySubscriptions) {
      newValue = get_store_value(childDerived);
    }
    if (isUpdated) {
      doReflect(newValue);
    }
  }
  __name(update2, "update");
  return {
    subscribe: childDerived.subscribe,
    set(value) {
      update2(() => value);
    },
    update: update2
  };
}
__name(writableDerived, "writableDerived");
function propertyStore(origin, propName) {
  if (!Array.isArray(propName)) {
    return writableDerived(
      origin,
      (object) => object[propName],
      { withOld(reflecting, object) {
        object[propName] = reflecting;
        return object;
      } }
    );
  } else {
    let props = propName.concat();
    return writableDerived(
      origin,
      (value) => {
        for (let i = 0; i < props.length; ++i) {
          value = value[props[i]];
        }
        return value;
      },
      { withOld(reflecting, object) {
        let target = object;
        for (let i = 0; i < props.length - 1; ++i) {
          target = target[props[i]];
        }
        target[props[props.length - 1]] = reflecting;
        return object;
      } }
    );
  }
}
__name(propertyStore, "propertyStore");
class EmbeddedStoreManager {
  static #renderContextRegex = /(create|delete|update)(\w+)/;
  #name = /* @__PURE__ */ new Map();
  #document;
  #embeddedNames = /* @__PURE__ */ new Set();
  constructor(document2) {
    this.#document = document2;
    this.handleDocChange();
  }
  create(embeddedName, options) {
    const doc = this.#document[0];
    let collection = null;
    if (doc) {
      try {
        collection = doc.getEmbeddedCollection(embeddedName);
      } catch (err) {
        console.warn(`EmbeddedStoreManager.create error: No valid embedded collection for: ${embeddedName}`);
      }
    }
    let embeddedData;
    if (!this.#name.has(embeddedName)) {
      embeddedData = {
        collection,
        stores: /* @__PURE__ */ new Map()
      };
      this.#name.set(embeddedName, embeddedData);
    } else {
      embeddedData = this.#name.get(embeddedName);
    }
    let name;
    let rest = {};
    let ctor;
    if (typeof options === "string") {
      name = options;
      ctor = DynMapReducer;
    } else if (typeof options === "function" && hasPrototype(options, DynMapReducer)) {
      ctor = options;
    } else if (typeof options === "object" && options !== null) {
      ({ name, ctor = DynMapReducer, ...rest } = options);
    } else {
      throw new TypeError(`EmbeddedStoreManager.create error: 'options' does not conform to allowed parameters.`);
    }
    if (!hasPrototype(ctor, DynMapReducer)) {
      throw new TypeError(`EmbeddedStoreManager.create error: 'ctor' is not a 'DynMapReducer'.`);
    }
    name = name ?? ctor?.name;
    if (typeof name !== "string") {
      throw new TypeError(`EmbeddedStoreManager.create error: 'name' is not a string.`);
    }
    if (embeddedData.stores.has(name)) {
      return embeddedData.stores.get(name);
    } else {
      const storeOptions = collection ? { data: collection, ...rest } : { ...rest };
      const store = new ctor(storeOptions);
      embeddedData.stores.set(name, store);
      return store;
    }
  }
  destroy(embeddedName, storeName) {
    let count = 0;
    if (embeddedName === void 0) {
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.destroy();
          count++;
        }
      }
      this.#name.clear();
    } else if (typeof embeddedName === "string" && storeName === void 0) {
      const embeddedData = this.#name.get(embeddedName);
      if (embeddedData) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.destroy();
          count++;
        }
      }
      this.#name.delete(embeddedName);
    } else if (typeof embeddedName === "string" && storeName === "string") {
      const embeddedData = this.#name.get(embeddedName);
      if (embeddedData) {
        const store = embeddedData.stores.get(storeName);
        if (store) {
          store.destroy();
          count++;
        }
      }
    }
    return count > 0;
  }
  get(embeddedName, storeName) {
    if (!this.#name.has(embeddedName)) {
      return void 0;
    }
    return this.#name.get(embeddedName).stores.get(storeName);
  }
  handleDocChange() {
    const doc = this.#document[0];
    if (doc instanceof foundry.abstract.Document) {
      const existingEmbeddedNames = new Set(this.#name.keys());
      const embeddedNames = Object.keys(doc.constructor?.metadata?.embedded ?? []);
      this.#embeddedNames.clear();
      for (const embeddedName of embeddedNames) {
        existingEmbeddedNames.delete(embeddedName);
        this.#embeddedNames.add(`create${embeddedName}`);
        this.#embeddedNames.add(`delete${embeddedName}`);
        this.#embeddedNames.add(`update${embeddedName}`);
        let collection = null;
        try {
          collection = doc.getEmbeddedCollection(embeddedName);
        } catch (err) {
          console.warn(`EmbeddedStoreManager.handleDocUpdate error: No valid embedded collection for: ${embeddedName}`);
        }
        const embeddedData = this.#name.get(embeddedName);
        if (embeddedData) {
          embeddedData.collection = collection;
          for (const store of embeddedData.stores.values()) {
            store.setData(collection, true);
          }
        }
      }
      for (const embeddedName of existingEmbeddedNames) {
        const embeddedData = this.#name.get(embeddedName);
        if (embeddedData) {
          embeddedData.collection = null;
          for (const store of embeddedData.stores.values()) {
            store.setData(null, true);
          }
        }
      }
    } else {
      this.#embeddedNames.clear();
      for (const embeddedData of this.#name.values()) {
        embeddedData.collection = null;
        for (const store of embeddedData.stores.values()) {
          store.setData(null, true);
        }
      }
    }
  }
  handleUpdate(renderContext) {
    if (!this.#embeddedNames.has(renderContext)) {
      return;
    }
    const match = EmbeddedStoreManager.#renderContextRegex.exec(renderContext);
    if (match) {
      const embeddedName = match[2];
      if (!this.#name.has(embeddedName)) {
        return;
      }
      for (const store of this.#name.get(embeddedName).stores.values()) {
        store.index.update(true);
      }
    }
  }
}
__name(EmbeddedStoreManager, "EmbeddedStoreManager");
class TJSDocument {
  #document = [void 0];
  #embeddedStoreManager;
  #embeddedAPI;
  #uuidv4;
  #options = { delete: void 0 };
  #subscriptions = [];
  #updateOptions;
  constructor(document2, options = {}) {
    this.#uuidv4 = `tjs-document-${uuidv4()}`;
    if (isPlainObject(document2)) {
      this.setOptions(document2);
    } else {
      this.setOptions(options);
      this.set(document2);
    }
  }
  get embedded() {
    if (!this.#embeddedAPI) {
      this.#embeddedStoreManager = new EmbeddedStoreManager(this.#document);
      this.#embeddedAPI = {
        create: (embeddedName, options) => this.#embeddedStoreManager.create(embeddedName, options),
        destroy: (embeddedName, storeName) => this.#embeddedStoreManager.destroy(embeddedName, storeName),
        get: (embeddedName, storeName) => this.#embeddedStoreManager.get(embeddedName, storeName)
      };
    }
    return this.#embeddedAPI;
  }
  get updateOptions() {
    return this.#updateOptions ?? {};
  }
  get uuidv4() {
    return this.#uuidv4;
  }
  async #deleted() {
    const doc = this.#document[0];
    if (doc instanceof foundry.abstract.Document && !doc?.collection?.has(doc.id)) {
      delete doc?.apps[this.#uuidv4];
      this.#setDocument(void 0);
      if (typeof this.#options.delete === "function") {
        await this.#options.delete();
      }
      this.#updateSubscribers(false, { action: "delete", data: void 0 });
      this.#updateOptions = void 0;
    }
  }
  destroy() {
    const doc = this.#document[0];
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.destroy();
      this.#embeddedStoreManager = void 0;
      this.#embeddedAPI = void 0;
    }
    if (doc instanceof foundry.abstract.Document) {
      delete doc?.apps[this.#uuidv4];
      this.#setDocument(void 0);
    }
    this.#options.delete = void 0;
    this.#subscriptions.length = 0;
  }
  #updateSubscribers(force = false, options = {}) {
    this.#updateOptions = options;
    const doc = this.#document[0];
    for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) {
      this.#subscriptions[cntr](doc, options);
    }
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleUpdate(options.renderContext);
    }
  }
  get() {
    return this.#document[0];
  }
  set(document2, options = {}) {
    if (this.#document[0]) {
      delete this.#document[0].apps[this.#uuidv4];
    }
    if (document2 !== void 0 && !(document2 instanceof foundry.abstract.Document)) {
      throw new TypeError(`TJSDocument set error: 'document' is not a valid Document or undefined.`);
    }
    if (options === null || typeof options !== "object") {
      throw new TypeError(`TJSDocument set error: 'options' is not an object.`);
    }
    if (document2 instanceof foundry.abstract.Document) {
      document2.apps[this.#uuidv4] = {
        close: this.#deleted.bind(this),
        render: this.#updateSubscribers.bind(this)
      };
    }
    this.#setDocument(document2);
    this.#updateOptions = options;
    this.#updateSubscribers();
  }
  #setDocument(doc) {
    this.#document[0] = doc;
    if (this.#embeddedStoreManager) {
      this.#embeddedStoreManager.handleDocChange();
    }
  }
  async setFromDataTransfer(data, options) {
    return this.setFromUUID(getUUIDFromDataTransfer(data, options), options);
  }
  async setFromUUID(uuid, options = {}) {
    if (typeof uuid !== "string" || uuid.length === 0) {
      return false;
    }
    try {
      const doc = await globalThis.fromUuid(uuid);
      if (doc) {
        this.set(doc, options);
        return true;
      }
    } catch (err) {
    }
    return false;
  }
  setOptions(options) {
    if (!isObject(options)) {
      throw new TypeError(`TJSDocument error: 'options' is not a plain object.`);
    }
    if (options.delete !== void 0 && typeof options.delete !== "function") {
      throw new TypeError(`TJSDocument error: 'delete' attribute in options is not a function.`);
    }
    if (options.delete === void 0 || typeof options.delete === "function") {
      this.#options.delete = options.delete;
    }
  }
  subscribe(handler) {
    this.#subscriptions.push(handler);
    const updateOptions = { action: "subscribe", data: void 0 };
    handler(this.#document[0], updateOptions);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
}
__name(TJSDocument, "TJSDocument");
const storeState = writable(void 0);
const gameState = {
  subscribe: storeState.subscribe,
  get: () => game
};
Object.freeze(gameState);
Hooks.once("ready", () => storeState.set(game));
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
__name(cubicOut, "cubicOut");
function quintOut(t) {
  return --t * t * t * t * t + 1;
}
__name(quintOut, "quintOut");
function lerp$5(start, end, amount) {
  return (1 - amount) * start + amount * end;
}
__name(lerp$5, "lerp$5");
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
__name(degToRad, "degToRad");
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function create$6() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
__name(create$6, "create$6");
function create$5() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
__name(create$5, "create$5");
function clone$5(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
__name(clone$5, "clone$5");
function copy$5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
__name(copy$5, "copy$5");
function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
__name(fromValues$5, "fromValues$5");
function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
__name(set$5, "set$5");
function identity$2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(identity$2, "identity$2");
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
__name(transpose, "transpose");
function invert$2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
__name(invert$2, "invert$2");
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
__name(adjoint, "adjoint");
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
__name(determinant, "determinant");
function multiply$5(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
__name(multiply$5, "multiply$5");
function translate$1(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
__name(translate$1, "translate$1");
function scale$5(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
__name(scale$5, "scale$5");
function rotate$1(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
__name(rotate$1, "rotate$1");
function rotateX$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
__name(rotateX$3, "rotateX$3");
function rotateY$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
__name(rotateY$3, "rotateY$3");
function rotateZ$3(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
__name(rotateZ$3, "rotateZ$3");
function fromTranslation$1(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
__name(fromTranslation$1, "fromTranslation$1");
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromScaling, "fromScaling");
function fromRotation$1(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromRotation$1, "fromRotation$1");
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromXRotation, "fromXRotation");
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromYRotation, "fromYRotation");
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromZRotation, "fromZRotation");
function fromRotationTranslation$1(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
__name(fromRotationTranslation$1, "fromRotationTranslation$1");
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation$1(out, a, translation);
  return out;
}
__name(fromQuat2, "fromQuat2");
function getTranslation$1(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
__name(getTranslation$1, "getTranslation$1");
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
__name(getScaling, "getScaling");
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
__name(getRotation, "getRotation");
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
__name(fromRotationTranslationScale, "fromRotationTranslationScale");
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
__name(fromRotationTranslationScaleOrigin, "fromRotationTranslationScaleOrigin");
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
__name(fromQuat, "fromQuat");
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
__name(frustum, "frustum");
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
__name(perspectiveNO, "perspectiveNO");
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
__name(perspectiveZO, "perspectiveZO");
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
__name(perspectiveFromFieldOfView, "perspectiveFromFieldOfView");
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
__name(orthoNO, "orthoNO");
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
__name(orthoZO, "orthoZO");
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity$2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
__name(lookAt, "lookAt");
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
__name(targetTo, "targetTo");
function str$5(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
__name(str$5, "str$5");
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
__name(frob, "frob");
function add$5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
__name(add$5, "add$5");
function subtract$3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
__name(subtract$3, "subtract$3");
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
__name(multiplyScalar, "multiplyScalar");
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
__name(multiplyScalarAndAdd, "multiplyScalarAndAdd");
function exactEquals$5(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
__name(exactEquals$5, "exactEquals$5");
function equals$5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
__name(equals$5, "equals$5");
var mul$5 = multiply$5;
var sub$3 = subtract$3;
const mat4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  create: create$5,
  clone: clone$5,
  copy: copy$5,
  fromValues: fromValues$5,
  set: set$5,
  identity: identity$2,
  transpose,
  invert: invert$2,
  adjoint,
  determinant,
  multiply: multiply$5,
  translate: translate$1,
  scale: scale$5,
  rotate: rotate$1,
  rotateX: rotateX$3,
  rotateY: rotateY$3,
  rotateZ: rotateZ$3,
  fromTranslation: fromTranslation$1,
  fromScaling,
  fromRotation: fromRotation$1,
  fromXRotation,
  fromYRotation,
  fromZRotation,
  fromRotationTranslation: fromRotationTranslation$1,
  fromQuat2,
  getTranslation: getTranslation$1,
  getScaling,
  getRotation,
  fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin,
  fromQuat,
  frustum,
  perspectiveNO,
  perspective,
  perspectiveZO,
  perspectiveFromFieldOfView,
  orthoNO,
  ortho,
  orthoZO,
  lookAt,
  targetTo,
  str: str$5,
  frob,
  add: add$5,
  subtract: subtract$3,
  multiplyScalar,
  multiplyScalarAndAdd,
  exactEquals: exactEquals$5,
  equals: equals$5,
  mul: mul$5,
  sub: sub$3
});
function create$4() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
__name(create$4, "create$4");
function clone$4(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
__name(clone$4, "clone$4");
function length$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
__name(length$4, "length$4");
function fromValues$4(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
__name(fromValues$4, "fromValues$4");
function copy$4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
__name(copy$4, "copy$4");
function set$4(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
__name(set$4, "set$4");
function add$4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
__name(add$4, "add$4");
function subtract$2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
__name(subtract$2, "subtract$2");
function multiply$4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
__name(multiply$4, "multiply$4");
function divide$2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
__name(divide$2, "divide$2");
function ceil$2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
__name(ceil$2, "ceil$2");
function floor$2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
__name(floor$2, "floor$2");
function min$2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
__name(min$2, "min$2");
function max$2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
__name(max$2, "max$2");
function round$2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
__name(round$2, "round$2");
function scale$4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
__name(scale$4, "scale$4");
function scaleAndAdd$2(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
__name(scaleAndAdd$2, "scaleAndAdd$2");
function distance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
__name(distance$2, "distance$2");
function squaredDistance$2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
__name(squaredDistance$2, "squaredDistance$2");
function squaredLength$4(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
__name(squaredLength$4, "squaredLength$4");
function negate$2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
__name(negate$2, "negate$2");
function inverse$2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
__name(inverse$2, "inverse$2");
function normalize$4(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
__name(normalize$4, "normalize$4");
function dot$4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
__name(dot$4, "dot$4");
function cross$2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
__name(cross$2, "cross$2");
function lerp$4(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
__name(lerp$4, "lerp$4");
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
__name(hermite, "hermite");
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
__name(bezier, "bezier");
function random$3(out, scale) {
  scale = scale || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
__name(random$3, "random$3");
function transformMat4$2(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
__name(transformMat4$2, "transformMat4$2");
function transformMat3$1(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
__name(transformMat3$1, "transformMat3$1");
function transformQuat$1(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
__name(transformQuat$1, "transformQuat$1");
function rotateX$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
__name(rotateX$2, "rotateX$2");
function rotateY$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
__name(rotateY$2, "rotateY$2");
function rotateZ$2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
__name(rotateZ$2, "rotateZ$2");
function angle$1(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot$4(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
__name(angle$1, "angle$1");
function zero$2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
__name(zero$2, "zero$2");
function str$4(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
__name(str$4, "str$4");
function exactEquals$4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
__name(exactEquals$4, "exactEquals$4");
function equals$4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
__name(equals$4, "equals$4");
var sub$2 = subtract$2;
var mul$4 = multiply$4;
var div$2 = divide$2;
var dist$2 = distance$2;
var sqrDist$2 = squaredDistance$2;
var len$4 = length$4;
var sqrLen$4 = squaredLength$4;
var forEach$2 = function() {
  var vec = create$4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
const vec3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  create: create$4,
  clone: clone$4,
  length: length$4,
  fromValues: fromValues$4,
  copy: copy$4,
  set: set$4,
  add: add$4,
  subtract: subtract$2,
  multiply: multiply$4,
  divide: divide$2,
  ceil: ceil$2,
  floor: floor$2,
  min: min$2,
  max: max$2,
  round: round$2,
  scale: scale$4,
  scaleAndAdd: scaleAndAdd$2,
  distance: distance$2,
  squaredDistance: squaredDistance$2,
  squaredLength: squaredLength$4,
  negate: negate$2,
  inverse: inverse$2,
  normalize: normalize$4,
  dot: dot$4,
  cross: cross$2,
  lerp: lerp$4,
  hermite,
  bezier,
  random: random$3,
  transformMat4: transformMat4$2,
  transformMat3: transformMat3$1,
  transformQuat: transformQuat$1,
  rotateX: rotateX$2,
  rotateY: rotateY$2,
  rotateZ: rotateZ$2,
  angle: angle$1,
  zero: zero$2,
  str: str$4,
  exactEquals: exactEquals$4,
  equals: equals$4,
  sub: sub$2,
  mul: mul$4,
  div: div$2,
  dist: dist$2,
  sqrDist: sqrDist$2,
  len: len$4,
  sqrLen: sqrLen$4,
  forEach: forEach$2
});
function create$3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
__name(create$3, "create$3");
function normalize$3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
__name(normalize$3, "normalize$3");
(function() {
  var vec = create$3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
})();
function create$2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
__name(create$2, "create$2");
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
__name(setAxisAngle, "setAxisAngle");
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
__name(slerp, "slerp");
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
__name(fromMat3, "fromMat3");
var normalize$2 = normalize$3;
(function() {
  var tmpvec3 = create$4();
  var xUnitVec3 = fromValues$4(1, 0, 0);
  var yUnitVec3 = fromValues$4(0, 1, 0);
  return function(out, a, b) {
    var dot = dot$4(a, b);
    if (dot < -0.999999) {
      cross$2(tmpvec3, xUnitVec3, a);
      if (len$4(tmpvec3) < 1e-6)
        cross$2(tmpvec3, yUnitVec3, a);
      normalize$4(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross$2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize$2(out, out);
    }
  };
})();
(function() {
  var temp1 = create$2();
  var temp2 = create$2();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
(function() {
  var matr = create$6();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize$2(out, fromMat3(out, matr));
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
__name(create, "create");
(function() {
  var vec = create();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
class AnimationControl {
  #animationData;
  #finishedPromise;
  #willFinish;
  static #voidControl = new AnimationControl(null);
  static get voidControl() {
    return this.#voidControl;
  }
  constructor(animationData, willFinish = false) {
    this.#animationData = animationData;
    this.#willFinish = willFinish;
    if (animationData !== null && typeof animationData === "object") {
      animationData.control = this;
    }
  }
  get finished() {
    if (!(this.#finishedPromise instanceof Promise)) {
      this.#finishedPromise = this.#willFinish ? new Promise((resolve) => this.#animationData.resolve = resolve) : Promise.resolve();
    }
    return this.#finishedPromise;
  }
  get isActive() {
    return this.#animationData.active;
  }
  get isFinished() {
    return this.#animationData.finished;
  }
  cancel() {
    const animationData = this.#animationData;
    if (animationData === null || animationData === void 0) {
      return;
    }
    animationData.cancelled = true;
  }
}
__name(AnimationControl, "AnimationControl");
class AnimationManager {
  static activeList = [];
  static newList = [];
  static current;
  static add(data) {
    const now2 = performance.now();
    data.start = now2 + (AnimationManager.current - now2);
    AnimationManager.newList.push(data);
  }
  static animate() {
    const current = AnimationManager.current = performance.now();
    if (AnimationManager.activeList.length === 0 && AnimationManager.newList.length === 0) {
      globalThis.requestAnimationFrame(AnimationManager.animate);
      return;
    }
    if (AnimationManager.newList.length) {
      for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
        const data = AnimationManager.newList[cntr];
        if (data.cancelled) {
          AnimationManager.newList.splice(cntr, 1);
          data.cleanup(data);
        }
        if (data.active) {
          AnimationManager.newList.splice(cntr, 1);
          AnimationManager.activeList.push(data);
        }
      }
    }
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.cancelled || data.el !== void 0 && !data.el.isConnected) {
        AnimationManager.activeList.splice(cntr, 1);
        data.cleanup(data);
        continue;
      }
      data.current = current - data.start;
      if (data.current >= data.duration) {
        for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
          const key = data.keys[dataCntr];
          data.newData[key] = data.destination[key];
        }
        data.position.set(data.newData);
        AnimationManager.activeList.splice(cntr, 1);
        data.cleanup(data);
        continue;
      }
      const easedTime = data.ease(data.current / data.duration);
      for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
        const key = data.keys[dataCntr];
        data.newData[key] = data.interpolate(data.initial[key], data.destination[key], easedTime);
      }
      data.position.set(data.newData);
    }
    globalThis.requestAnimationFrame(AnimationManager.animate);
  }
  static cancel(position) {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.position === position) {
        AnimationManager.activeList.splice(cntr, 1);
        data.cancelled = true;
        data.cleanup(data);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      if (data.position === position) {
        AnimationManager.newList.splice(cntr, 1);
        data.cancelled = true;
        data.cleanup(data);
      }
    }
  }
  static cancelAll() {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      data.cancelled = true;
      data.cleanup(data);
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      data.cancelled = true;
      data.cleanup(data);
    }
    AnimationManager.activeList.length = 0;
    AnimationManager.newList.length = 0;
  }
  static getScheduled(position) {
    const results = [];
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    return results;
  }
}
__name(AnimationManager, "AnimationManager");
AnimationManager.animate();
const animateKeys = /* @__PURE__ */ new Set([
  "left",
  "top",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "width",
  "height",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ",
  "zIndex",
  "rotation"
]);
const transformKeys = ["rotateX", "rotateY", "rotateZ", "scale", "translateX", "translateY", "translateZ"];
Object.freeze(transformKeys);
const relativeRegex = /^([-+*])=(-?[\d]*\.?[\d]+)$/;
const numericDefaults = {
  height: 0,
  left: 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  top: 0,
  transformOrigin: null,
  width: 0,
  zIndex: null,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  rotation: 0
};
Object.freeze(numericDefaults);
function setNumericDefaults(data) {
  if (data.rotateX === null) {
    data.rotateX = 0;
  }
  if (data.rotateY === null) {
    data.rotateY = 0;
  }
  if (data.rotateZ === null) {
    data.rotateZ = 0;
  }
  if (data.translateX === null) {
    data.translateX = 0;
  }
  if (data.translateY === null) {
    data.translateY = 0;
  }
  if (data.translateZ === null) {
    data.translateZ = 0;
  }
  if (data.scale === null) {
    data.scale = 1;
  }
  if (data.rotation === null) {
    data.rotation = 0;
  }
}
__name(setNumericDefaults, "setNumericDefaults");
const transformKeysBitwise = {
  rotateX: 1,
  rotateY: 2,
  rotateZ: 4,
  scale: 8,
  translateX: 16,
  translateY: 32,
  translateZ: 64
};
Object.freeze(transformKeysBitwise);
const transformOriginDefault = "top left";
const transformOrigins = [
  "top left",
  "top center",
  "top right",
  "center left",
  "center",
  "center right",
  "bottom left",
  "bottom center",
  "bottom right"
];
Object.freeze(transformOrigins);
function convertRelative(positionData, position) {
  for (const key in positionData) {
    if (animateKeys.has(key)) {
      const value = positionData[key];
      if (typeof value !== "string") {
        continue;
      }
      if (value === "auto" || value === "inherit") {
        continue;
      }
      const regexResults = relativeRegex.exec(value);
      if (!regexResults) {
        throw new Error(
          `convertRelative error: malformed relative key (${key}) with value (${value})`
        );
      }
      const current = position[key];
      switch (regexResults[1]) {
        case "-":
          positionData[key] = current - parseFloat(regexResults[2]);
          break;
        case "+":
          positionData[key] = current + parseFloat(regexResults[2]);
          break;
        case "*":
          positionData[key] = current * parseFloat(regexResults[2]);
          break;
      }
    }
  }
}
__name(convertRelative, "convertRelative");
class AnimationAPI {
  #data;
  #position;
  #instanceCount = 0;
  #cleanup;
  constructor(position, data) {
    this.#position = position;
    this.#data = data;
    this.#cleanup = this.#cleanupInstance.bind(this);
  }
  get isScheduled() {
    return this.#instanceCount > 0;
  }
  #addAnimation(initial, destination, duration, el, delay, ease, interpolate) {
    setNumericDefaults(initial);
    setNumericDefaults(destination);
    for (const key in initial) {
      if (!Number.isFinite(initial[key])) {
        delete initial[key];
      }
    }
    const keys2 = Object.keys(initial);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    if (keys2.length === 0) {
      return AnimationControl.voidControl;
    }
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      ease,
      el,
      finished: false,
      initial,
      interpolate,
      keys: keys2,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    if (delay > 0) {
      animationData.active = false;
      setTimeout(() => {
        if (!animationData.cancelled) {
          animationData.active = true;
          const now2 = performance.now();
          animationData.start = now2 + (AnimationManager.current - now2);
        }
      }, delay * 1e3);
    }
    this.#instanceCount++;
    AnimationManager.add(animationData);
    return new AnimationControl(animationData, true);
  }
  cancel() {
    AnimationManager.cancel(this.#position);
  }
  #cleanupInstance(data) {
    this.#instanceCount--;
    data.active = false;
    data.finished = true;
    if (typeof data.resolve === "function") {
      data.resolve(data.cancelled);
    }
  }
  getScheduled() {
    return AnimationManager.getScheduled(this.#position);
  }
  from(fromData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationAPI.from error: 'fromData' is not an object.`);
    }
    const position = this.#position;
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.from error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.from error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in fromData) {
      if (data[key] !== void 0 && fromData[key] !== data[key]) {
        initial[key] = fromData[key];
        destination[key] = data[key];
      }
    }
    convertRelative(initial, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  fromTo(fromData, toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(fromData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'fromData' is not an object.`);
    }
    if (!isObject(toData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in fromData) {
      if (toData[key] === void 0) {
        console.warn(
          `AnimationAPI.fromTo warning: key ('${key}') from 'fromData' missing in 'toData'; skipping this key.`
        );
        continue;
      }
      if (data[key] !== void 0) {
        initial[key] = fromData[key];
        destination[key] = toData[key];
      }
    }
    convertRelative(initial, data);
    convertRelative(destination, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  to(toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isObject(toData)) {
      throw new TypeError(`AnimationAPI.to error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.to error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.to error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in toData) {
      if (data[key] !== void 0 && toData[key] !== data[key]) {
        destination[key] = toData[key];
        initial[key] = data[key];
      }
    }
    convertRelative(destination, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  quickTo(keys2, { duration = 1, ease = cubicOut, interpolate = lerp$5 } = {}) {
    if (!isIterable(keys2)) {
      throw new TypeError(`AnimationAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      throw new Error(`AnimationAPI.quickTo error: 'parent' is not positionable.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.quickTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key of keys2) {
      if (typeof key !== "string") {
        throw new TypeError(`AnimationAPI.quickTo error: key is not a string.`);
      }
      if (!animateKeys.has(key)) {
        throw new Error(`AnimationAPI.quickTo error: key ('${key}') is not animatable.`);
      }
      if (data[key] !== void 0) {
        destination[key] = data[key];
        initial[key] = data[key];
      }
    }
    const keysArray = [...keys2];
    Object.freeze(keysArray);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      ease,
      el: void 0,
      finished: true,
      initial,
      interpolate,
      keys: keys2,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    const quickToCB = /* @__PURE__ */ __name((...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      for (let cntr = keysArray.length; --cntr >= 0; ) {
        const key = keysArray[cntr];
        if (data[key] !== void 0) {
          initial[key] = data[key];
        }
      }
      if (isObject(args[0])) {
        const objData = args[0];
        for (const key in objData) {
          if (destination[key] !== void 0) {
            destination[key] = objData[key];
          }
        }
      } else {
        for (let cntr = 0; cntr < argsLength && cntr < keysArray.length; cntr++) {
          const key = keysArray[cntr];
          if (destination[key] !== void 0) {
            destination[key] = args[cntr];
          }
        }
      }
      convertRelative(destination, data);
      setNumericDefaults(initial);
      setNumericDefaults(destination);
      const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
      animationData.el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
      if (animationData.finished) {
        animationData.finished = false;
        animationData.active = true;
        animationData.current = 0;
        this.#instanceCount++;
        AnimationManager.add(animationData);
      } else {
        const now2 = performance.now();
        animationData.start = now2 + (AnimationManager.current - now2);
        animationData.current = 0;
      }
    }, "quickToCB");
    quickToCB.keys = keysArray;
    quickToCB.options = ({ duration: duration2, ease: ease2, interpolate: interpolate2 } = {}) => {
      if (duration2 !== void 0 && (!Number.isFinite(duration2) || duration2 < 0)) {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'duration' is not a positive number.`);
      }
      if (ease2 !== void 0 && typeof ease2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'ease' is not a function.`);
      }
      if (interpolate2 !== void 0 && typeof interpolate2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'interpolate' is not a function.`);
      }
      if (duration2 >= 0) {
        animationData.duration = duration2 * 1e3;
      }
      if (ease2) {
        animationData.ease = ease2;
      }
      if (interpolate2) {
        animationData.interpolate = interpolate2;
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
__name(AnimationAPI, "AnimationAPI");
class AnimationGroupControl {
  #animationControls;
  #finishedPromise;
  static #voidControl = new AnimationGroupControl(null);
  static get voidControl() {
    return this.#voidControl;
  }
  constructor(animationControls) {
    this.#animationControls = animationControls;
  }
  get finished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return Promise.resolve();
    }
    if (!(this.#finishedPromise instanceof Promise)) {
      const promises = [];
      for (let cntr = animationControls.length; --cntr >= 0; ) {
        promises.push(animationControls[cntr].finished);
      }
      this.#finishedPromise = Promise.all(promises);
    }
    return this.#finishedPromise;
  }
  get isActive() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return false;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (animationControls[cntr].isActive) {
        return true;
      }
    }
    return false;
  }
  get isFinished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return true;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (!animationControls[cntr].isFinished) {
        return false;
      }
    }
    return false;
  }
  cancel() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return;
    }
    for (let cntr = this.#animationControls.length; --cntr >= 0; ) {
      this.#animationControls[cntr].cancel();
    }
  }
}
__name(AnimationGroupControl, "AnimationGroupControl");
class AnimationGroupAPI {
  static #isPosition(object) {
    return object !== null && typeof object === "object" && object.animate instanceof AnimationAPI;
  }
  static cancel(position) {
    if (isIterable(position)) {
      let index = -1;
      for (const entry of position) {
        index++;
        const actualPosition = this.#isPosition(entry) ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.cancel warning: No Position instance found at index: ${index}.`);
          continue;
        }
        AnimationManager.cancel(actualPosition);
      }
    } else {
      const actualPosition = this.#isPosition(position) ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.cancel warning: No Position instance found.`);
        return;
      }
      AnimationManager.cancel(actualPosition);
    }
  }
  static cancelAll() {
    AnimationManager.cancelAll();
  }
  static getScheduled(position) {
    const results = [];
    if (isIterable(position)) {
      let index = -1;
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found at index: ${index}.`);
          continue;
        }
        const controls = AnimationManager.getScheduled(actualPosition);
        results.push({ position: actualPosition, data: isPosition ? void 0 : entry, controls });
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found.`);
        return results;
      }
      const controls = AnimationManager.getScheduled(actualPosition);
      results.push({ position: actualPosition, data: isPosition ? void 0 : position, controls });
    }
    return results;
  }
  static from(position, fromData, options) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'fromData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof fromData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.from warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (typeof actualFromData !== "object") {
            throw new TypeError(`AnimationGroupAPI.from error: fromData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.from error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.from warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualFromData = fromData(callbackOptions);
        if (typeof actualFromData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.from error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.from error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  static fromTo(position, fromData, toData, options) {
    if (!isObject(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.`);
    }
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasFromCallback = typeof fromData === "function";
    const hasToCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasFromCallback || hasToCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasFromCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (typeof actualFromData !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: fromData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasToCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (typeof actualToData !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: toData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.fromTo error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasFromCallback) {
        actualFromData = fromData(callbackOptions);
        if (typeof actualFromData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasToCallback) {
        actualToData = toData(callbackOptions);
        if (typeof actualToData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  static to(position, toData, options) {
    if (!isObject(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index = -1;
    let callbackOptions;
    const hasDataCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index, position: void 0, data: void 0 };
    }
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.to warning: No Position instance found at index: ${index}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (typeof actualToData !== "object") {
            throw new TypeError(`AnimationGroupAPI.to error: toData callback function iteration(${index}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.to error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.to warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualToData = toData(callbackOptions);
        if (typeof actualToData !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.to error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.to error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  static quickTo(position, keys2, options) {
    if (!isIterable(keys2)) {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    if (options !== void 0 && !isObject(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
    }
    const quickToCallbacks = [];
    let index = -1;
    const hasOptionCallback = typeof options === "function";
    const callbackOptions = { index, position: void 0, data: void 0 };
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found at index: ${index}.`);
          continue;
        }
        callbackOptions.index = index;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : entry;
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (typeof actualOptions !== "object") {
            throw new TypeError(`AnimationGroupAPI.quickTo error: options callback function iteration(${index}) failed to return an object.`);
          }
        }
        quickToCallbacks.push(actualPosition.animate.quickTo(keys2, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found.`);
        return () => null;
      }
      callbackOptions.index = 0;
      callbackOptions.position = position;
      callbackOptions.data = isPosition ? void 0 : position;
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (typeof actualOptions !== "object") {
          throw new TypeError(
            `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
          );
        }
      }
      quickToCallbacks.push(actualPosition.animate.quickTo(keys2, actualOptions));
    }
    const keysArray = [...keys2];
    Object.freeze(keysArray);
    const quickToCB = /* @__PURE__ */ __name((...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      if (typeof args[0] === "function") {
        const dataCallback = args[0];
        index = -1;
        let cntr = 0;
        if (isIterable(position)) {
          for (const entry of position) {
            index++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              continue;
            }
            callbackOptions.index = index;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            const toData = dataCallback(callbackOptions);
            if (toData === null || toData === void 0) {
              continue;
            }
            const toDataIterable = isIterable(toData);
            if (!Number.isFinite(toData) && !toDataIterable && typeof toData !== "object") {
              throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
            }
            if (toDataIterable) {
              quickToCallbacks[cntr++](...toData);
            } else {
              quickToCallbacks[cntr++](toData);
            }
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            return;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          const toData = dataCallback(callbackOptions);
          if (toData === null || toData === void 0) {
            return;
          }
          const toDataIterable = isIterable(toData);
          if (!Number.isFinite(toData) && !toDataIterable && typeof toData !== "object") {
            throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index}) failed to return a finite number, iterable list, or object.`);
          }
          if (toDataIterable) {
            quickToCallbacks[cntr++](...toData);
          } else {
            quickToCallbacks[cntr++](toData);
          }
        }
      } else {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr](...args);
        }
      }
    }, "quickToCB");
    quickToCB.keys = keysArray;
    quickToCB.options = (options2) => {
      if (options2 !== void 0 && !isObject(options2) && typeof options2 !== "function") {
        throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
      }
      if (isObject(options2)) {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr].options(options2);
        }
      } else if (typeof options2 === "function") {
        if (isIterable(position)) {
          index = -1;
          let cntr = 0;
          for (const entry of position) {
            index++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              console.warn(
                `AnimationGroupAPI.quickTo.options warning: No Position instance found at index: ${index}.`
              );
              continue;
            }
            callbackOptions.index = index;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            actualOptions = options2(callbackOptions);
            if (actualOptions === null || actualOptions === void 0) {
              continue;
            }
            if (typeof actualOptions !== "object") {
              throw new TypeError(
                `AnimationGroupAPI.quickTo.options error: options callback function iteration(${index}) failed to return an object.`
              );
            }
            quickToCallbacks[cntr++].options(actualOptions);
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            console.warn(`AnimationGroupAPI.quickTo.options warning: No Position instance found.`);
            return quickToCB;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          actualOptions = options2(callbackOptions);
          if (typeof actualOptions !== "object") {
            throw new TypeError(
              `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
            );
          }
          quickToCallbacks[0].options(actualOptions);
        }
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
__name(AnimationGroupAPI, "AnimationGroupAPI");
class Centered {
  #element;
  #height;
  #lock;
  #width;
  constructor({ element: element2, lock = false, width, height } = {}) {
    this.element = element2;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get element() {
    return this.#element;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  getLeft(width) {
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    return (boundsWidth - width) / 2;
  }
  getTop(height) {
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    return (boundsHeight - height) / 2;
  }
}
__name(Centered, "Centered");
const browserCentered = new Centered();
const positionInitial = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  browserCentered,
  Centered
}, Symbol.toStringTag, { value: "Module" }));
class PositionChangeSet {
  constructor() {
    this.left = false;
    this.top = false;
    this.width = false;
    this.height = false;
    this.maxHeight = false;
    this.maxWidth = false;
    this.minHeight = false;
    this.minWidth = false;
    this.zIndex = false;
    this.transform = false;
    this.transformOrigin = false;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(value) {
    this.left = value;
    this.top = value;
    this.width = value;
    this.height = value;
    this.maxHeight = value;
    this.maxWidth = value;
    this.minHeight = value;
    this.minWidth = value;
    this.zIndex = value;
    this.transform = value;
    this.transformOrigin = value;
  }
}
__name(PositionChangeSet, "PositionChangeSet");
class PositionData {
  constructor({
    height = null,
    left = null,
    maxHeight = null,
    maxWidth = null,
    minHeight = null,
    minWidth = null,
    rotateX = null,
    rotateY = null,
    rotateZ = null,
    scale = null,
    translateX = null,
    translateY = null,
    translateZ = null,
    top = null,
    transformOrigin = null,
    width = null,
    zIndex = null
  } = {}) {
    this.height = height;
    this.left = left;
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.minHeight = minHeight;
    this.minWidth = minWidth;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.scale = scale;
    this.top = top;
    this.transformOrigin = transformOrigin;
    this.translateX = translateX;
    this.translateY = translateY;
    this.translateZ = translateZ;
    this.width = width;
    this.zIndex = zIndex;
    Object.seal(this);
  }
  copy(data) {
    this.height = data.height;
    this.left = data.left;
    this.maxHeight = data.maxHeight;
    this.maxWidth = data.maxWidth;
    this.minHeight = data.minHeight;
    this.minWidth = data.minWidth;
    this.rotateX = data.rotateX;
    this.rotateY = data.rotateY;
    this.rotateZ = data.rotateZ;
    this.scale = data.scale;
    this.top = data.top;
    this.transformOrigin = data.transformOrigin;
    this.translateX = data.translateX;
    this.translateY = data.translateY;
    this.translateZ = data.translateZ;
    this.width = data.width;
    this.zIndex = data.zIndex;
    return this;
  }
}
__name(PositionData, "PositionData");
class PositionStateAPI {
  #data;
  #dataSaved = /* @__PURE__ */ new Map();
  #position;
  #transforms;
  constructor(position, data, transforms) {
    this.#position = position;
    this.#data = data;
    this.#transforms = transforms;
  }
  get({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  getDefault() {
    return this.#dataSaved.get("#defaultData");
  }
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data;
  }
  reset({ keepZIndex = false, invokeSet = true } = {}) {
    const defaultData = this.#dataSaved.get("#defaultData");
    if (typeof defaultData !== "object") {
      return false;
    }
    if (this.#position.animate.isScheduled) {
      this.#position.animate.cancel();
    }
    const zIndex = this.#position.zIndex;
    const data = Object.assign({}, defaultData);
    if (keepZIndex) {
      data.zIndex = zIndex;
    }
    this.#transforms.reset(data);
    if (this.#position.parent?.reactive?.minimized) {
      this.#position.parent?.maximize?.({ animate: false, duration: 0 });
    }
    if (invokeSet) {
      setTimeout(() => this.#position.set(data), 0);
    }
    return true;
  }
  restore({
    name,
    remove = false,
    properties,
    silent = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity,
    interpolate = lerp$5
  }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      let data = dataSaved;
      if (isIterable(properties)) {
        data = {};
        for (const property of properties) {
          data[property] = dataSaved[property];
        }
      }
      if (silent) {
        for (const property in data) {
          this.#data[property] = data[property];
        }
        return dataSaved;
      } else if (animateTo) {
        if (data.transformOrigin !== this.#position.transformOrigin) {
          this.#position.transformOrigin = data.transformOrigin;
        }
        if (async) {
          return this.#position.animate.to(data, { duration, ease, interpolate }).finished.then(() => dataSaved);
        } else {
          this.#position.animate.to(data, { duration, ease, interpolate });
        }
      } else {
        this.#position.set(data);
      }
    }
    return dataSaved;
  }
  save({ name, ...extra }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - save error: 'name' is not a string.`);
    }
    const data = this.#position.get(extra);
    this.#dataSaved.set(name, data);
    return data;
  }
  set({ name, ...data }) {
    if (typeof name !== "string") {
      throw new TypeError(`Position - set error: 'name' is not a string.`);
    }
    this.#dataSaved.set(name, data);
  }
}
__name(PositionStateAPI, "PositionStateAPI");
class StyleCache {
  constructor() {
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved = {
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    };
    const storeResizeObserved = writable(this.resizeObserved);
    this.stores = {
      element: writable(this.el),
      resizeContentHeight: propertyStore(storeResizeObserved, "contentHeight"),
      resizeContentWidth: propertyStore(storeResizeObserved, "contentWidth"),
      resizeObserved: storeResizeObserved,
      resizeOffsetHeight: propertyStore(storeResizeObserved, "offsetHeight"),
      resizeOffsetWidth: propertyStore(storeResizeObserved, "offsetWidth")
    };
  }
  get offsetHeight() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    }
    throw new Error(`StyleCache - get offsetHeight error: no element assigned.`);
  }
  get offsetWidth() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    }
    throw new Error(`StyleCache - get offsetWidth error: no element assigned.`);
  }
  hasData(el) {
    return this.el === el;
  }
  reset() {
    if (this.el instanceof HTMLElement && this.el.isConnected && !this.hasWillChange) {
      this.el.style.willChange = null;
    }
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved.contentHeight = void 0;
    this.resizeObserved.contentWidth = void 0;
    this.resizeObserved.offsetHeight = void 0;
    this.resizeObserved.offsetWidth = void 0;
    this.stores.element.set(void 0);
  }
  update(el) {
    this.el = el;
    this.computed = globalThis.getComputedStyle(el);
    this.marginLeft = styleParsePixels(el.style.marginLeft) ?? styleParsePixels(this.computed.marginLeft);
    this.marginTop = styleParsePixels(el.style.marginTop) ?? styleParsePixels(this.computed.marginTop);
    this.maxHeight = styleParsePixels(el.style.maxHeight) ?? styleParsePixels(this.computed.maxHeight);
    this.maxWidth = styleParsePixels(el.style.maxWidth) ?? styleParsePixels(this.computed.maxWidth);
    this.minHeight = styleParsePixels(el.style.minHeight) ?? styleParsePixels(this.computed.minHeight);
    this.minWidth = styleParsePixels(el.style.minWidth) ?? styleParsePixels(this.computed.minWidth);
    const willChange = el.style.willChange !== "" ? el.style.willChange : this.computed.willChange;
    this.hasWillChange = willChange !== "" && willChange !== "auto";
    this.stores.element.set(el);
  }
}
__name(StyleCache, "StyleCache");
class TransformData {
  constructor() {
    Object.seal(this);
  }
  #boundingRect = new DOMRect();
  #corners = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  #mat4 = mat4.create();
  #originTranslations = [mat4.create(), mat4.create()];
  get boundingRect() {
    return this.#boundingRect;
  }
  get corners() {
    return this.#corners;
  }
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  get mat4() {
    return this.#mat4;
  }
  get originTranslations() {
    return this.#originTranslations;
  }
}
__name(TransformData, "TransformData");
class AdapterValidators {
  #validatorData;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  constructor() {
    this.#validatorData = [];
    Object.seal(this);
    return [this, this.#validatorData];
  }
  get length() {
    return this.#validatorData.length;
  }
  *[Symbol.iterator]() {
    if (this.#validatorData.length === 0) {
      return;
    }
    for (const entry of this.#validatorData) {
      yield { ...entry };
    }
  }
  add(...validators) {
    for (const validator of validators) {
      const validatorType = typeof validator;
      if (validatorType !== "function" && validatorType !== "object" || validator === null) {
        throw new TypeError(`AdapterValidator error: 'validator' is not a function or object.`);
      }
      let data = void 0;
      let subscribeFn = void 0;
      switch (validatorType) {
        case "function":
          data = {
            id: void 0,
            validator,
            weight: 1
          };
          subscribeFn = validator.subscribe;
          break;
        case "object":
          if (typeof validator.validator !== "function") {
            throw new TypeError(`AdapterValidator error: 'validator' attribute is not a function.`);
          }
          if (validator.weight !== void 0 && typeof validator.weight !== "number" || (validator.weight < 0 || validator.weight > 1)) {
            throw new TypeError(
              `AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive.`
            );
          }
          data = {
            id: validator.id !== void 0 ? validator.id : void 0,
            validator: validator.validator.bind(validator),
            weight: validator.weight || 1,
            instance: validator
          };
          subscribeFn = validator.validator.subscribe ?? validator.subscribe;
          break;
      }
      const index = this.#validatorData.findIndex((value) => {
        return data.weight < value.weight;
      });
      if (index >= 0) {
        this.#validatorData.splice(index, 0, data);
      } else {
        this.#validatorData.push(data);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn();
        if (typeof unsubscribe !== "function") {
          throw new TypeError(
            "AdapterValidator error: Filter has subscribe function, but no unsubscribe function is returned."
          );
        }
        if (this.#mapUnsubscribe.has(data.validator)) {
          throw new Error(
            "AdapterValidator error: Filter added already has an unsubscribe function registered."
          );
        }
        this.#mapUnsubscribe.set(data.validator, unsubscribe);
      }
    }
  }
  clear() {
    this.#validatorData.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
  }
  remove(...validators) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    for (const data of validators) {
      const actualValidator = typeof data === "function" ? data : data !== null && typeof data === "object" ? data.validator : void 0;
      if (!actualValidator) {
        continue;
      }
      for (let cntr = this.#validatorData.length; --cntr >= 0; ) {
        if (this.#validatorData[cntr].validator === actualValidator) {
          this.#validatorData.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualValidator)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualValidator);
          }
        }
      }
    }
  }
  removeBy(callback) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterValidator error: 'callback' is not a function.`);
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      const remove = callback.call(callback, { ...data });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validator);
        }
      }
      return !remove;
    });
  }
  removeById(...ids) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      let remove = false;
      for (const id of ids) {
        remove |= data.id === id;
      }
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validator);
        }
      }
      return !remove;
    });
  }
}
__name(AdapterValidators, "AdapterValidators");
class BasicBounds {
  #constrain;
  #element;
  #enabled;
  #height;
  #lock;
  #width;
  constructor({ constrain = true, element: element2, enabled = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = valData.width = Math.clamped(valData.position.width, valData.minWidth, maxW);
      if (valData.width + valData.position.left + valData.marginLeft > boundsWidth) {
        valData.position.left = boundsWidth - valData.width - valData.marginLeft;
      }
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = valData.height = Math.clamped(valData.position.height, valData.minHeight, maxH);
      if (valData.height + valData.position.top + valData.marginTop > boundsHeight) {
        valData.position.top = boundsHeight - valData.height - valData.marginTop;
      }
    }
    const maxL = Math.max(boundsWidth - valData.width - valData.marginLeft, 0);
    valData.position.left = Math.round(Math.clamped(valData.position.left, 0, maxL));
    const maxT = Math.max(boundsHeight - valData.height - valData.marginTop, 0);
    valData.position.top = Math.round(Math.clamped(valData.position.top, 0, maxT));
    return valData.position;
  }
}
__name(BasicBounds, "BasicBounds");
const s_TRANSFORM_DATA = new TransformData();
class TransformBounds {
  #constrain;
  #element;
  #enabled;
  #height;
  #lock;
  #width;
  constructor({ constrain = true, element: element2, enabled = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = Math.clamped(valData.width, valData.minWidth, maxW);
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = Math.clamped(valData.height, valData.minHeight, maxH);
    }
    const data = valData.transforms.getData(valData.position, s_TRANSFORM_DATA, valData);
    const initialX = data.boundingRect.x;
    const initialY = data.boundingRect.y;
    if (data.boundingRect.bottom + valData.marginTop > boundsHeight) {
      data.boundingRect.y += boundsHeight - data.boundingRect.bottom - valData.marginTop;
    }
    if (data.boundingRect.right + valData.marginLeft > boundsWidth) {
      data.boundingRect.x += boundsWidth - data.boundingRect.right - valData.marginLeft;
    }
    if (data.boundingRect.top - valData.marginTop < 0) {
      data.boundingRect.y += Math.abs(data.boundingRect.top - valData.marginTop);
    }
    if (data.boundingRect.left - valData.marginLeft < 0) {
      data.boundingRect.x += Math.abs(data.boundingRect.left - valData.marginLeft);
    }
    valData.position.left -= initialX - data.boundingRect.x;
    valData.position.top -= initialY - data.boundingRect.y;
    return valData.position;
  }
}
__name(TransformBounds, "TransformBounds");
const basicWindow = new BasicBounds({ lock: true });
const transformWindow = new TransformBounds({ lock: true });
const positionValidators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  basicWindow,
  BasicBounds,
  transformWindow,
  TransformBounds
}, Symbol.toStringTag, { value: "Module" }));
const s_SCALE_VECTOR = [1, 1, 1];
const s_TRANSLATE_VECTOR = [0, 0, 0];
const s_MAT4_RESULT = mat4.create();
const s_MAT4_TEMP = mat4.create();
const s_VEC3_TEMP = vec3.create();
class Transforms {
  #orderList = [];
  constructor() {
    this._data = {};
  }
  get isActive() {
    return this.#orderList.length > 0;
  }
  get rotateX() {
    return this._data.rotateX;
  }
  get rotateY() {
    return this._data.rotateY;
  }
  get rotateZ() {
    return this._data.rotateZ;
  }
  get scale() {
    return this._data.scale;
  }
  get translateX() {
    return this._data.translateX;
  }
  get translateY() {
    return this._data.translateY;
  }
  get translateZ() {
    return this._data.translateZ;
  }
  set rotateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateX === void 0) {
        this.#orderList.push("rotateX");
      }
      this._data.rotateX = value;
    } else {
      if (this._data.rotateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateX;
    }
  }
  set rotateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateY === void 0) {
        this.#orderList.push("rotateY");
      }
      this._data.rotateY = value;
    } else {
      if (this._data.rotateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateY;
    }
  }
  set rotateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateZ === void 0) {
        this.#orderList.push("rotateZ");
      }
      this._data.rotateZ = value;
    } else {
      if (this._data.rotateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "rotateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.rotateZ;
    }
  }
  set scale(value) {
    if (Number.isFinite(value)) {
      if (this._data.scale === void 0) {
        this.#orderList.push("scale");
      }
      this._data.scale = value;
    } else {
      if (this._data.scale !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "scale");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.scale;
    }
  }
  set translateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateX === void 0) {
        this.#orderList.push("translateX");
      }
      this._data.translateX = value;
    } else {
      if (this._data.translateX !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateX");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateX;
    }
  }
  set translateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateY === void 0) {
        this.#orderList.push("translateY");
      }
      this._data.translateY = value;
    } else {
      if (this._data.translateY !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateY");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateY;
    }
  }
  set translateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateZ === void 0) {
        this.#orderList.push("translateZ");
      }
      this._data.translateZ = value;
    } else {
      if (this._data.translateZ !== void 0) {
        const index = this.#orderList.findIndex((entry) => entry === "translateZ");
        if (index >= 0) {
          this.#orderList.splice(index, 1);
        }
      }
      delete this._data.translateZ;
    }
  }
  getCSS(data = this._data) {
    return `matrix3d(${this.getMat4(data, s_MAT4_RESULT).join(",")})`;
  }
  getCSSOrtho(data = this._data) {
    return `matrix3d(${this.getMat4Ortho(data, s_MAT4_RESULT).join(",")})`;
  }
  getData(position, output = new TransformData(), validationData = {}) {
    const valWidth = validationData.width ?? 0;
    const valHeight = validationData.height ?? 0;
    const valOffsetTop = validationData.offsetTop ?? validationData.marginTop ?? 0;
    const valOffsetLeft = validationData.offsetLeft ?? validationData.offsetLeft ?? 0;
    position.top += valOffsetTop;
    position.left += valOffsetLeft;
    const width = Number.isFinite(position.width) ? position.width : valWidth;
    const height = Number.isFinite(position.height) ? position.height : valHeight;
    const rect = output.corners;
    if (this.hasTransform(position)) {
      rect[0][0] = rect[0][1] = rect[0][2] = 0;
      rect[1][0] = width;
      rect[1][1] = rect[1][2] = 0;
      rect[2][0] = width;
      rect[2][1] = height;
      rect[2][2] = 0;
      rect[3][0] = 0;
      rect[3][1] = height;
      rect[3][2] = 0;
      const matrix = this.getMat4(position, output.mat4);
      const translate = s_GET_ORIGIN_TRANSLATION(position.transformOrigin, width, height, output.originTranslations);
      if (transformOriginDefault === position.transformOrigin) {
        vec3.transformMat4(rect[0], rect[0], matrix);
        vec3.transformMat4(rect[1], rect[1], matrix);
        vec3.transformMat4(rect[2], rect[2], matrix);
        vec3.transformMat4(rect[3], rect[3], matrix);
      } else {
        vec3.transformMat4(rect[0], rect[0], translate[0]);
        vec3.transformMat4(rect[0], rect[0], matrix);
        vec3.transformMat4(rect[0], rect[0], translate[1]);
        vec3.transformMat4(rect[1], rect[1], translate[0]);
        vec3.transformMat4(rect[1], rect[1], matrix);
        vec3.transformMat4(rect[1], rect[1], translate[1]);
        vec3.transformMat4(rect[2], rect[2], translate[0]);
        vec3.transformMat4(rect[2], rect[2], matrix);
        vec3.transformMat4(rect[2], rect[2], translate[1]);
        vec3.transformMat4(rect[3], rect[3], translate[0]);
        vec3.transformMat4(rect[3], rect[3], matrix);
        vec3.transformMat4(rect[3], rect[3], translate[1]);
      }
      rect[0][0] = position.left + rect[0][0];
      rect[0][1] = position.top + rect[0][1];
      rect[1][0] = position.left + rect[1][0];
      rect[1][1] = position.top + rect[1][1];
      rect[2][0] = position.left + rect[2][0];
      rect[2][1] = position.top + rect[2][1];
      rect[3][0] = position.left + rect[3][0];
      rect[3][1] = position.top + rect[3][1];
    } else {
      rect[0][0] = position.left;
      rect[0][1] = position.top;
      rect[1][0] = position.left + width;
      rect[1][1] = position.top;
      rect[2][0] = position.left + width;
      rect[2][1] = position.top + height;
      rect[3][0] = position.left;
      rect[3][1] = position.top + height;
      mat4.identity(output.mat4);
    }
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    for (let cntr = 4; --cntr >= 0; ) {
      if (rect[cntr][0] > maxX) {
        maxX = rect[cntr][0];
      }
      if (rect[cntr][0] < minX) {
        minX = rect[cntr][0];
      }
      if (rect[cntr][1] > maxY) {
        maxY = rect[cntr][1];
      }
      if (rect[cntr][1] < minY) {
        minY = rect[cntr][1];
      }
    }
    const boundingRect = output.boundingRect;
    boundingRect.x = minX;
    boundingRect.y = minY;
    boundingRect.width = maxX - minX;
    boundingRect.height = maxY - minY;
    position.top -= valOffsetTop;
    position.left -= valOffsetLeft;
    return output;
  }
  getMat4(data = this._data, output = mat4.create()) {
    const matrix = mat4.identity(output);
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "scale":
          seenKeys |= transformKeysBitwise.scale;
          s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data[key];
          mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
          break;
        case "translateX":
          seenKeys |= transformKeysBitwise.translateX;
          s_TRANSLATE_VECTOR[0] = data.translateX;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = 0;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateY":
          seenKeys |= transformKeysBitwise.translateY;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = data.translateY;
          s_TRANSLATE_VECTOR[2] = 0;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateZ":
          seenKeys |= transformKeysBitwise.translateZ;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = data.translateZ;
          mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
      }
    }
    if (data !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateY":
            mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateZ":
            mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "scale":
            s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data[key];
            mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
            break;
          case "translateX":
            s_TRANSLATE_VECTOR[0] = data[key];
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = 0;
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateY":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = data[key];
            s_TRANSLATE_VECTOR[2] = 0;
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateZ":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = data[key];
            mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
        }
      }
    }
    return matrix;
  }
  getMat4Ortho(data = this._data, output = mat4.create()) {
    const matrix = mat4.identity(output);
    s_TRANSLATE_VECTOR[0] = (data.left ?? 0) + (data.translateX ?? 0);
    s_TRANSLATE_VECTOR[1] = (data.top ?? 0) + (data.translateY ?? 0);
    s_TRANSLATE_VECTOR[2] = data.translateZ ?? 0;
    mat4.multiply(matrix, matrix, mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
    if (data.scale !== null) {
      s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data.scale;
      mat4.multiply(matrix, matrix, mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
    }
    if (data.rotateX === null && data.rotateY === null && data.rotateZ === null) {
      return matrix;
    }
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
      }
    }
    if (data !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            mat4.multiply(matrix, matrix, mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateY":
            mat4.multiply(matrix, matrix, mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateZ":
            mat4.multiply(matrix, matrix, mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
        }
      }
    }
    return matrix;
  }
  hasTransform(data) {
    for (const key of transformKeys) {
      if (Number.isFinite(data[key])) {
        return true;
      }
    }
    return false;
  }
  reset(data) {
    for (const key in data) {
      if (transformKeys.includes(key)) {
        if (Number.isFinite(data[key])) {
          this._data[key] = data[key];
        } else {
          const index = this.#orderList.findIndex((entry) => entry === key);
          if (index >= 0) {
            this.#orderList.splice(index, 1);
          }
          delete this._data[key];
        }
      }
    }
  }
}
__name(Transforms, "Transforms");
function s_GET_ORIGIN_TRANSLATION(transformOrigin, width, height, output) {
  const vector = s_VEC3_TEMP;
  switch (transformOrigin) {
    case "top left":
      vector[0] = vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      mat4.fromTranslation(output[1], vector);
      break;
    case "top center":
      vector[0] = -width * 0.5;
      vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "top right":
      vector[0] = -width;
      vector[1] = 0;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      mat4.fromTranslation(output[1], vector);
      break;
    case "center left":
      vector[0] = 0;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case null:
    case "center":
      vector[0] = -width * 0.5;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "center right":
      vector[0] = -width;
      vector[1] = -height * 0.5;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height * 0.5;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom left":
      vector[0] = 0;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom center":
      vector[0] = -width * 0.5;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    case "bottom right":
      vector[0] = -width;
      vector[1] = -height;
      mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height;
      mat4.fromTranslation(output[1], vector);
      break;
    default:
      mat4.identity(output[0]);
      mat4.identity(output[1]);
      break;
  }
  return output;
}
__name(s_GET_ORIGIN_TRANSLATION, "s_GET_ORIGIN_TRANSLATION");
class UpdateElementData {
  constructor() {
    this.data = void 0;
    this.dataSubscribers = new PositionData();
    this.dimensionData = { width: 0, height: 0 };
    this.changeSet = void 0;
    this.options = void 0;
    this.queued = false;
    this.styleCache = void 0;
    this.transforms = void 0;
    this.transformData = new TransformData();
    this.subscriptions = void 0;
    this.storeDimension = writable(this.dimensionData);
    this.storeTransform = writable(this.transformData, () => {
      this.options.transformSubscribed = true;
      return () => this.options.transformSubscribed = false;
    });
    this.queued = false;
    Object.seal(this.dimensionData);
  }
}
__name(UpdateElementData, "UpdateElementData");
async function nextAnimationFrame(cntr = 1) {
  if (!Number.isInteger(cntr) || cntr < 1) {
    throw new TypeError(`nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.`);
  }
  let currentTime = performance.now();
  for (; --cntr >= 0; ) {
    currentTime = await new Promise((resolve) => requestAnimationFrame(resolve));
  }
  return currentTime;
}
__name(nextAnimationFrame, "nextAnimationFrame");
class UpdateElementManager {
  static list = [];
  static listCntr = 0;
  static updatePromise;
  static get promise() {
    return this.updatePromise;
  }
  static add(el, updateData) {
    if (this.listCntr < this.list.length) {
      const entry = this.list[this.listCntr];
      entry[0] = el;
      entry[1] = updateData;
    } else {
      this.list.push([el, updateData]);
    }
    this.listCntr++;
    updateData.queued = true;
    if (!this.updatePromise) {
      this.updatePromise = this.wait();
    }
    return this.updatePromise;
  }
  static async wait() {
    const currentTime = await nextAnimationFrame();
    this.updatePromise = void 0;
    for (let cntr = this.listCntr; --cntr >= 0; ) {
      const entry = this.list[cntr];
      const el = entry[0];
      const updateData = entry[1];
      entry[0] = void 0;
      entry[1] = void 0;
      updateData.queued = false;
      if (!el.isConnected) {
        continue;
      }
      if (updateData.options.ortho) {
        s_UPDATE_ELEMENT_ORTHO(el, updateData);
      } else {
        s_UPDATE_ELEMENT(el, updateData);
      }
      if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
        s_UPDATE_TRANSFORM(el, updateData);
      }
      this.updateSubscribers(updateData);
    }
    this.listCntr = 0;
    return currentTime;
  }
  static immediate(el, updateData) {
    if (!el.isConnected) {
      return;
    }
    if (updateData.options.ortho) {
      s_UPDATE_ELEMENT_ORTHO(el, updateData);
    } else {
      s_UPDATE_ELEMENT(el, updateData);
    }
    if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
      s_UPDATE_TRANSFORM(el, updateData);
    }
    this.updateSubscribers(updateData);
  }
  static updateSubscribers(updateData) {
    const data = updateData.data;
    const changeSet = updateData.changeSet;
    if (!changeSet.hasChange()) {
      return;
    }
    const output = updateData.dataSubscribers.copy(data);
    const subscriptions = updateData.subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](output);
      }
    }
    if (changeSet.width || changeSet.height) {
      updateData.dimensionData.width = data.width;
      updateData.dimensionData.height = data.height;
      updateData.storeDimension.set(updateData.dimensionData);
    }
    changeSet.set(false);
  }
}
__name(UpdateElementManager, "UpdateElementManager");
function s_UPDATE_ELEMENT(el, updateData) {
  const changeSet = updateData.changeSet;
  const data = updateData.data;
  if (changeSet.left) {
    el.style.left = `${data.left}px`;
  }
  if (changeSet.top) {
    el.style.top = `${data.top}px`;
  }
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data.transformOrigin === "center" ? null : data.transformOrigin;
  }
  if (changeSet.transform) {
    el.style.transform = updateData.transforms.isActive ? updateData.transforms.getCSS() : null;
  }
}
__name(s_UPDATE_ELEMENT, "s_UPDATE_ELEMENT");
function s_UPDATE_ELEMENT_ORTHO(el, updateData) {
  const changeSet = updateData.changeSet;
  const data = updateData.data;
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data.transformOrigin === "center" ? null : data.transformOrigin;
  }
  if (changeSet.left || changeSet.top || changeSet.transform) {
    el.style.transform = updateData.transforms.getCSSOrtho(data);
  }
}
__name(s_UPDATE_ELEMENT_ORTHO, "s_UPDATE_ELEMENT_ORTHO");
function s_UPDATE_TRANSFORM(el, updateData) {
  s_VALIDATION_DATA$1.height = updateData.data.height !== "auto" ? updateData.data.height : updateData.styleCache.offsetHeight;
  s_VALIDATION_DATA$1.width = updateData.data.width !== "auto" ? updateData.data.width : updateData.styleCache.offsetWidth;
  s_VALIDATION_DATA$1.marginLeft = updateData.styleCache.marginLeft;
  s_VALIDATION_DATA$1.marginTop = updateData.styleCache.marginTop;
  updateData.transforms.getData(updateData.data, updateData.transformData, s_VALIDATION_DATA$1);
  updateData.storeTransform.set(updateData.transformData);
}
__name(s_UPDATE_TRANSFORM, "s_UPDATE_TRANSFORM");
const s_VALIDATION_DATA$1 = {
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0
};
class Position {
  #data = new PositionData();
  #animate = new AnimationAPI(this, this.#data);
  #enabled = true;
  #positionChangeSet = new PositionChangeSet();
  #options = {
    calculateTransform: false,
    initialHelper: void 0,
    ortho: true,
    transformSubscribed: false
  };
  #parent;
  #stores;
  #styleCache;
  #subscriptions = [];
  #transforms = new Transforms();
  #updateElementData;
  #updateElementPromise;
  #validators;
  #validatorData;
  #state = new PositionStateAPI(this, this.#data, this.#transforms);
  static get Animate() {
    return AnimationGroupAPI;
  }
  static get Initial() {
    return positionInitial;
  }
  static get TransformData() {
    return TransformData;
  }
  static get Validators() {
    return positionValidators;
  }
  static duplicate(position, options) {
    if (!(position instanceof Position)) {
      throw new TypeError(`'position' is not an instance of Position.`);
    }
    const newPosition = new Position(options);
    newPosition.#options = Object.assign({}, position.#options, options);
    newPosition.#validators.add(...position.#validators);
    newPosition.set(position.#data);
    return newPosition;
  }
  constructor(parent, options) {
    if (isPlainObject(parent)) {
      options = parent;
    } else {
      this.#parent = parent;
    }
    const data = this.#data;
    const transforms = this.#transforms;
    this.#styleCache = new StyleCache();
    const updateData = new UpdateElementData();
    updateData.changeSet = this.#positionChangeSet;
    updateData.data = this.#data;
    updateData.options = this.#options;
    updateData.styleCache = this.#styleCache;
    updateData.subscriptions = this.#subscriptions;
    updateData.transforms = this.#transforms;
    this.#updateElementData = updateData;
    if (typeof options === "object") {
      if (typeof options.calculateTransform === "boolean") {
        this.#options.calculateTransform = options.calculateTransform;
      }
      if (typeof options.ortho === "boolean") {
        this.#options.ortho = options.ortho;
      }
      if (Number.isFinite(options.height) || options.height === "auto" || options.height === "inherit" || options.height === null) {
        data.height = updateData.dimensionData.height = typeof options.height === "number" ? Math.round(options.height) : options.height;
      }
      if (Number.isFinite(options.left) || options.left === null) {
        data.left = typeof options.left === "number" ? Math.round(options.left) : options.left;
      }
      if (Number.isFinite(options.maxHeight) || options.maxHeight === null) {
        data.maxHeight = typeof options.maxHeight === "number" ? Math.round(options.maxHeight) : options.maxHeight;
      }
      if (Number.isFinite(options.maxWidth) || options.maxWidth === null) {
        data.maxWidth = typeof options.maxWidth === "number" ? Math.round(options.maxWidth) : options.maxWidth;
      }
      if (Number.isFinite(options.minHeight) || options.minHeight === null) {
        data.minHeight = typeof options.minHeight === "number" ? Math.round(options.minHeight) : options.minHeight;
      }
      if (Number.isFinite(options.minWidth) || options.minWidth === null) {
        data.minWidth = typeof options.minWidth === "number" ? Math.round(options.minWidth) : options.minWidth;
      }
      if (Number.isFinite(options.rotateX) || options.rotateX === null) {
        transforms.rotateX = data.rotateX = options.rotateX;
      }
      if (Number.isFinite(options.rotateY) || options.rotateY === null) {
        transforms.rotateY = data.rotateY = options.rotateY;
      }
      if (Number.isFinite(options.rotateZ) || options.rotateZ === null) {
        transforms.rotateZ = data.rotateZ = options.rotateZ;
      }
      if (Number.isFinite(options.scale) || options.scale === null) {
        transforms.scale = data.scale = options.scale;
      }
      if (Number.isFinite(options.top) || options.top === null) {
        data.top = typeof options.top === "number" ? Math.round(options.top) : options.top;
      }
      if (typeof options.transformOrigin === "string" || options.transformOrigin === null) {
        data.transformOrigin = transformOrigins.includes(options.transformOrigin) ? options.transformOrigin : null;
      }
      if (Number.isFinite(options.translateX) || options.translateX === null) {
        transforms.translateX = data.translateX = options.translateX;
      }
      if (Number.isFinite(options.translateY) || options.translateY === null) {
        transforms.translateY = data.translateY = options.translateY;
      }
      if (Number.isFinite(options.translateZ) || options.translateZ === null) {
        transforms.translateZ = data.translateZ = options.translateZ;
      }
      if (Number.isFinite(options.width) || options.width === "auto" || options.width === "inherit" || options.width === null) {
        data.width = updateData.dimensionData.width = typeof options.width === "number" ? Math.round(options.width) : options.width;
      }
      if (Number.isFinite(options.zIndex) || options.zIndex === null) {
        data.zIndex = typeof options.zIndex === "number" ? Math.round(options.zIndex) : options.zIndex;
      }
    }
    this.#stores = {
      height: propertyStore(this, "height"),
      left: propertyStore(this, "left"),
      rotateX: propertyStore(this, "rotateX"),
      rotateY: propertyStore(this, "rotateY"),
      rotateZ: propertyStore(this, "rotateZ"),
      scale: propertyStore(this, "scale"),
      top: propertyStore(this, "top"),
      transformOrigin: propertyStore(this, "transformOrigin"),
      translateX: propertyStore(this, "translateX"),
      translateY: propertyStore(this, "translateY"),
      translateZ: propertyStore(this, "translateZ"),
      width: propertyStore(this, "width"),
      zIndex: propertyStore(this, "zIndex"),
      maxHeight: propertyStore(this, "maxHeight"),
      maxWidth: propertyStore(this, "maxWidth"),
      minHeight: propertyStore(this, "minHeight"),
      minWidth: propertyStore(this, "minWidth"),
      dimension: { subscribe: updateData.storeDimension.subscribe },
      element: { subscribe: this.#styleCache.stores.element.subscribe },
      resizeContentHeight: { subscribe: this.#styleCache.stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: this.#styleCache.stores.resizeContentWidth.subscribe },
      resizeOffsetHeight: { subscribe: this.#styleCache.stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: this.#styleCache.stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: updateData.storeTransform.subscribe },
      resizeObserved: this.#styleCache.stores.resizeObserved
    };
    subscribeIgnoreFirst(this.#stores.resizeObserved, (resizeData) => {
      const parent2 = this.#parent;
      const el = parent2 instanceof HTMLElement ? parent2 : parent2?.elementTarget;
      if (el instanceof HTMLElement && Number.isFinite(resizeData?.offsetWidth) && Number.isFinite(resizeData?.offsetHeight)) {
        this.set(data);
      }
    });
    this.#stores.transformOrigin.values = transformOrigins;
    [this.#validators, this.#validatorData] = new AdapterValidators();
    if (options?.initial || options?.positionInitial) {
      const initialHelper = options.initial ?? options.positionInitial;
      if (typeof initialHelper?.getLeft !== "function" || typeof initialHelper?.getTop !== "function") {
        throw new Error(
          `'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions.`
        );
      }
      this.#options.initialHelper = options.initial;
    }
    if (options?.validator) {
      if (isIterable(options?.validator)) {
        this.validators.add(...options.validator);
      } else {
        this.validators.add(options.validator);
      }
    }
  }
  get animate() {
    return this.#animate;
  }
  get dimension() {
    return this.#updateElementData.dimensionData;
  }
  get enabled() {
    return this.#enabled;
  }
  get element() {
    return this.#styleCache.el;
  }
  get elementUpdated() {
    return this.#updateElementPromise;
  }
  get parent() {
    return this.#parent;
  }
  get state() {
    return this.#state;
  }
  get stores() {
    return this.#stores;
  }
  get transform() {
    return this.#updateElementData.transformData;
  }
  get validators() {
    return this.#validators;
  }
  set enabled(enabled) {
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  set parent(parent) {
    if (parent !== void 0 && !(parent instanceof HTMLElement) && !isObject(parent)) {
      throw new TypeError(`'parent' is not an HTMLElement, object, or undefined.`);
    }
    this.#parent = parent;
    this.#state.remove({ name: "#defaultData" });
    this.#styleCache.reset();
    if (parent) {
      this.set(this.#data);
    }
  }
  get height() {
    return this.#data.height;
  }
  get left() {
    return this.#data.left;
  }
  get maxHeight() {
    return this.#data.maxHeight;
  }
  get maxWidth() {
    return this.#data.maxWidth;
  }
  get minHeight() {
    return this.#data.minHeight;
  }
  get minWidth() {
    return this.#data.minWidth;
  }
  get rotateX() {
    return this.#data.rotateX;
  }
  get rotateY() {
    return this.#data.rotateY;
  }
  get rotateZ() {
    return this.#data.rotateZ;
  }
  get rotation() {
    return this.#data.rotateZ;
  }
  get scale() {
    return this.#data.scale;
  }
  get top() {
    return this.#data.top;
  }
  get transformOrigin() {
    return this.#data.transformOrigin;
  }
  get translateX() {
    return this.#data.translateX;
  }
  get translateY() {
    return this.#data.translateY;
  }
  get translateZ() {
    return this.#data.translateZ;
  }
  get width() {
    return this.#data.width;
  }
  get zIndex() {
    return this.#data.zIndex;
  }
  set height(height) {
    this.#stores.height.set(height);
  }
  set left(left) {
    this.#stores.left.set(left);
  }
  set maxHeight(maxHeight) {
    this.#stores.maxHeight.set(maxHeight);
  }
  set maxWidth(maxWidth) {
    this.#stores.maxWidth.set(maxWidth);
  }
  set minHeight(minHeight) {
    this.#stores.minHeight.set(minHeight);
  }
  set minWidth(minWidth) {
    this.#stores.minWidth.set(minWidth);
  }
  set rotateX(rotateX) {
    this.#stores.rotateX.set(rotateX);
  }
  set rotateY(rotateY) {
    this.#stores.rotateY.set(rotateY);
  }
  set rotateZ(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  set rotation(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  set scale(scale) {
    this.#stores.scale.set(scale);
  }
  set top(top) {
    this.#stores.top.set(top);
  }
  set transformOrigin(transformOrigin) {
    if (transformOrigins.includes(transformOrigin)) {
      this.#stores.transformOrigin.set(transformOrigin);
    }
  }
  set translateX(translateX) {
    this.#stores.translateX.set(translateX);
  }
  set translateY(translateY) {
    this.#stores.translateY.set(translateY);
  }
  set translateZ(translateZ) {
    this.#stores.translateZ.set(translateZ);
  }
  set width(width) {
    this.#stores.width.set(width);
  }
  set zIndex(zIndex) {
    this.#stores.zIndex.set(zIndex);
  }
  get(position = {}, options) {
    const keys2 = options?.keys;
    const excludeKeys = options?.exclude;
    const numeric = options?.numeric ?? false;
    if (isIterable(keys2)) {
      if (numeric) {
        for (const key of keys2) {
          position[key] = this[key] ?? numericDefaults[key];
        }
      } else {
        for (const key of keys2) {
          position[key] = this[key];
        }
      }
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete position[key];
        }
      }
      return position;
    } else {
      const data = Object.assign(position, this.#data);
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete data[key];
        }
      }
      if (numeric) {
        setNumericDefaults(data);
      }
      return data;
    }
  }
  toJSON() {
    return Object.assign({}, this.#data);
  }
  set(position = {}) {
    if (typeof position !== "object") {
      throw new TypeError(`Position - set error: 'position' is not an object.`);
    }
    const parent = this.#parent;
    if (!this.#enabled) {
      return this;
    }
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return this;
    }
    const immediateElementUpdate = position.immediateElementUpdate === true;
    const data = this.#data;
    const transforms = this.#transforms;
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    const changeSet = this.#positionChangeSet;
    const styleCache = this.#styleCache;
    if (el) {
      if (!styleCache.hasData(el)) {
        styleCache.update(el);
        if (!styleCache.hasWillChange) {
          el.style.willChange = this.#options.ortho ? "transform" : "top, left, transform";
        }
        changeSet.set(true);
        this.#updateElementData.queued = false;
      }
      convertRelative(position, this);
      position = this.#updatePosition(position, parent, el, styleCache);
      if (position === null) {
        return this;
      }
    }
    if (Number.isFinite(position.left)) {
      position.left = Math.round(position.left);
      if (data.left !== position.left) {
        data.left = position.left;
        changeSet.left = true;
      }
    }
    if (Number.isFinite(position.top)) {
      position.top = Math.round(position.top);
      if (data.top !== position.top) {
        data.top = position.top;
        changeSet.top = true;
      }
    }
    if (Number.isFinite(position.maxHeight) || position.maxHeight === null) {
      position.maxHeight = typeof position.maxHeight === "number" ? Math.round(position.maxHeight) : null;
      if (data.maxHeight !== position.maxHeight) {
        data.maxHeight = position.maxHeight;
        changeSet.maxHeight = true;
      }
    }
    if (Number.isFinite(position.maxWidth) || position.maxWidth === null) {
      position.maxWidth = typeof position.maxWidth === "number" ? Math.round(position.maxWidth) : null;
      if (data.maxWidth !== position.maxWidth) {
        data.maxWidth = position.maxWidth;
        changeSet.maxWidth = true;
      }
    }
    if (Number.isFinite(position.minHeight) || position.minHeight === null) {
      position.minHeight = typeof position.minHeight === "number" ? Math.round(position.minHeight) : null;
      if (data.minHeight !== position.minHeight) {
        data.minHeight = position.minHeight;
        changeSet.minHeight = true;
      }
    }
    if (Number.isFinite(position.minWidth) || position.minWidth === null) {
      position.minWidth = typeof position.minWidth === "number" ? Math.round(position.minWidth) : null;
      if (data.minWidth !== position.minWidth) {
        data.minWidth = position.minWidth;
        changeSet.minWidth = true;
      }
    }
    if (Number.isFinite(position.rotateX) || position.rotateX === null) {
      if (data.rotateX !== position.rotateX) {
        data.rotateX = transforms.rotateX = position.rotateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateY) || position.rotateY === null) {
      if (data.rotateY !== position.rotateY) {
        data.rotateY = transforms.rotateY = position.rotateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateZ) || position.rotateZ === null) {
      if (data.rotateZ !== position.rotateZ) {
        data.rotateZ = transforms.rotateZ = position.rotateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.scale) || position.scale === null) {
      position.scale = typeof position.scale === "number" ? Math.max(0, Math.min(position.scale, 1e3)) : null;
      if (data.scale !== position.scale) {
        data.scale = transforms.scale = position.scale;
        changeSet.transform = true;
      }
    }
    if (typeof position.transformOrigin === "string" && transformOrigins.includes(
      position.transformOrigin
    ) || position.transformOrigin === null) {
      if (data.transformOrigin !== position.transformOrigin) {
        data.transformOrigin = position.transformOrigin;
        changeSet.transformOrigin = true;
      }
    }
    if (Number.isFinite(position.translateX) || position.translateX === null) {
      if (data.translateX !== position.translateX) {
        data.translateX = transforms.translateX = position.translateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateY) || position.translateY === null) {
      if (data.translateY !== position.translateY) {
        data.translateY = transforms.translateY = position.translateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateZ) || position.translateZ === null) {
      if (data.translateZ !== position.translateZ) {
        data.translateZ = transforms.translateZ = position.translateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.zIndex)) {
      position.zIndex = Math.round(position.zIndex);
      if (data.zIndex !== position.zIndex) {
        data.zIndex = position.zIndex;
        changeSet.zIndex = true;
      }
    }
    if (Number.isFinite(position.width) || position.width === "auto" || position.width === "inherit" || position.width === null) {
      position.width = typeof position.width === "number" ? Math.round(position.width) : position.width;
      if (data.width !== position.width) {
        data.width = position.width;
        changeSet.width = true;
      }
    }
    if (Number.isFinite(position.height) || position.height === "auto" || position.height === "inherit" || position.height === null) {
      position.height = typeof position.height === "number" ? Math.round(position.height) : position.height;
      if (data.height !== position.height) {
        data.height = position.height;
        changeSet.height = true;
      }
    }
    if (el) {
      const defaultData = this.#state.getDefault();
      if (typeof defaultData !== "object") {
        this.#state.save({ name: "#defaultData", ...Object.assign({}, data) });
      }
      if (immediateElementUpdate) {
        UpdateElementManager.immediate(el, this.#updateElementData);
        this.#updateElementPromise = Promise.resolve(performance.now());
      } else if (!this.#updateElementData.queued) {
        this.#updateElementPromise = UpdateElementManager.add(el, this.#updateElementData);
      }
    } else {
      UpdateElementManager.updateSubscribers(this.#updateElementData);
    }
    return this;
  }
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(Object.assign({}, this.#data));
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updatePosition({
    left,
    top,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    width,
    height,
    rotateX,
    rotateY,
    rotateZ,
    scale,
    transformOrigin,
    translateX,
    translateY,
    translateZ,
    zIndex,
    rotation,
    ...rest
  } = {}, parent, el, styleCache) {
    let currentPosition = s_DATA_UPDATE.copy(this.#data);
    if (el.style.width === "" || width !== void 0) {
      if (width === "auto" || currentPosition.width === "auto" && width !== null) {
        currentPosition.width = "auto";
        width = styleCache.offsetWidth;
      } else if (width === "inherit" || currentPosition.width === "inherit" && width !== null) {
        currentPosition.width = "inherit";
        width = styleCache.offsetWidth;
      } else {
        const newWidth = Number.isFinite(width) ? width : currentPosition.width;
        currentPosition.width = width = Number.isFinite(newWidth) ? Math.round(newWidth) : styleCache.offsetWidth;
      }
    } else {
      width = Number.isFinite(currentPosition.width) ? currentPosition.width : styleCache.offsetWidth;
    }
    if (el.style.height === "" || height !== void 0) {
      if (height === "auto" || currentPosition.height === "auto" && height !== null) {
        currentPosition.height = "auto";
        height = styleCache.offsetHeight;
      } else if (height === "inherit" || currentPosition.height === "inherit" && height !== null) {
        currentPosition.height = "inherit";
        height = styleCache.offsetHeight;
      } else {
        const newHeight = Number.isFinite(height) ? height : currentPosition.height;
        currentPosition.height = height = Number.isFinite(newHeight) ? Math.round(newHeight) : styleCache.offsetHeight;
      }
    } else {
      height = Number.isFinite(currentPosition.height) ? currentPosition.height : styleCache.offsetHeight;
    }
    if (Number.isFinite(left)) {
      currentPosition.left = left;
    } else if (!Number.isFinite(currentPosition.left)) {
      currentPosition.left = typeof this.#options.initialHelper?.getLeft === "function" ? this.#options.initialHelper.getLeft(width) : 0;
    }
    if (Number.isFinite(top)) {
      currentPosition.top = top;
    } else if (!Number.isFinite(currentPosition.top)) {
      currentPosition.top = typeof this.#options.initialHelper?.getTop === "function" ? this.#options.initialHelper.getTop(height) : 0;
    }
    if (Number.isFinite(maxHeight) || maxHeight === null) {
      currentPosition.maxHeight = Number.isFinite(maxHeight) ? Math.round(maxHeight) : null;
    }
    if (Number.isFinite(maxWidth) || maxWidth === null) {
      currentPosition.maxWidth = Number.isFinite(maxWidth) ? Math.round(maxWidth) : null;
    }
    if (Number.isFinite(minHeight) || minHeight === null) {
      currentPosition.minHeight = Number.isFinite(minHeight) ? Math.round(minHeight) : null;
    }
    if (Number.isFinite(minWidth) || minWidth === null) {
      currentPosition.minWidth = Number.isFinite(minWidth) ? Math.round(minWidth) : null;
    }
    if (Number.isFinite(rotateX) || rotateX === null) {
      currentPosition.rotateX = rotateX;
    }
    if (Number.isFinite(rotateY) || rotateY === null) {
      currentPosition.rotateY = rotateY;
    }
    if (rotateZ !== currentPosition.rotateZ && (Number.isFinite(rotateZ) || rotateZ === null)) {
      currentPosition.rotateZ = rotateZ;
    } else if (rotation !== currentPosition.rotateZ && (Number.isFinite(rotation) || rotation === null)) {
      currentPosition.rotateZ = rotation;
    }
    if (Number.isFinite(translateX) || translateX === null) {
      currentPosition.translateX = translateX;
    }
    if (Number.isFinite(translateY) || translateY === null) {
      currentPosition.translateY = translateY;
    }
    if (Number.isFinite(translateZ) || translateZ === null) {
      currentPosition.translateZ = translateZ;
    }
    if (Number.isFinite(scale) || scale === null) {
      currentPosition.scale = typeof scale === "number" ? Math.max(0, Math.min(scale, 1e3)) : null;
    }
    if (typeof transformOrigin === "string" || transformOrigin === null) {
      currentPosition.transformOrigin = transformOrigins.includes(transformOrigin) ? transformOrigin : null;
    }
    if (Number.isFinite(zIndex) || zIndex === null) {
      currentPosition.zIndex = typeof zIndex === "number" ? Math.round(zIndex) : zIndex;
    }
    const validatorData = this.#validatorData;
    if (validatorData.length) {
      s_VALIDATION_DATA.parent = parent;
      s_VALIDATION_DATA.el = el;
      s_VALIDATION_DATA.computed = styleCache.computed;
      s_VALIDATION_DATA.transforms = this.#transforms;
      s_VALIDATION_DATA.height = height;
      s_VALIDATION_DATA.width = width;
      s_VALIDATION_DATA.marginLeft = styleCache.marginLeft;
      s_VALIDATION_DATA.marginTop = styleCache.marginTop;
      s_VALIDATION_DATA.maxHeight = styleCache.maxHeight ?? currentPosition.maxHeight;
      s_VALIDATION_DATA.maxWidth = styleCache.maxWidth ?? currentPosition.maxWidth;
      const isMinimized = parent?.reactive?.minimized ?? false;
      s_VALIDATION_DATA.minHeight = isMinimized ? currentPosition.minHeight ?? 0 : styleCache.minHeight || (currentPosition.minHeight ?? 0);
      s_VALIDATION_DATA.minWidth = isMinimized ? currentPosition.minWidth ?? 0 : styleCache.minWidth || (currentPosition.minWidth ?? 0);
      for (let cntr = 0; cntr < validatorData.length; cntr++) {
        s_VALIDATION_DATA.position = currentPosition;
        s_VALIDATION_DATA.rest = rest;
        currentPosition = validatorData[cntr].validator(s_VALIDATION_DATA);
        if (currentPosition === null) {
          return null;
        }
      }
    }
    return currentPosition;
  }
}
__name(Position, "Position");
const s_DATA_UPDATE = new PositionData();
const s_VALIDATION_DATA = {
  position: void 0,
  parent: void 0,
  el: void 0,
  computed: void 0,
  transforms: void 0,
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0,
  maxHeight: void 0,
  maxWidth: void 0,
  minHeight: void 0,
  minWidth: void 0,
  rest: void 0
};
Object.seal(s_VALIDATION_DATA);
class ApplicationState {
  #application;
  #dataSaved = /* @__PURE__ */ new Map();
  constructor(application) {
    this.#application = application;
  }
  get(extra = {}) {
    return Object.assign(extra, {
      position: this.#application?.position?.get(),
      beforeMinimized: this.#application?.position?.state.get({ name: "#beforeMinimized" }),
      options: Object.assign({}, this.#application?.options),
      ui: { minimized: this.#application?.reactive?.minimized }
    });
  }
  getSave({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name);
  }
  remove({ name }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name);
    this.#dataSaved.delete(name);
    return data;
  }
  restore({
    name,
    remove = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity,
    interpolate = lerp$5
  }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name);
      }
      if (async) {
        return this.set(dataSaved, { async, animateTo, duration, ease, interpolate }).then(() => dataSaved);
      } else {
        this.set(dataSaved, { async, animateTo, duration, ease, interpolate });
      }
    }
    return dataSaved;
  }
  save({ name, ...extra }) {
    if (typeof name !== "string") {
      throw new TypeError(`ApplicationState - save error: 'name' is not a string.`);
    }
    const data = this.get(extra);
    this.#dataSaved.set(name, data);
    return data;
  }
  set(data, { async = false, animateTo = false, duration = 0.1, ease = identity, interpolate = lerp$5 } = {}) {
    if (!isObject(data)) {
      throw new TypeError(`ApplicationState - restore error: 'data' is not an object.`);
    }
    const application = this.#application;
    if (!isObject(data?.position)) {
      console.warn(`ApplicationState.set warning: 'data.position' is not an object.`);
      return application;
    }
    const rendered = application.rendered;
    if (animateTo && !rendered) {
      console.warn(`ApplicationState.set warning: Application is not rendered and 'animateTo' is true.`);
      return application;
    }
    if (animateTo) {
      if (data.position.transformOrigin !== application.position.transformOrigin) {
        application.position.transformOrigin = data.position.transformOrigin;
      }
      if (isObject(data?.ui)) {
        const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
        if (application?.reactive?.minimized && !minimized) {
          application.maximize({ animate: false, duration: 0 });
        }
      }
      const promise2 = application.position.animate.to(
        data.position,
        { duration, ease, interpolate }
      ).finished.then((cancelled) => {
        if (cancelled) {
          return application;
        }
        if (isObject(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration: 0 });
          }
        }
        if (isObject(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
        return application;
      });
      if (async) {
        return promise2;
      }
    } else {
      if (rendered) {
        if (isObject(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (application?.reactive?.minimized && !minimized) {
            application.maximize({ animate: false, duration: 0 });
          } else if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration });
          }
        }
        if (isObject(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
        application.position.set(data.position);
      } else {
        let positionData = data.position;
        if (isObject(data.beforeMinimized)) {
          positionData = data.beforeMinimized;
          positionData.left = data.position.left;
          positionData.top = data.position.top;
        }
        application.position.set(positionData);
      }
    }
    return application;
  }
}
__name(ApplicationState, "ApplicationState");
class GetSvelteData {
  #applicationShellHolder;
  #svelteData;
  constructor(applicationShellHolder, svelteData) {
    this.#applicationShellHolder = applicationShellHolder;
    this.#svelteData = svelteData;
  }
  get applicationShell() {
    return this.#applicationShellHolder[0];
  }
  component(index) {
    const data = this.#svelteData[index];
    return typeof data === "object" ? data?.component : void 0;
  }
  *componentEntries() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield [cntr, this.#svelteData[cntr].component];
    }
  }
  *componentValues() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield this.#svelteData[cntr].component;
    }
  }
  data(index) {
    return this.#svelteData[index];
  }
  dataByComponent(component) {
    for (const data of this.#svelteData) {
      if (data.component === component) {
        return data;
      }
    }
    return void 0;
  }
  dataEntries() {
    return this.#svelteData.entries();
  }
  dataValues() {
    return this.#svelteData.values();
  }
  get length() {
    return this.#svelteData.length;
  }
}
__name(GetSvelteData, "GetSvelteData");
function loadSvelteConfig({ app, template, config, elementRootUpdate } = {}) {
  const svelteOptions = typeof config.options === "object" ? config.options : {};
  let target;
  if (config.target instanceof HTMLElement) {
    target = config.target;
  } else if (template instanceof HTMLElement && typeof config.target === "string") {
    target = template.querySelector(config.target);
  } else {
    target = document.createDocumentFragment();
  }
  if (target === void 0) {
    console.log(
      `%c[TRL] loadSvelteConfig error - could not find target selector, '${config.target}', for config:
`,
      "background: rgb(57,34,34)",
      config
    );
    throw new Error();
  }
  const NewSvelteComponent = config.class;
  const svelteConfig = parseSvelteConfig({ ...config, target }, app);
  const externalContext = svelteConfig.context.get("external");
  externalContext.application = app;
  externalContext.elementRootUpdate = elementRootUpdate;
  let eventbus;
  if (typeof app._eventbus === "object" && typeof app._eventbus.createProxy === "function") {
    eventbus = app._eventbus.createProxy();
    externalContext.eventbus = eventbus;
  }
  const component = new NewSvelteComponent(svelteConfig);
  svelteConfig.eventbus = eventbus;
  let element2;
  if (isApplicationShell(component)) {
    element2 = component.elementRoot;
  }
  if (target instanceof DocumentFragment && target.firstElementChild) {
    if (element2 === void 0) {
      element2 = target.firstElementChild;
    }
    template.append(target);
  } else if (config.target instanceof HTMLElement && element2 === void 0) {
    if (config.target instanceof HTMLElement && typeof svelteOptions.selectorElement !== "string") {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with no 'selectorElement' defined.

Note: If configuring an application shell and directly targeting a HTMLElement did you bind an'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
        "background: rgb(57,34,34)",
        config
      );
      throw new Error();
    }
    element2 = target.querySelector(svelteOptions.selectorElement);
    if (element2 === null || element2 === void 0) {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with 'selectorElement', '${svelteOptions.selectorElement}', not found for config:
`,
        "background: rgb(57,34,34)",
        config
      );
      throw new Error();
    }
  }
  const injectHTML = !(config.target instanceof HTMLElement);
  return { config: svelteConfig, component, element: element2, injectHTML };
}
__name(loadSvelteConfig, "loadSvelteConfig");
class SvelteReactive {
  #application;
  #initialized = false;
  #storeAppOptions;
  #storeAppOptionsUpdate;
  #dataUIState;
  #storeUIState;
  #storeUIStateUpdate;
  #storeUnsubscribe = [];
  constructor(application) {
    this.#application = application;
  }
  initialize() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    this.#storesInitialize();
    return {
      appOptionsUpdate: this.#storeAppOptionsUpdate,
      uiOptionsUpdate: this.#storeUIStateUpdate,
      subscribe: this.#storesSubscribe.bind(this),
      unsubscribe: this.#storesUnsubscribe.bind(this)
    };
  }
  get dragging() {
    return this.#dataUIState.dragging;
  }
  get minimized() {
    return this.#dataUIState.minimized;
  }
  get resizing() {
    return this.#dataUIState.resizing;
  }
  get draggable() {
    return this.#application?.options?.draggable;
  }
  get headerButtonNoClose() {
    return this.#application?.options?.headerButtonNoClose;
  }
  get headerButtonNoLabel() {
    return this.#application?.options?.headerButtonNoLabel;
  }
  get headerNoTitleMinimized() {
    return this.#application?.options?.headerNoTitleMinimized;
  }
  get minimizable() {
    return this.#application?.options?.minimizable;
  }
  get popOut() {
    return this.#application.popOut;
  }
  get resizable() {
    return this.#application?.options?.resizable;
  }
  get storeAppOptions() {
    return this.#storeAppOptions;
  }
  get storeUIState() {
    return this.#storeUIState;
  }
  get title() {
    return this.#application.title;
  }
  set draggable(draggable2) {
    if (typeof draggable2 === "boolean") {
      this.setOptions("draggable", draggable2);
    }
  }
  set headerButtonNoClose(headerButtonNoClose) {
    if (typeof headerButtonNoClose === "boolean") {
      this.setOptions("headerButtonNoClose", headerButtonNoClose);
    }
  }
  set headerButtonNoLabel(headerButtonNoLabel) {
    if (typeof headerButtonNoLabel === "boolean") {
      this.setOptions("headerButtonNoLabel", headerButtonNoLabel);
    }
  }
  set headerNoTitleMinimized(headerNoTitleMinimized) {
    if (typeof headerNoTitleMinimized === "boolean") {
      this.setOptions("headerNoTitleMinimized", headerNoTitleMinimized);
    }
  }
  set minimizable(minimizable) {
    if (typeof minimizable === "boolean") {
      this.setOptions("minimizable", minimizable);
    }
  }
  set popOut(popOut) {
    if (typeof popOut === "boolean") {
      this.setOptions("popOut", popOut);
    }
  }
  set resizable(resizable) {
    if (typeof resizable === "boolean") {
      this.setOptions("resizable", resizable);
    }
  }
  set title(title) {
    if (typeof title === "string") {
      this.setOptions("title", title);
    } else if (title === void 0 || title === null) {
      this.setOptions("title", "");
    }
  }
  getOptions(accessor, defaultValue) {
    return safeAccess(this.#application.options, accessor, defaultValue);
  }
  mergeOptions(options) {
    this.#storeAppOptionsUpdate((instanceOptions) => deepMerge(instanceOptions, options));
  }
  setOptions(accessor, value) {
    const success = safeSet(this.#application.options, accessor, value);
    if (success) {
      this.#storeAppOptionsUpdate(() => this.#application.options);
    }
  }
  #storesInitialize() {
    const writableAppOptions = writable(this.#application.options);
    this.#storeAppOptionsUpdate = writableAppOptions.update;
    const storeAppOptions = {
      subscribe: writableAppOptions.subscribe,
      draggable: propertyStore(writableAppOptions, "draggable"),
      headerButtonNoClose: propertyStore(writableAppOptions, "headerButtonNoClose"),
      headerButtonNoLabel: propertyStore(writableAppOptions, "headerButtonNoLabel"),
      headerNoTitleMinimized: propertyStore(writableAppOptions, "headerNoTitleMinimized"),
      minimizable: propertyStore(writableAppOptions, "minimizable"),
      popOut: propertyStore(writableAppOptions, "popOut"),
      resizable: propertyStore(writableAppOptions, "resizable"),
      title: propertyStore(writableAppOptions, "title")
    };
    Object.freeze(storeAppOptions);
    this.#storeAppOptions = storeAppOptions;
    this.#dataUIState = {
      dragging: false,
      headerButtons: [],
      minimized: this.#application._minimized,
      resizing: false
    };
    const writableUIOptions = writable(this.#dataUIState);
    this.#storeUIStateUpdate = writableUIOptions.update;
    const storeUIState = {
      subscribe: writableUIOptions.subscribe,
      dragging: propertyStore(writableUIOptions, "dragging"),
      headerButtons: derived(writableUIOptions, ($options, set) => set($options.headerButtons)),
      minimized: derived(writableUIOptions, ($options, set) => set($options.minimized)),
      resizing: propertyStore(writableUIOptions, "resizing")
    };
    Object.freeze(storeUIState);
    this.#storeUIState = storeUIState;
  }
  #storesSubscribe() {
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoClose, (value) => {
      this.updateHeaderButtons({ headerButtonNoClose: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoLabel, (value) => {
      this.updateHeaderButtons({ headerButtonNoLabel: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.popOut, (value) => {
      if (value && this.#application.rendered) {
        ui.windows[this.#application.appId] = this.#application;
      } else {
        delete ui.windows[this.#application.appId];
      }
    }));
  }
  #storesUnsubscribe() {
    this.#storeUnsubscribe.forEach((unsubscribe) => unsubscribe());
    this.#storeUnsubscribe = [];
  }
  updateHeaderButtons({
    headerButtonNoClose = this.#application.options.headerButtonNoClose,
    headerButtonNoLabel = this.#application.options.headerButtonNoLabel
  } = {}) {
    let buttons = this.#application._getHeaderButtons();
    if (typeof headerButtonNoClose === "boolean" && headerButtonNoClose) {
      buttons = buttons.filter((button) => button.class !== "close");
    }
    if (typeof headerButtonNoLabel === "boolean" && headerButtonNoLabel) {
      for (const button of buttons) {
        button.label = void 0;
      }
    }
    this.#storeUIStateUpdate((options) => {
      options.headerButtons = buttons;
      return options;
    });
  }
}
__name(SvelteReactive, "SvelteReactive");
class SvelteApplication extends Application {
  #applicationShellHolder = [null];
  #applicationState;
  #elementTarget = null;
  #elementContent = null;
  #initialZIndex = 95;
  #onMount = false;
  #position;
  #reactive;
  #svelteData = [];
  #getSvelteData = new GetSvelteData(this.#applicationShellHolder, this.#svelteData);
  #stores;
  constructor(options = {}) {
    super(options);
    this.#applicationState = new ApplicationState(this);
    this.#position = new Position(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    });
    delete this.position;
    Object.defineProperty(this, "position", {
      get: () => this.#position,
      set: (position) => {
        if (typeof position === "object") {
          this.#position.set(position);
        }
      }
    });
    this.#reactive = new SvelteReactive(this);
    this.#stores = this.#reactive.initialize();
  }
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      defaultCloseAnimation: true,
      draggable: true,
      headerButtonNoClose: false,
      headerButtonNoLabel: false,
      headerNoTitleMinimized: false,
      minHeight: MIN_WINDOW_HEIGHT,
      minWidth: MIN_WINDOW_WIDTH,
      positionable: true,
      positionInitial: Position.Initial.browserCentered,
      positionOrtho: true,
      positionValidator: Position.Validators.transformWindow,
      transformOrigin: "top left"
    });
  }
  get elementContent() {
    return this.#elementContent;
  }
  get elementTarget() {
    return this.#elementTarget;
  }
  get reactive() {
    return this.#reactive;
  }
  get state() {
    return this.#applicationState;
  }
  get svelte() {
    return this.#getSvelteData;
  }
  _activateCoreListeners(html) {
    super._activateCoreListeners(typeof this.options.template === "string" ? html : [this.#elementTarget]);
  }
  bringToTop({ force = false } = {}) {
    if (force || this.popOut) {
      super.bringToTop();
    }
    if (document.activeElement !== document.body && !this.elementTarget.contains(document.activeElement)) {
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
      document.body.focus();
    }
    ui.activeWindow = this;
  }
  async close(options = {}) {
    const states = Application.RENDER_STATES;
    if (!options.force && ![states.RENDERED, states.ERROR].includes(this._state)) {
      return;
    }
    this.#stores.unsubscribe();
    this._state = states.CLOSING;
    const el = this.#elementTarget;
    if (!el) {
      return this._state = states.CLOSED;
    }
    const content = el.querySelector(".window-content");
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    for (const cls of this.constructor._getInheritanceChain()) {
      Hooks.call(`close${cls.name}`, this, el);
    }
    const animate = typeof this.options.defaultCloseAnimation === "boolean" ? this.options.defaultCloseAnimation : true;
    if (animate) {
      el.style.minHeight = "0";
      const { paddingBottom, paddingTop } = globalThis.getComputedStyle(el);
      await el.animate([
        { maxHeight: `${el.clientHeight}px`, paddingTop, paddingBottom },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const svelteDestroyPromises = [];
    for (const entry of this.#svelteData) {
      svelteDestroyPromises.push(outroAndDestroy(entry.component));
      const eventbus = entry.config.eventbus;
      if (typeof eventbus === "object" && typeof eventbus.off === "function") {
        eventbus.off();
        entry.config.eventbus = void 0;
      }
    }
    await Promise.all(svelteDestroyPromises);
    this.#svelteData.length = 0;
    el.remove();
    this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: true,
      remove: true
    });
    this.#applicationShellHolder[0] = null;
    this._element = null;
    this.#elementContent = null;
    this.#elementTarget = null;
    delete ui.windows[this.appId];
    this._minimized = false;
    this._scrollPositions = null;
    this._state = states.CLOSED;
    this.#onMount = false;
    this.#stores.uiOptionsUpdate((storeOptions) => deepMerge(storeOptions, { minimized: this._minimized }));
  }
  _injectHTML(html) {
    if (this.popOut && html.length === 0 && Array.isArray(this.options.svelte)) {
      throw new Error(
        "SvelteApplication - _injectHTML - A popout app with no template can only support one Svelte component."
      );
    }
    this.reactive.updateHeaderButtons();
    const elementRootUpdate = /* @__PURE__ */ __name(() => {
      let cntr = 0;
      return (elementRoot) => {
        if (elementRoot !== null && elementRoot !== void 0 && cntr++ > 0) {
          this.#updateApplicationShell();
          return true;
        }
        return false;
      };
    }, "elementRootUpdate");
    if (Array.isArray(this.options.svelte)) {
      for (const svelteConfig of this.options.svelte) {
        const svelteData = loadSvelteConfig({
          app: this,
          template: html[0],
          config: svelteConfig,
          elementRootUpdate
        });
        if (isApplicationShell(svelteData.component)) {
          if (this.svelte.applicationShell !== null) {
            throw new Error(
              `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                    ${JSON.stringify(svelteConfig)}`
            );
          }
          this.#applicationShellHolder[0] = svelteData.component;
          if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
            svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
          }
        }
        this.#svelteData.push(svelteData);
      }
    } else if (typeof this.options.svelte === "object") {
      const svelteData = loadSvelteConfig({
        app: this,
        template: html[0],
        config: this.options.svelte,
        elementRootUpdate
      });
      if (isApplicationShell(svelteData.component)) {
        if (this.svelte.applicationShell !== null) {
          throw new Error(
            `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                 ${JSON.stringify(this.options.svelte)}`
          );
        }
        this.#applicationShellHolder[0] = svelteData.component;
        if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
          svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
        }
      }
      this.#svelteData.push(svelteData);
    }
    const isDocumentFragment = html.length && html[0] instanceof DocumentFragment;
    let injectHTML = true;
    for (const svelteData of this.#svelteData) {
      if (!svelteData.injectHTML) {
        injectHTML = false;
        break;
      }
    }
    if (injectHTML) {
      super._injectHTML(html);
    }
    if (this.svelte.applicationShell !== null) {
      this._element = $(this.svelte.applicationShell.elementRoot);
      this.#elementContent = hasGetter(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : null;
    } else if (isDocumentFragment) {
      for (const svelteData of this.#svelteData) {
        if (svelteData.element instanceof HTMLElement) {
          this._element = $(svelteData.element);
          break;
        }
      }
    }
    if (this.#elementTarget === null) {
      const element2 = typeof this.options.selectorTarget === "string" ? this._element.find(this.options.selectorTarget) : this._element;
      this.#elementTarget = element2[0];
    }
    if (this.#elementTarget === null || this.#elementTarget === void 0 || this.#elementTarget.length === 0) {
      throw new Error(`SvelteApplication - _injectHTML: Target element '${this.options.selectorTarget}' not found.`);
    }
    if (typeof this.options.positionable === "boolean" && this.options.positionable) {
      this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
    }
    this.#stores.subscribe();
  }
  async maximize({ animate = true, duration = 0.1 } = {}) {
    if (!this.popOut || [false, null].includes(this._minimized)) {
      return;
    }
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const positionBefore = this.position.state.get({ name: "#beforeMinimized" });
    if (animate) {
      await this.position.state.restore({
        name: "#beforeMinimized",
        async: true,
        animateTo: true,
        properties: ["width"],
        duration: 0.1
      });
    }
    for (let cntr = header.children.length; --cntr >= 0; ) {
      header.children[cntr].style.display = null;
    }
    content.style.display = null;
    let constraints;
    if (animate) {
      ({ constraints } = this.position.state.restore({
        name: "#beforeMinimized",
        animateTo: true,
        properties: ["height"],
        remove: true,
        duration
      }));
    } else {
      ({ constraints } = this.position.state.remove({ name: "#beforeMinimized" }));
    }
    await content.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...constraints, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: durationMS, fill: "forwards" }).finished;
    this.position.set({
      minHeight: positionBefore.minHeight ?? this.options?.minHeight ?? MIN_WINDOW_HEIGHT,
      minWidth: positionBefore.minWidth ?? this.options?.minWidth ?? MIN_WINDOW_WIDTH
    });
    element2.style.minWidth = null;
    element2.style.minHeight = null;
    element2.classList.remove("minimized");
    this._minimized = false;
    setTimeout(() => {
      content.style.overflow = null;
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = null;
      }
    }, 50);
    this.#stores.uiOptionsUpdate((options) => deepMerge(options, { minimized: false }));
  }
  async minimize({ animate = true, duration = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [true, null].includes(this._minimized)) {
      return;
    }
    this.#stores.uiOptionsUpdate((options) => deepMerge(options, { minimized: true }));
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const beforeMinWidth = this.position.minWidth;
    const beforeMinHeight = this.position.minHeight;
    this.position.set({ minWidth: 100, minHeight: 30 });
    element2.style.minWidth = "100px";
    element2.style.minHeight = "30px";
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    const { paddingBottom, paddingTop } = globalThis.getComputedStyle(content);
    const constraints = {
      maxHeight: `${content.clientHeight}px`,
      paddingTop,
      paddingBottom
    };
    if (animate) {
      const animation = content.animate([
        constraints,
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: durationMS, fill: "forwards" });
      animation.finished.then(() => content.style.display = "none");
    } else {
      setTimeout(() => content.style.display = "none", durationMS);
    }
    const saved = this.position.state.save({ name: "#beforeMinimized", constraints });
    saved.minWidth = beforeMinWidth;
    saved.minHeight = beforeMinHeight;
    const headerOffsetHeight = header.offsetHeight;
    this.position.minHeight = headerOffsetHeight;
    if (animate) {
      await this.position.animate.to({ height: headerOffsetHeight }, { duration }).finished;
    }
    for (let cntr = header.children.length; --cntr >= 0; ) {
      const className = header.children[cntr].className;
      if (className.includes("window-title") || className.includes("close")) {
        continue;
      }
      if (className.includes("keep-minimized")) {
        header.children[cntr].style.display = "block";
        continue;
      }
      header.children[cntr].style.display = "none";
    }
    if (animate) {
      await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished;
    }
    element2.classList.add("minimized");
    this._minimized = true;
  }
  onSvelteMount({ element: element2, elementContent, elementTarget } = {}) {
  }
  onSvelteRemount({ element: element2, elementContent, elementTarget } = {}) {
  }
  _replaceHTML(element2, html) {
    if (!element2.length) {
      return;
    }
    this.reactive.updateHeaderButtons();
  }
  async _render(force = false, options = {}) {
    if (this._state === Application.RENDER_STATES.NONE && document.querySelector(`#${this.id}`) instanceof HTMLElement) {
      console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    await super._render(force, options);
    if (!this.#onMount) {
      this.onSvelteMount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
      this.#onMount = true;
    }
  }
  async _renderInner(data) {
    const html = typeof this.template === "string" ? await renderTemplate(this.template, data) : document.createDocumentFragment();
    return $(html);
  }
  async _renderOuter() {
    const html = await super._renderOuter();
    this.#initialZIndex = html[0].style.zIndex;
    return html;
  }
  setPosition(position) {
    return this.position.set(position);
  }
  #updateApplicationShell() {
    const applicationShell = this.svelte.applicationShell;
    if (applicationShell !== null) {
      this._element = $(applicationShell.elementRoot);
      this.#elementContent = hasGetter(applicationShell, "elementContent") ? applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(applicationShell, "elementTarget") ? applicationShell.elementTarget : null;
      if (this.#elementTarget === null) {
        const element2 = typeof this.options.selectorTarget === "string" ? this._element.find(this.options.selectorTarget) : this._element;
        this.#elementTarget = element2[0];
      }
      if (typeof this.options.positionable === "boolean" && this.options.positionable) {
        this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
        super.bringToTop();
        this.position.set(this.position.get());
      }
      super._activateCoreListeners([this.#elementTarget]);
      this.onSvelteRemount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
    }
  }
}
__name(SvelteApplication, "SvelteApplication");
const TJSContainer_svelte_svelte_type_style_lang = "";
function get_each_context$t(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
__name(get_each_context$t, "get_each_context$t");
function create_if_block_1$v(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Container warning: No children.";
      attr(p, "class", "svelte-1s361pr");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_1$v, "create_if_block_1$v");
function create_if_block$I(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$t(get_each_context$t(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$t(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$t(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
__name(create_if_block$I, "create_if_block$I");
function create_each_block$t(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[2].props];
  var switch_value = ctx[2].class;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[2].props)]) : {};
      if (switch_value !== (switch_value = ctx2[2].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_each_block$t, "create_each_block$t");
function create_fragment$V(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$I, create_if_block_1$v];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[1]);
    if (show_if)
      return 0;
    if (ctx2[0])
      return 1;
    return -1;
  }
  __name(select_block_type, "select_block_type");
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_fragment$V, "create_fragment$V");
function instance$V($$self, $$props, $$invalidate) {
  let { warn = false } = $$props;
  let { children: children2 = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("warn" in $$props2)
      $$invalidate(0, warn = $$props2.warn);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
  };
  return [warn, children2];
}
__name(instance$V, "instance$V");
class TJSContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$V, safe_not_equal, { warn: 0, children: 1 });
  }
  get warn() {
    return this.$$.ctx[0];
  }
  set warn(warn) {
    this.$$set({ warn });
    flush();
  }
  get children() {
    return this.$$.ctx[1];
  }
  set children(children2) {
    this.$$set({ children: children2 });
    flush();
  }
}
__name(TJSContainer, "TJSContainer");
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
__name(fade, "fade");
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}
__name(slide, "slide");
function slideFade(node, options) {
  const fadeEasing = options.easingFade || options.easing || identity;
  const slideEasing = options.easingSlide || options.easing || identity;
  const fadeTransition = fade(node);
  const slideTransition = slide(node);
  return {
    delay: options.delay || 0,
    duration: options.duration || 500,
    easing: identity,
    css: (t) => {
      const fadeT = fadeEasing(t);
      const slideT = slideEasing(t);
      return `${slideTransition.css(slideT, 1 - slideT)}; ${fadeTransition.css(fadeT, 1 - fadeT)}`;
    }
  };
}
__name(slideFade, "slideFade");
const s_DEFAULT_TRANSITION = /* @__PURE__ */ __name(() => void 0, "s_DEFAULT_TRANSITION");
const s_DEFAULT_TRANSITION_OPTIONS = {};
const TJSGlassPane_svelte_svelte_type_style_lang = "";
function create_fragment$U(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "id", ctx[4]);
      attr(div, "class", "tjs-glass-pane svelte-71db55");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[18](div);
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[6]);
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(default_slot_template, ctx[16], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 16) {
        attr(div, "id", ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, ctx[0], ctx[2]);
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, ctx[1], ctx[3]);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[18](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$U, "create_fragment$U");
function instance$U($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id = void 0 } = $$props;
  let { zIndex = Number.MAX_SAFE_INTEGER } = $$props;
  let { background = "#50505080" } = $$props;
  let { captureInput = true } = $$props;
  let { preventDefault: preventDefault2 = true } = $$props;
  let { stopPropagation = true } = $$props;
  let glassPane;
  let { transition = void 0 } = $$props;
  let { inTransition = s_DEFAULT_TRANSITION } = $$props;
  let { outTransition = s_DEFAULT_TRANSITION } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let { outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let oldTransition = void 0;
  let oldTransitionOptions = void 0;
  function swallow(event) {
    if (captureInput) {
      if (preventDefault2) {
        event.preventDefault();
      }
      if (stopPropagation) {
        event.stopPropagation();
      }
    }
  }
  __name(swallow, "swallow");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      glassPane = $$value;
      $$invalidate(5, glassPane), $$invalidate(9, captureInput), $$invalidate(8, background), $$invalidate(7, zIndex);
    });
  }
  __name(div_binding, "div_binding");
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("zIndex" in $$props2)
      $$invalidate(7, zIndex = $$props2.zIndex);
    if ("background" in $$props2)
      $$invalidate(8, background = $$props2.background);
    if ("captureInput" in $$props2)
      $$invalidate(9, captureInput = $$props2.captureInput);
    if ("preventDefault" in $$props2)
      $$invalidate(10, preventDefault2 = $$props2.preventDefault);
    if ("stopPropagation" in $$props2)
      $$invalidate(11, stopPropagation = $$props2.stopPropagation);
    if ("transition" in $$props2)
      $$invalidate(12, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(0, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(1, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(13, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(2, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(3, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      if (glassPane) {
        $$invalidate(5, glassPane.style.maxWidth = "100%", glassPane);
        $$invalidate(5, glassPane.style.maxHeight = "100%", glassPane);
        $$invalidate(5, glassPane.style.width = "100%", glassPane);
        $$invalidate(5, glassPane.style.height = "100%", glassPane);
      }
    }
    if ($$self.$$.dirty & 544) {
      if (glassPane) {
        if (captureInput) {
          glassPane.focus();
        }
        $$invalidate(5, glassPane.style.pointerEvents = captureInput ? "auto" : "none", glassPane);
      }
    }
    if ($$self.$$.dirty & 288) {
      if (glassPane) {
        $$invalidate(5, glassPane.style.background = background, glassPane);
      }
    }
    if ($$self.$$.dirty & 160) {
      if (glassPane) {
        $$invalidate(5, glassPane.style.zIndex = zIndex, glassPane);
      }
    }
    if ($$self.$$.dirty & 20480) {
      if (oldTransition !== transition) {
        const newTransition = s_DEFAULT_TRANSITION !== transition && typeof transition === "function" ? transition : s_DEFAULT_TRANSITION;
        $$invalidate(0, inTransition = newTransition);
        $$invalidate(1, outTransition = newTransition);
        $$invalidate(14, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty & 40960) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== s_DEFAULT_TRANSITION_OPTIONS && typeof transitionOptions === "object" ? transitionOptions : s_DEFAULT_TRANSITION_OPTIONS;
        $$invalidate(2, inTransitionOptions = newOptions);
        $$invalidate(3, outTransitionOptions = newOptions);
        $$invalidate(15, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty & 1) {
      if (typeof inTransition !== "function") {
        $$invalidate(0, inTransition = s_DEFAULT_TRANSITION);
      }
    }
    if ($$self.$$.dirty & 2) {
      if (typeof outTransition !== "function") {
        $$invalidate(1, outTransition = s_DEFAULT_TRANSITION);
      }
    }
    if ($$self.$$.dirty & 4) {
      if (typeof inTransitionOptions !== "object") {
        $$invalidate(2, inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
    if ($$self.$$.dirty & 8) {
      if (typeof outTransitionOptions !== "object") {
        $$invalidate(3, outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
  };
  return [
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    id,
    glassPane,
    swallow,
    zIndex,
    background,
    captureInput,
    preventDefault2,
    stopPropagation,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $$scope,
    slots,
    div_binding
  ];
}
__name(instance$U, "instance$U");
class TJSGlassPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$U, safe_not_equal, {
      id: 4,
      zIndex: 7,
      background: 8,
      captureInput: 9,
      preventDefault: 10,
      stopPropagation: 11,
      transition: 12,
      inTransition: 0,
      outTransition: 1,
      transitionOptions: 13,
      inTransitionOptions: 2,
      outTransitionOptions: 3
    });
  }
  get id() {
    return this.$$.ctx[4];
  }
  set id(id) {
    this.$$set({ id });
    flush();
  }
  get zIndex() {
    return this.$$.ctx[7];
  }
  set zIndex(zIndex) {
    this.$$set({ zIndex });
    flush();
  }
  get background() {
    return this.$$.ctx[8];
  }
  set background(background) {
    this.$$set({ background });
    flush();
  }
  get captureInput() {
    return this.$$.ctx[9];
  }
  set captureInput(captureInput) {
    this.$$set({ captureInput });
    flush();
  }
  get preventDefault() {
    return this.$$.ctx[10];
  }
  set preventDefault(preventDefault2) {
    this.$$set({ preventDefault: preventDefault2 });
    flush();
  }
  get stopPropagation() {
    return this.$$.ctx[11];
  }
  set stopPropagation(stopPropagation) {
    this.$$set({ stopPropagation });
    flush();
  }
  get transition() {
    return this.$$.ctx[12];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get inTransition() {
    return this.$$.ctx[0];
  }
  set inTransition(inTransition) {
    this.$$set({ inTransition });
    flush();
  }
  get outTransition() {
    return this.$$.ctx[1];
  }
  set outTransition(outTransition) {
    this.$$set({ outTransition });
    flush();
  }
  get transitionOptions() {
    return this.$$.ctx[13];
  }
  set transitionOptions(transitionOptions) {
    this.$$set({ transitionOptions });
    flush();
  }
  get inTransitionOptions() {
    return this.$$.ctx[2];
  }
  set inTransitionOptions(inTransitionOptions) {
    this.$$set({ inTransitionOptions });
    flush();
  }
  get outTransitionOptions() {
    return this.$$.ctx[3];
  }
  set outTransitionOptions(outTransitionOptions) {
    this.$$set({ outTransitionOptions });
    flush();
  }
}
__name(TJSGlassPane, "TJSGlassPane");
function resizeObserver(node, target) {
  ResizeObserverManager.add(node, target);
  return {
    update: (newTarget) => {
      ResizeObserverManager.remove(node, target);
      target = newTarget;
      ResizeObserverManager.add(node, target);
    },
    destroy: () => {
      ResizeObserverManager.remove(node, target);
    }
  };
}
__name(resizeObserver, "resizeObserver");
resizeObserver.updateCache = function(el) {
  if (!(el instanceof HTMLElement)) {
    throw new TypeError(`resizeObserverUpdate error: 'el' is not an HTMLElement.`);
  }
  const subscribers = s_MAP.get(el);
  if (Array.isArray(subscribers)) {
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = styleParsePixels(el.style.borderBottom) ?? styleParsePixels(computed.borderBottom) ?? 0;
    const borderLeft = styleParsePixels(el.style.borderLeft) ?? styleParsePixels(computed.borderLeft) ?? 0;
    const borderRight = styleParsePixels(el.style.borderRight) ?? styleParsePixels(computed.borderRight) ?? 0;
    const borderTop = styleParsePixels(el.style.borderTop) ?? styleParsePixels(computed.borderTop) ?? 0;
    const paddingBottom = styleParsePixels(el.style.paddingBottom) ?? styleParsePixels(computed.paddingBottom) ?? 0;
    const paddingLeft = styleParsePixels(el.style.paddingLeft) ?? styleParsePixels(computed.paddingLeft) ?? 0;
    const paddingRight = styleParsePixels(el.style.paddingRight) ?? styleParsePixels(computed.paddingRight) ?? 0;
    const paddingTop = styleParsePixels(el.style.paddingTop) ?? styleParsePixels(computed.paddingTop) ?? 0;
    const additionalWidth = borderLeft + borderRight + paddingLeft + paddingRight;
    const additionalHeight = borderTop + borderBottom + paddingTop + paddingBottom;
    for (const subscriber of subscribers) {
      subscriber.styles.additionalWidth = additionalWidth;
      subscriber.styles.additionalHeight = additionalHeight;
      s_UPDATE_SUBSCRIBER(subscriber, subscriber.contentWidth, subscriber.contentHeight);
    }
  }
};
const s_MAP = /* @__PURE__ */ new Map();
class ResizeObserverManager {
  static add(el, target) {
    const updateType = s_GET_UPDATE_TYPE(target);
    if (updateType === 0) {
      throw new Error(`'target' does not match supported ResizeObserverManager update mechanisms.`);
    }
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = styleParsePixels(el.style.borderBottom) ?? styleParsePixels(computed.borderBottom) ?? 0;
    const borderLeft = styleParsePixels(el.style.borderLeft) ?? styleParsePixels(computed.borderLeft) ?? 0;
    const borderRight = styleParsePixels(el.style.borderRight) ?? styleParsePixels(computed.borderRight) ?? 0;
    const borderTop = styleParsePixels(el.style.borderTop) ?? styleParsePixels(computed.borderTop) ?? 0;
    const paddingBottom = styleParsePixels(el.style.paddingBottom) ?? styleParsePixels(computed.paddingBottom) ?? 0;
    const paddingLeft = styleParsePixels(el.style.paddingLeft) ?? styleParsePixels(computed.paddingLeft) ?? 0;
    const paddingRight = styleParsePixels(el.style.paddingRight) ?? styleParsePixels(computed.paddingRight) ?? 0;
    const paddingTop = styleParsePixels(el.style.paddingTop) ?? styleParsePixels(computed.paddingTop) ?? 0;
    const data = {
      updateType,
      target,
      contentWidth: 0,
      contentHeight: 0,
      styles: {
        additionalWidth: borderLeft + borderRight + paddingLeft + paddingRight,
        additionalHeight: borderTop + borderBottom + paddingTop + paddingBottom
      }
    };
    if (s_MAP.has(el)) {
      const subscribers = s_MAP.get(el);
      subscribers.push(data);
    } else {
      s_MAP.set(el, [data]);
    }
    s_RESIZE_OBSERVER.observe(el);
  }
  static remove(el, target = void 0) {
    const subscribers = s_MAP.get(el);
    if (Array.isArray(subscribers)) {
      const index = subscribers.findIndex((entry) => entry.target === target);
      if (index >= 0) {
        s_UPDATE_SUBSCRIBER(subscribers[index], void 0, void 0);
        subscribers.splice(index, 1);
      }
      if (subscribers.length === 0) {
        s_MAP.delete(el);
        s_RESIZE_OBSERVER.unobserve(el);
      }
    }
  }
}
__name(ResizeObserverManager, "ResizeObserverManager");
const s_UPDATE_TYPES = {
  none: 0,
  attribute: 1,
  function: 2,
  resizeObserved: 3,
  setContentBounds: 4,
  setDimension: 5,
  storeObject: 6,
  storesObject: 7
};
const s_RESIZE_OBSERVER = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const subscribers = s_MAP.get(entry?.target);
    if (Array.isArray(subscribers)) {
      const contentWidth = entry.contentRect.width;
      const contentHeight = entry.contentRect.height;
      for (const subscriber of subscribers) {
        s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight);
      }
    }
  }
});
function s_GET_UPDATE_TYPE(target) {
  if (target?.resizeObserved instanceof Function) {
    return s_UPDATE_TYPES.resizeObserved;
  }
  if (target?.setDimension instanceof Function) {
    return s_UPDATE_TYPES.setDimension;
  }
  if (target?.setContentBounds instanceof Function) {
    return s_UPDATE_TYPES.setContentBounds;
  }
  const targetType = typeof target;
  if (targetType === "object" || targetType === "function") {
    if (isUpdatableStore(target.resizeObserved)) {
      return s_UPDATE_TYPES.storeObject;
    }
    const stores = target?.stores;
    if (typeof stores === "object" || typeof stores === "function") {
      if (isUpdatableStore(stores.resizeObserved)) {
        return s_UPDATE_TYPES.storesObject;
      }
    }
  }
  if (targetType === "object") {
    return s_UPDATE_TYPES.attribute;
  }
  if (targetType === "function") {
    return s_UPDATE_TYPES.function;
  }
  return s_UPDATE_TYPES.none;
}
__name(s_GET_UPDATE_TYPE, "s_GET_UPDATE_TYPE");
function s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight) {
  const styles2 = subscriber.styles;
  subscriber.contentWidth = contentWidth;
  subscriber.contentHeight = contentHeight;
  const offsetWidth = Number.isFinite(contentWidth) ? contentWidth + styles2.additionalWidth : void 0;
  const offsetHeight = Number.isFinite(contentHeight) ? contentHeight + styles2.additionalHeight : void 0;
  const target = subscriber.target;
  switch (subscriber.updateType) {
    case s_UPDATE_TYPES.attribute:
      target.contentWidth = contentWidth;
      target.contentHeight = contentHeight;
      target.offsetWidth = offsetWidth;
      target.offsetHeight = offsetHeight;
      break;
    case s_UPDATE_TYPES.function:
      target?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.resizeObserved:
      target.resizeObserved?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setContentBounds:
      target.setContentBounds?.(contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setDimension:
      target.setDimension?.(offsetWidth, offsetHeight);
      break;
    case s_UPDATE_TYPES.storeObject:
      target.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
    case s_UPDATE_TYPES.storesObject:
      target.stores.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
  }
}
__name(s_UPDATE_SUBSCRIBER, "s_UPDATE_SUBSCRIBER");
function applyStyles(node, properties) {
  function setProperties() {
    if (typeof properties !== "object") {
      return;
    }
    for (const prop of Object.keys(properties)) {
      node.style.setProperty(`${prop}`, properties[prop]);
    }
  }
  __name(setProperties, "setProperties");
  setProperties();
  return {
    update(newProperties) {
      properties = newProperties;
      setProperties();
    }
  };
}
__name(applyStyles, "applyStyles");
function draggable(node, {
  position,
  active: active2 = true,
  button = 0,
  storeDragging = void 0,
  ease = false,
  easeOptions = { duration: 0.1, ease: cubicOut }
}) {
  let initialPosition = null;
  let initialDragPoint = {};
  let dragging = false;
  let quickTo = position.animate.quickTo(["top", "left"], easeOptions);
  const handlers = {
    dragDown: ["pointerdown", (e) => onDragPointerDown(e), false],
    dragMove: ["pointermove", (e) => onDragPointerChange(e), false],
    dragUp: ["pointerup", (e) => onDragPointerUp(e), false]
  };
  function activateListeners() {
    node.addEventListener(...handlers.dragDown);
    node.classList.add("draggable");
  }
  __name(activateListeners, "activateListeners");
  function removeListeners() {
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragDown);
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
    node.classList.remove("draggable");
  }
  __name(removeListeners, "removeListeners");
  if (active2) {
    activateListeners();
  }
  function onDragPointerDown(event) {
    if (event.button !== button || !event.isPrimary) {
      return;
    }
    if (!position.enabled) {
      return;
    }
    event.preventDefault();
    dragging = false;
    initialPosition = position.get();
    initialDragPoint = { x: event.clientX, y: event.clientY };
    node.addEventListener(...handlers.dragMove);
    node.addEventListener(...handlers.dragUp);
    node.setPointerCapture(event.pointerId);
  }
  __name(onDragPointerDown, "onDragPointerDown");
  function onDragPointerChange(event) {
    if ((event.buttons & 1) === 0) {
      onDragPointerUp(event);
      return;
    }
    if (event.button !== -1 || !event.isPrimary) {
      return;
    }
    event.preventDefault();
    if (!dragging && typeof storeDragging?.set === "function") {
      dragging = true;
      storeDragging.set(true);
    }
    const newLeft = initialPosition.left + (event.clientX - initialDragPoint.x);
    const newTop = initialPosition.top + (event.clientY - initialDragPoint.y);
    if (ease) {
      quickTo(newTop, newLeft);
    } else {
      s_POSITION_DATA.left = newLeft;
      s_POSITION_DATA.top = newTop;
      position.set(s_POSITION_DATA);
    }
  }
  __name(onDragPointerChange, "onDragPointerChange");
  function onDragPointerUp(event) {
    event.preventDefault();
    dragging = false;
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
  }
  __name(onDragPointerUp, "onDragPointerUp");
  return {
    update: (options) => {
      if (typeof options.active === "boolean") {
        active2 = options.active;
        if (active2) {
          activateListeners();
        } else {
          removeListeners();
        }
      }
      if (typeof options.button === "number") {
        button = options.button;
      }
      if (options.position !== void 0 && options.position !== position) {
        position = options.position;
        quickTo = position.animate.quickTo(["top", "left"], easeOptions);
      }
      if (typeof options.ease === "boolean") {
        ease = options.ease;
      }
      if (typeof options.easeOptions === "object") {
        easeOptions = options.easeOptions;
        quickTo.options(easeOptions);
      }
    },
    destroy: () => removeListeners()
  };
}
__name(draggable, "draggable");
class DraggableOptions {
  #ease = false;
  #easeOptions = { duration: 0.1, ease: cubicOut };
  #subscriptions = [];
  constructor({ ease, easeOptions } = {}) {
    Object.defineProperty(this, "ease", {
      get: () => {
        return this.#ease;
      },
      set: (newEase) => {
        if (typeof newEase !== "boolean") {
          throw new TypeError(`'ease' is not a boolean.`);
        }
        this.#ease = newEase;
        this.#updateSubscribers();
      },
      enumerable: true
    });
    Object.defineProperty(this, "easeOptions", {
      get: () => {
        return this.#easeOptions;
      },
      set: (newEaseOptions) => {
        if (newEaseOptions === null || typeof newEaseOptions !== "object") {
          throw new TypeError(`'easeOptions' is not an object.`);
        }
        if (newEaseOptions.duration !== void 0) {
          if (!Number.isFinite(newEaseOptions.duration)) {
            throw new TypeError(`'easeOptions.duration' is not a finite number.`);
          }
          if (newEaseOptions.duration < 0) {
            throw new Error(`'easeOptions.duration' is less than 0.`);
          }
          this.#easeOptions.duration = newEaseOptions.duration;
        }
        if (newEaseOptions.ease !== void 0) {
          if (typeof newEaseOptions.ease !== "function" && typeof newEaseOptions.ease !== "string") {
            throw new TypeError(`'easeOptions.ease' is not a function or string.`);
          }
          this.#easeOptions.ease = newEaseOptions.ease;
        }
        this.#updateSubscribers();
      },
      enumerable: true
    });
    if (ease !== void 0) {
      this.ease = ease;
    }
    if (easeOptions !== void 0) {
      this.easeOptions = easeOptions;
    }
  }
  get easeDuration() {
    return this.#easeOptions.duration;
  }
  get easeValue() {
    return this.#easeOptions.ease;
  }
  set easeDuration(duration) {
    if (!Number.isFinite(duration)) {
      throw new TypeError(`'duration' is not a finite number.`);
    }
    if (duration < 0) {
      throw new Error(`'duration' is less than 0.`);
    }
    this.#easeOptions.duration = duration;
    this.#updateSubscribers();
  }
  set easeValue(value) {
    if (typeof value !== "function" && typeof value !== "string") {
      throw new TypeError(`'value' is not a function or string.`);
    }
    this.#easeOptions.ease = value;
    this.#updateSubscribers();
  }
  reset() {
    this.#ease = false;
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  resetEase() {
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index = this.#subscriptions.findIndex((sub) => sub === handler);
      if (index >= 0) {
        this.#subscriptions.splice(index, 1);
      }
    };
  }
  #updateSubscribers() {
    const subscriptions = this.#subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](this);
      }
    }
  }
}
__name(DraggableOptions, "DraggableOptions");
draggable.options = (options) => new DraggableOptions(options);
const s_POSITION_DATA = { left: 0, top: 0 };
function localize(stringId, data) {
  const result = typeof data !== "object" ? game.i18n.localize(stringId) : game.i18n.format(stringId, data);
  return result !== void 0 ? result : "";
}
__name(localize, "localize");
function create_fragment$T(ctx) {
  let a;
  let html_tag;
  let t;
  let a_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      html_tag = new HtmlTag(false);
      t = text(ctx[2]);
      html_tag.a = t;
      attr(a, "class", a_class_value = "header-button " + ctx[0].class);
      attr(a, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      html_tag.m(ctx[1], a);
      append(a, t);
      if (!mounted) {
        dispose = [
          listen(a, "click", stop_propagation(prevent_default(ctx[4])), true),
          listen(a, "pointerdown", stop_propagation(prevent_default(pointerdown_handler)), true),
          listen(a, "mousedown", stop_propagation(prevent_default(mousedown_handler)), true),
          listen(a, "dblclick", stop_propagation(prevent_default(dblclick_handler)), true),
          action_destroyer(applyStyles_action = applyStyles.call(null, a, ctx[3]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        html_tag.p(ctx2[1]);
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (dirty & 1 && a_class_value !== (a_class_value = "header-button " + ctx2[0].class)) {
        attr(a, "class", a_class_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & 8)
        applyStyles_action.update.call(null, ctx2[3]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$T, "create_fragment$T");
const s_REGEX_HTML$1 = /^\s*<.*>$/;
const pointerdown_handler = /* @__PURE__ */ __name(() => null, "pointerdown_handler");
const mousedown_handler = /* @__PURE__ */ __name(() => null, "mousedown_handler");
const dblclick_handler = /* @__PURE__ */ __name(() => null, "dblclick_handler");
function instance$T($$self, $$props, $$invalidate) {
  let { button = void 0 } = $$props;
  let icon, label, title, styles2;
  function onClick(event) {
    const invoke = button.callback ?? button.onclick;
    if (typeof invoke === "function") {
      invoke.call(button, event);
      $$invalidate(0, button);
    }
  }
  __name(onClick, "onClick");
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 33) {
      if (button) {
        $$invalidate(5, title = typeof button.title === "string" ? localize(button.title) : "");
        $$invalidate(1, icon = typeof button.icon !== "string" ? void 0 : s_REGEX_HTML$1.test(button.icon) ? button.icon : `<i class="${button.icon}" title="${title}"></i>`);
        $$invalidate(2, label = typeof button.label === "string" ? localize(button.label) : "");
        $$invalidate(3, styles2 = typeof button.styles === "object" ? button.styles : void 0);
      }
    }
  };
  return [button, icon, label, styles2, onClick, title];
}
__name(instance$T, "instance$T");
class TJSHeaderButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$T, safe_not_equal, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(button) {
    this.$$set({ button });
    flush();
  }
}
__name(TJSHeaderButton, "TJSHeaderButton");
const TJSApplicationHeader_svelte_svelte_type_style_lang = "";
function get_each_context$s(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
__name(get_each_context$s, "get_each_context$s");
function create_each_block$s(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[20].props];
  var switch_value = ctx[20].class;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[20].props)]) : {};
      if (switch_value !== (switch_value = ctx2[20].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_each_block$s, "create_each_block$s");
function create_key_block(ctx) {
  let header;
  let h4;
  let t0_value = localize(ctx[5]) + "";
  let t0;
  let t1;
  let draggable_action;
  let minimizable_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$s(get_each_context$s(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  return {
    c() {
      header = element("header");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h4, "class", "window-title svelte-3umz0z");
      set_style(h4, "display", ctx[2]);
      attr(header, "class", "window-header flexrow");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      append(header, h4);
      append(h4, t0);
      append(header, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(draggable_action = ctx[0].call(null, header, ctx[1])),
          action_destroyer(minimizable_action = ctx[12].call(null, header, ctx[4]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 32) && t0_value !== (t0_value = localize(ctx2[5]) + ""))
        set_data(t0, t0_value);
      if (dirty & 4) {
        set_style(h4, "display", ctx2[2]);
      }
      if (dirty & 8) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$s(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$s(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(header, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & 2)
        draggable_action.update.call(null, ctx2[1]);
      if (minimizable_action && is_function(minimizable_action.update) && dirty & 16)
        minimizable_action.update.call(null, ctx2[4]);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_key_block, "create_key_block");
function create_fragment$S(ctx) {
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
__name(create_fragment$S, "create_fragment$S");
function instance$S($$self, $$props, $$invalidate) {
  let $storeHeaderButtons;
  let $storeMinimized;
  let $storeHeaderNoTitleMinimized;
  let $storeDraggable;
  let $storeMinimizable;
  let $storeTitle;
  let { draggable: draggable$1 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  const application = getContext("external").application;
  const storeTitle = application.reactive.storeAppOptions.title;
  component_subscribe($$self, storeTitle, (value) => $$invalidate(5, $storeTitle = value));
  const storeDraggable = application.reactive.storeAppOptions.draggable;
  component_subscribe($$self, storeDraggable, (value) => $$invalidate(17, $storeDraggable = value));
  const storeDragging = application.reactive.storeUIState.dragging;
  const storeHeaderButtons = application.reactive.storeUIState.headerButtons;
  component_subscribe($$self, storeHeaderButtons, (value) => $$invalidate(14, $storeHeaderButtons = value));
  const storeHeaderNoTitleMinimized = application.reactive.storeAppOptions.headerNoTitleMinimized;
  component_subscribe($$self, storeHeaderNoTitleMinimized, (value) => $$invalidate(16, $storeHeaderNoTitleMinimized = value));
  const storeMinimizable = application.reactive.storeAppOptions.minimizable;
  component_subscribe($$self, storeMinimizable, (value) => $$invalidate(4, $storeMinimizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(15, $storeMinimized = value));
  let dragOptions;
  let displayHeaderTitle;
  let buttons;
  function minimizable(node, booleanStore) {
    const callback = application._onToggleMinimize.bind(application);
    function activateListeners() {
      node.addEventListener("dblclick", callback);
    }
    __name(activateListeners, "activateListeners");
    function removeListeners() {
      node.removeEventListener("dblclick", callback);
    }
    __name(removeListeners, "removeListeners");
    if (booleanStore) {
      activateListeners();
    }
    return {
      update: (booleanStore2) => {
        if (booleanStore2) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  __name(minimizable, "minimizable");
  $$self.$$set = ($$props2) => {
    if ("draggable" in $$props2)
      $$invalidate(0, draggable$1 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(13, draggableOptions = $$props2.draggableOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(0, draggable$1 = typeof draggable$1 === "function" ? draggable$1 : draggable);
    }
    if ($$self.$$.dirty & 139264) {
      $$invalidate(1, dragOptions = Object.assign(
        {},
        {
          ease: true,
          easeOptions: { duration: 0.1, ease: cubicOut }
        },
        typeof draggableOptions === "object" ? draggableOptions : {},
        {
          position: application.position,
          active: $storeDraggable,
          storeDragging
        }
      ));
    }
    if ($$self.$$.dirty & 98304) {
      $$invalidate(2, displayHeaderTitle = $storeHeaderNoTitleMinimized && $storeMinimized ? "none" : null);
    }
    if ($$self.$$.dirty & 16384) {
      {
        $$invalidate(3, buttons = $storeHeaderButtons.reduce(
          (array, button) => {
            array.push(isSvelteComponent(button) ? { class: button, props: {} } : {
              class: TJSHeaderButton,
              props: { button }
            });
            return array;
          },
          []
        ));
      }
    }
  };
  return [
    draggable$1,
    dragOptions,
    displayHeaderTitle,
    buttons,
    $storeMinimizable,
    $storeTitle,
    storeTitle,
    storeDraggable,
    storeHeaderButtons,
    storeHeaderNoTitleMinimized,
    storeMinimizable,
    storeMinimized,
    minimizable,
    draggableOptions,
    $storeHeaderButtons,
    $storeMinimized,
    $storeHeaderNoTitleMinimized,
    $storeDraggable
  ];
}
__name(instance$S, "instance$S");
class TJSApplicationHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$S, safe_not_equal, { draggable: 0, draggableOptions: 13 });
  }
}
__name(TJSApplicationHeader, "TJSApplicationHeader");
function create_fragment$R(ctx) {
  let div;
  let resizable_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-arrows-alt-h"></i>`;
      attr(div, "class", "window-resizable-handle");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[10](div);
      if (!mounted) {
        dispose = action_destroyer(resizable_action = ctx[6].call(null, div, {
          active: ctx[1],
          storeResizing: ctx[5]
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (resizable_action && is_function(resizable_action.update) && dirty & 2)
        resizable_action.update.call(null, {
          active: ctx2[1],
          storeResizing: ctx2[5]
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$R, "create_fragment$R");
function instance$R($$self, $$props, $$invalidate) {
  let $storeElementRoot;
  let $storeMinimized;
  let $storeResizable;
  let { isResizable = false } = $$props;
  const application = getContext("external").application;
  const storeElementRoot = getContext("storeElementRoot");
  component_subscribe($$self, storeElementRoot, (value) => $$invalidate(8, $storeElementRoot = value));
  const storeResizable = application.reactive.storeAppOptions.resizable;
  component_subscribe($$self, storeResizable, (value) => $$invalidate(1, $storeResizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(9, $storeMinimized = value));
  const storeResizing = application.reactive.storeUIState.resizing;
  let elementResize;
  function resizable(node, { active: active2 = true, storeResizing: storeResizing2 = void 0 } = {}) {
    let position = null;
    let initialPosition = {};
    let resizing = false;
    const handlers = {
      resizeDown: ["pointerdown", (e) => onResizePointerDown(e), false],
      resizeMove: ["pointermove", (e) => onResizePointerMove(e), false],
      resizeUp: ["pointerup", (e) => onResizePointerUp(e), false]
    };
    function activateListeners() {
      node.addEventListener(...handlers.resizeDown);
      $$invalidate(7, isResizable = true);
      node.style.display = "block";
    }
    __name(activateListeners, "activateListeners");
    function removeListeners() {
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      node.removeEventListener(...handlers.resizeDown);
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      node.style.display = "none";
      $$invalidate(7, isResizable = false);
    }
    __name(removeListeners, "removeListeners");
    if (active2) {
      activateListeners();
    } else {
      node.style.display = "none";
    }
    function onResizePointerDown(event) {
      event.preventDefault();
      resizing = false;
      position = application.position.get();
      if (position.height === "auto") {
        position.height = $storeElementRoot.clientHeight;
      }
      if (position.width === "auto") {
        position.width = $storeElementRoot.clientWidth;
      }
      initialPosition = { x: event.clientX, y: event.clientY };
      node.addEventListener(...handlers.resizeMove);
      node.addEventListener(...handlers.resizeUp);
      node.setPointerCapture(event.pointerId);
    }
    __name(onResizePointerDown, "onResizePointerDown");
    function onResizePointerMove(event) {
      event.preventDefault();
      if (!resizing && typeof storeResizing2?.set === "function") {
        resizing = true;
        storeResizing2.set(true);
      }
      application.position.set({
        width: position.width + (event.clientX - initialPosition.x),
        height: position.height + (event.clientY - initialPosition.y)
      });
    }
    __name(onResizePointerMove, "onResizePointerMove");
    function onResizePointerUp(event) {
      resizing = false;
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      event.preventDefault();
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      application._onResize(event);
    }
    __name(onResizePointerUp, "onResizePointerUp");
    return {
      update: ({ active: active3 }) => {
        if (active3) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  __name(resizable, "resizable");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementResize = $$value;
      $$invalidate(0, elementResize), $$invalidate(7, isResizable), $$invalidate(9, $storeMinimized), $$invalidate(8, $storeElementRoot);
    });
  }
  __name(div_binding, "div_binding");
  $$self.$$set = ($$props2) => {
    if ("isResizable" in $$props2)
      $$invalidate(7, isResizable = $$props2.isResizable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 897) {
      if (elementResize) {
        $$invalidate(0, elementResize.style.display = isResizable && !$storeMinimized ? "block" : "none", elementResize);
        const elementRoot = $storeElementRoot;
        if (elementRoot) {
          elementRoot.classList[isResizable ? "add" : "remove"]("resizable");
        }
      }
    }
  };
  return [
    elementResize,
    $storeResizable,
    storeElementRoot,
    storeResizable,
    storeMinimized,
    storeResizing,
    resizable,
    isResizable,
    $storeElementRoot,
    $storeMinimized,
    div_binding
  ];
}
__name(instance$R, "instance$R");
class ResizableHandle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$R, safe_not_equal, { isResizable: 7 });
  }
}
__name(ResizableHandle, "ResizableHandle");
const ApplicationShell_svelte_svelte_type_style_lang = "";
function create_else_block$m(ctx) {
  let current;
  const default_slot_template = ctx[27].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[26], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(default_slot_template, ctx2[26], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
__name(create_else_block$m, "create_else_block$m");
function create_if_block$H(ctx) {
  let tjscontainer;
  let current;
  tjscontainer = new TJSContainer({
    props: { children: ctx[14] }
  });
  return {
    c() {
      create_component(tjscontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjscontainer, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tjscontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjscontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjscontainer, detaching);
    }
  };
}
__name(create_if_block$H, "create_if_block$H");
function create_fragment$Q(ctx) {
  let div;
  let tjsapplicationheader;
  let t0;
  let section;
  let current_block_type_index;
  let if_block;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader({
    props: {
      draggable: ctx[6],
      draggableOptions: ctx[7]
    }
  });
  const if_block_creators = [create_if_block$H, create_else_block$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (Array.isArray(ctx2[14]))
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  resizablehandle = new ResizableHandle({});
  return {
    c() {
      div = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section = element("section");
      if_block.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      attr(section, "class", "window-content svelte-are4no");
      attr(div, "id", div_id_value = ctx[10].id);
      attr(div, "class", div_class_value = "app window-app " + ctx[10].options.classes.join(" ") + " svelte-are4no");
      attr(div, "data-appid", div_data_appid_value = ctx[10].appId);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tjsapplicationheader, div, null);
      append(div, t0);
      append(div, section);
      if_blocks[current_block_type_index].m(section, null);
      ctx[28](section);
      append(div, t1);
      mount_component(resizablehandle, div, null);
      ctx[29](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(applyStyles_action = applyStyles.call(null, section, ctx[9])),
          action_destroyer(ctx[12].call(null, section, ctx[15])),
          listen(div, "pointerdown", ctx[13], true),
          action_destroyer(applyStyles_action_1 = applyStyles.call(null, div, ctx[8])),
          action_destroyer(ctx[11].call(null, div, ctx[16]))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const tjsapplicationheader_changes = {};
      if (dirty & 64)
        tjsapplicationheader_changes.draggable = ctx[6];
      if (dirty & 128)
        tjsapplicationheader_changes.draggableOptions = ctx[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if_block.p(ctx, dirty);
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & 512)
        applyStyles_action.update.call(null, ctx[9]);
      if (!current || dirty & 1024 && div_id_value !== (div_id_value = ctx[10].id)) {
        attr(div, "id", div_id_value);
      }
      if (!current || dirty & 1024 && div_class_value !== (div_class_value = "app window-app " + ctx[10].options.classes.join(" ") + " svelte-are4no")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & 1024 && div_data_appid_value !== (div_data_appid_value = ctx[10].appId)) {
        attr(div, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty & 256)
        applyStyles_action_1.update.call(null, ctx[8]);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(if_block);
      transition_in(resizablehandle.$$.fragment, local);
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, ctx[2], ctx[4]);
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(if_block);
      transition_out(resizablehandle.$$.fragment, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, ctx[3], ctx[5]);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsapplicationheader);
      if_blocks[current_block_type_index].d();
      ctx[28](null);
      destroy_component(resizablehandle);
      ctx[29](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$Q, "create_fragment$Q");
function instance$Q($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { draggable: draggable2 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  let { children: children2 = void 0 } = $$props;
  let { stylesApp = void 0 } = $$props;
  let { stylesContent = void 0 } = $$props;
  let { appOffsetHeight = false } = $$props;
  let { appOffsetWidth = false } = $$props;
  const appResizeObserver = !!appOffsetHeight || !!appOffsetWidth ? resizeObserver : () => null;
  let { contentOffsetHeight = false } = $$props;
  let { contentOffsetWidth = false } = $$props;
  const contentResizeObserver = !!contentOffsetHeight || !!contentOffsetWidth ? resizeObserver : () => null;
  const bringToTop = /* @__PURE__ */ __name((event) => {
    if (typeof application.options.popOut === "boolean" && application.options.popOut) {
      if (application !== ui?.activeWindow) {
        application.bringToTop.call(application);
      }
      if (document.activeElement !== document.body && event.target !== document.activeElement) {
        if (document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
        }
        document.body.focus();
      }
    }
  }, "bringToTop");
  if (!getContext("storeElementContent")) {
    setContext("storeElementContent", writable(elementContent));
  }
  if (!getContext("storeElementRoot")) {
    setContext("storeElementRoot", writable(elementRoot));
  }
  const context = getContext("external");
  const application = context.application;
  const allChildren = Array.isArray(children2) ? children2 : typeof context === "object" ? context.children : void 0;
  let { transition = void 0 } = $$props;
  let { inTransition = s_DEFAULT_TRANSITION } = $$props;
  let { outTransition = s_DEFAULT_TRANSITION } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let { outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS } = $$props;
  let oldTransition = void 0;
  let oldTransitionOptions = void 0;
  function resizeObservedContent(offsetWidth, offsetHeight) {
    $$invalidate(20, contentOffsetWidth = offsetWidth);
    $$invalidate(19, contentOffsetHeight = offsetHeight);
  }
  __name(resizeObservedContent, "resizeObservedContent");
  function resizeObservedApp(offsetWidth, offsetHeight, contentWidth, contentHeight) {
    application.position.stores.resizeObserved.update((object) => {
      object.contentWidth = contentWidth;
      object.contentHeight = contentHeight;
      object.offsetWidth = offsetWidth;
      object.offsetHeight = offsetHeight;
      return object;
    });
    $$invalidate(17, appOffsetHeight = offsetHeight);
    $$invalidate(18, appOffsetWidth = offsetWidth);
  }
  __name(resizeObservedApp, "resizeObservedApp");
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  __name(section_binding, "section_binding");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  __name(div_binding, "div_binding");
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(0, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("draggable" in $$props2)
      $$invalidate(6, draggable2 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(7, draggableOptions = $$props2.draggableOptions);
    if ("children" in $$props2)
      $$invalidate(21, children2 = $$props2.children);
    if ("stylesApp" in $$props2)
      $$invalidate(8, stylesApp = $$props2.stylesApp);
    if ("stylesContent" in $$props2)
      $$invalidate(9, stylesContent = $$props2.stylesContent);
    if ("appOffsetHeight" in $$props2)
      $$invalidate(17, appOffsetHeight = $$props2.appOffsetHeight);
    if ("appOffsetWidth" in $$props2)
      $$invalidate(18, appOffsetWidth = $$props2.appOffsetWidth);
    if ("contentOffsetHeight" in $$props2)
      $$invalidate(19, contentOffsetHeight = $$props2.contentOffsetHeight);
    if ("contentOffsetWidth" in $$props2)
      $$invalidate(20, contentOffsetWidth = $$props2.contentOffsetWidth);
    if ("transition" in $$props2)
      $$invalidate(22, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(2, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(3, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(23, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(4, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(5, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(26, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (elementContent !== void 0 && elementContent !== null) {
        getContext("storeElementContent").set(elementContent);
      }
    }
    if ($$self.$$.dirty & 2) {
      if (elementRoot !== void 0 && elementRoot !== null) {
        getContext("storeElementRoot").set(elementRoot);
      }
    }
    if ($$self.$$.dirty & 20971520) {
      if (oldTransition !== transition) {
        const newTransition = s_DEFAULT_TRANSITION !== transition && typeof transition === "function" ? transition : s_DEFAULT_TRANSITION;
        $$invalidate(2, inTransition = newTransition);
        $$invalidate(3, outTransition = newTransition);
        $$invalidate(24, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty & 41943040) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== s_DEFAULT_TRANSITION_OPTIONS && typeof transitionOptions === "object" ? transitionOptions : s_DEFAULT_TRANSITION_OPTIONS;
        $$invalidate(4, inTransitionOptions = newOptions);
        $$invalidate(5, outTransitionOptions = newOptions);
        $$invalidate(25, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty & 4) {
      if (typeof inTransition !== "function") {
        $$invalidate(2, inTransition = s_DEFAULT_TRANSITION);
      }
    }
    if ($$self.$$.dirty & 1032) {
      {
        if (typeof outTransition !== "function") {
          $$invalidate(3, outTransition = s_DEFAULT_TRANSITION);
        }
        if (application && typeof application?.options?.defaultCloseAnimation === "boolean") {
          $$invalidate(10, application.options.defaultCloseAnimation = outTransition === s_DEFAULT_TRANSITION, application);
        }
      }
    }
    if ($$self.$$.dirty & 16) {
      if (typeof inTransitionOptions !== "object") {
        $$invalidate(4, inTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
    if ($$self.$$.dirty & 32) {
      if (typeof outTransitionOptions !== "object") {
        $$invalidate(5, outTransitionOptions = s_DEFAULT_TRANSITION_OPTIONS);
      }
    }
  };
  return [
    elementContent,
    elementRoot,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    draggable2,
    draggableOptions,
    stylesApp,
    stylesContent,
    application,
    appResizeObserver,
    contentResizeObserver,
    bringToTop,
    allChildren,
    resizeObservedContent,
    resizeObservedApp,
    appOffsetHeight,
    appOffsetWidth,
    contentOffsetHeight,
    contentOffsetWidth,
    children2,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $$scope,
    slots,
    section_binding,
    div_binding
  ];
}
__name(instance$Q, "instance$Q");
class ApplicationShell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
      elementContent: 0,
      elementRoot: 1,
      draggable: 6,
      draggableOptions: 7,
      children: 21,
      stylesApp: 8,
      stylesContent: 9,
      appOffsetHeight: 17,
      appOffsetWidth: 18,
      contentOffsetHeight: 19,
      contentOffsetWidth: 20,
      transition: 22,
      inTransition: 2,
      outTransition: 3,
      transitionOptions: 23,
      inTransitionOptions: 4,
      outTransitionOptions: 5
    });
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(draggable2) {
    this.$$set({ draggable: draggable2 });
    flush();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(draggableOptions) {
    this.$$set({ draggableOptions });
    flush();
  }
  get children() {
    return this.$$.ctx[21];
  }
  set children(children2) {
    this.$$set({ children: children2 });
    flush();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(stylesApp) {
    this.$$set({ stylesApp });
    flush();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(stylesContent) {
    this.$$set({ stylesContent });
    flush();
  }
  get appOffsetHeight() {
    return this.$$.ctx[17];
  }
  set appOffsetHeight(appOffsetHeight) {
    this.$$set({ appOffsetHeight });
    flush();
  }
  get appOffsetWidth() {
    return this.$$.ctx[18];
  }
  set appOffsetWidth(appOffsetWidth) {
    this.$$set({ appOffsetWidth });
    flush();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[19];
  }
  set contentOffsetHeight(contentOffsetHeight) {
    this.$$set({ contentOffsetHeight });
    flush();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[20];
  }
  set contentOffsetWidth(contentOffsetWidth) {
    this.$$set({ contentOffsetWidth });
    flush();
  }
  get transition() {
    return this.$$.ctx[22];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(inTransition) {
    this.$$set({ inTransition });
    flush();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(outTransition) {
    this.$$set({ outTransition });
    flush();
  }
  get transitionOptions() {
    return this.$$.ctx[23];
  }
  set transitionOptions(transitionOptions) {
    this.$$set({ transitionOptions });
    flush();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(inTransitionOptions) {
    this.$$set({ inTransitionOptions });
    flush();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(outTransitionOptions) {
    this.$$set({ outTransitionOptions });
    flush();
  }
}
__name(ApplicationShell, "ApplicationShell");
const TJSApplicationShell_svelte_svelte_type_style_lang = "";
const DialogContent_svelte_svelte_type_style_lang = "";
function get_each_context$r(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
__name(get_each_context$r, "get_each_context$r");
function create_if_block_3$k(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[5]];
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    ctx[12](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 32 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[5])]) : {};
      if (switch_value !== (switch_value = ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          ctx2[12](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[12](null);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_if_block_3$k, "create_if_block_3$k");
function create_if_block_2$q(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[2], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        html_tag.p(ctx2[2]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
__name(create_if_block_2$q, "create_if_block_2$q");
function create_if_block$G(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[1];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[15].id, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$r(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$r(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "dialog-buttons svelte-14xg9ru");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 74) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$r, null, get_each_context$r);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$G, "create_if_block$G");
function create_if_block_1$u(ctx) {
  let html_tag;
  let raw_value = ctx[15].icon + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && raw_value !== (raw_value = ctx2[15].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
__name(create_if_block_1$u, "create_if_block_1$u");
function create_each_block$r(key_1, ctx) {
  let button;
  let span;
  let t0_value = ctx[15].label + "";
  let t0;
  let span_title_value;
  let t1;
  let button_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = ctx[15].icon && create_if_block_1$u(ctx);
  function click_handler() {
    return ctx[13](ctx[15]);
  }
  __name(click_handler, "click_handler");
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      span = element("span");
      if (if_block)
        if_block.c();
      t0 = text(t0_value);
      t1 = space();
      attr(span, "title", span_title_value = ctx[15].title);
      attr(button, "class", button_class_value = "dialog-button " + ctx[15].id);
      toggle_class(button, "default", ctx[15].id === ctx[3]);
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (if_block)
        if_block.m(span, null);
      append(span, t0);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler),
          action_destroyer(applyStyles_action = applyStyles.call(null, button, ctx[15].styles))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[15].icon) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$u(ctx);
          if_block.c();
          if_block.m(span, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2 && t0_value !== (t0_value = ctx[15].label + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && span_title_value !== (span_title_value = ctx[15].title)) {
        attr(span, "title", span_title_value);
      }
      if (dirty & 2 && button_class_value !== (button_class_value = "dialog-button " + ctx[15].id)) {
        attr(button, "class", button_class_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & 2)
        applyStyles_action.update.call(null, ctx[15].styles);
      if (dirty & 10) {
        toggle_class(button, "default", ctx[15].id === ctx[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$r, "create_each_block$r");
function create_fragment$P(ctx) {
  let t0;
  let div;
  let current_block_type_index;
  let if_block0;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_2$q, create_if_block_3$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[2] === "string")
      return 0;
    if (ctx2[4])
      return 1;
    return -1;
  }
  __name(select_block_type, "select_block_type");
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[1].length && create_if_block$G(ctx);
  return {
    c() {
      t0 = space();
      div = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div, "class", "dialog-content");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(document.body, "keydown", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[1].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$G(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$P, "create_fragment$P");
const s_REGEX_HTML = /^\s*<.*>$/;
function instance$P($$self, $$props, $$invalidate) {
  let { data = {} } = $$props;
  let { autoClose = true } = $$props;
  let { preventDefault: preventDefault2 = false } = $$props;
  let { stopPropagation = false } = $$props;
  let { dialogInstance = void 0 } = $$props;
  let buttons;
  let content = void 0;
  let dialogComponent;
  let dialogProps = {};
  let application = getContext("external").application;
  let currentButtonId = data.default;
  async function onClick(button) {
    try {
      let result = null;
      const invoke = button.callback ?? button.onclick;
      switch (typeof invoke) {
        case "function":
          result = await invoke(
            application.options.jQuery ? application.element : application.element[0],
            dialogInstance
          );
          break;
        case "string":
          if (dialogInstance !== void 0 && typeof dialogInstance[invoke] === "function") {
            result = await dialogInstance[invoke](
              application.options.jQuery ? application.element : application.element[0],
              dialogInstance
            );
          }
          break;
      }
      if (autoClose) {
        setTimeout(() => application.close(), 0);
      }
      return result;
    } catch (err) {
      ui.notifications.error(err);
      throw new Error(err);
    }
  }
  __name(onClick, "onClick");
  function onKeydown(event) {
    if (event.key !== "Escape" && ui.activeWindow !== application) {
      return;
    }
    switch (event.key) {
      case "ArrowLeft": {
        event.preventDefault();
        event.stopPropagation();
        const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
        if (buttons.length && currentIndex > 0) {
          $$invalidate(3, currentButtonId = buttons[currentIndex - 1].id);
        }
        break;
      }
      case "ArrowRight": {
        event.preventDefault();
        event.stopPropagation();
        const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
        if (buttons.length && currentIndex < buttons.length - 1) {
          $$invalidate(3, currentButtonId = buttons[currentIndex + 1].id);
        }
        break;
      }
      case "Escape":
        event.preventDefault();
        event.stopPropagation();
        return application.close();
      case "Enter":
        event.preventDefault();
        event.stopPropagation();
        if (currentButtonId && isObject(data.buttons) && currentButtonId in data.buttons) {
          onClick(data.buttons[currentButtonId]);
        }
        break;
      default:
        if (preventDefault2) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
        break;
    }
  }
  __name(onKeydown, "onKeydown");
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialogInstance = $$value;
      $$invalidate(0, dialogInstance);
    });
  }
  __name(switch_instance_binding, "switch_instance_binding");
  const click_handler = /* @__PURE__ */ __name((button) => onClick(button), "click_handler");
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(8, data = $$props2.data);
    if ("autoClose" in $$props2)
      $$invalidate(9, autoClose = $$props2.autoClose);
    if ("preventDefault" in $$props2)
      $$invalidate(10, preventDefault2 = $$props2.preventDefault);
    if ("stopPropagation" in $$props2)
      $$invalidate(11, stopPropagation = $$props2.stopPropagation);
    if ("dialogInstance" in $$props2)
      $$invalidate(0, dialogInstance = $$props2.dialogInstance);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      {
        $$invalidate(1, buttons = !isObject(data.buttons) ? [] : Object.keys(data.buttons).reduce(
          (array, key) => {
            const b = data.buttons[key];
            const icon = typeof b.icon !== "string" ? void 0 : s_REGEX_HTML.test(b.icon) ? b.icon : `<i class="${b.icon}"></i>`;
            const label = typeof b.label === "string" ? `${icon !== void 0 ? " " : ""}${localize(b.label)}` : "";
            const title = typeof b.title === "string" ? localize(b.title) : void 0;
            const condition = typeof b.condition === "function" ? b.condition.call(b) : b.condition ?? true;
            if (condition) {
              array.push({ ...b, id: key, icon, label, title });
            }
            return array;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & 10) {
      if (!buttons.find((button) => button.id === currentButtonId)) {
        $$invalidate(3, currentButtonId = void 0);
      }
    }
    if ($$self.$$.dirty & 260) {
      if (content !== data.content) {
        $$invalidate(2, content = data.content);
        try {
          if (isSvelteComponent(content)) {
            $$invalidate(4, dialogComponent = content);
            $$invalidate(5, dialogProps = {});
          } else if (typeof content === "object") {
            const svelteConfig = parseSvelteConfig(content, application);
            $$invalidate(4, dialogComponent = svelteConfig.class);
            $$invalidate(5, dialogProps = svelteConfig.props ?? {});
            const children2 = svelteConfig?.context?.get("external")?.children;
            if (Array.isArray(children2)) {
              $$invalidate(5, dialogProps.children = children2, dialogProps);
            }
          } else {
            $$invalidate(4, dialogComponent = void 0);
            $$invalidate(5, dialogProps = {});
          }
        } catch (err) {
          $$invalidate(4, dialogComponent = void 0);
          $$invalidate(5, dialogProps = {});
          $$invalidate(2, content = err.message);
          console.error(err);
        }
      }
    }
  };
  return [
    dialogInstance,
    buttons,
    content,
    currentButtonId,
    dialogComponent,
    dialogProps,
    onClick,
    onKeydown,
    data,
    autoClose,
    preventDefault2,
    stopPropagation,
    switch_instance_binding,
    click_handler
  ];
}
__name(instance$P, "instance$P");
class DialogContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$P, safe_not_equal, {
      data: 8,
      autoClose: 9,
      preventDefault: 10,
      stopPropagation: 11,
      dialogInstance: 0
    });
  }
}
__name(DialogContent, "DialogContent");
function create_else_block$l(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [ctx[6], { appOffsetHeight: true }];
  function applicationshell_elementRoot_binding_1(value) {
    ctx[16](value);
  }
  __name(applicationshell_elementRoot_binding_1, "applicationshell_elementRoot_binding_1");
  function applicationshell_elementContent_binding_1(value) {
    ctx[17](value);
  }
  __name(applicationshell_elementContent_binding_1, "applicationshell_elementContent_binding_1");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < applicationshell_spread_levels.length; i += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i]);
  }
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  if (ctx[0] !== void 0) {
    applicationshell_props.elementContent = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding_1));
  binding_callbacks.push(() => bind$1(applicationshell, "elementContent", applicationshell_elementContent_binding_1));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & 64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(ctx2[6]),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & 1049100) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & 1) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = ctx2[0];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_else_block$l, "create_else_block$l");
function create_if_block$F(ctx) {
  let tjsglasspane;
  let current;
  const tjsglasspane_spread_levels = [
    {
      id: `${ctx[4].id}-glasspane`
    },
    { preventDefault: false },
    { stopPropagation: false },
    ctx[7],
    { zIndex: ctx[8] }
  ];
  let tjsglasspane_props = {
    $$slots: { default: [create_default_slot$m] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tjsglasspane_spread_levels.length; i += 1) {
    tjsglasspane_props = assign(tjsglasspane_props, tjsglasspane_spread_levels[i]);
  }
  tjsglasspane = new TJSGlassPane({ props: tjsglasspane_props });
  return {
    c() {
      create_component(tjsglasspane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjsglasspane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsglasspane_changes = dirty & 400 ? get_spread_update(tjsglasspane_spread_levels, [
        dirty & 16 && {
          id: `${ctx2[4].id}-glasspane`
        },
        tjsglasspane_spread_levels[1],
        tjsglasspane_spread_levels[2],
        dirty & 128 && get_spread_object(ctx2[7]),
        dirty & 256 && { zIndex: ctx2[8] }
      ]) : {};
      if (dirty & 1049167) {
        tjsglasspane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjsglasspane.$set(tjsglasspane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsglasspane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsglasspane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsglasspane, detaching);
    }
  };
}
__name(create_if_block$F, "create_if_block$F");
function create_default_slot_2(ctx) {
  let dialogcontent;
  let updating_autoClose;
  let updating_dialogInstance;
  let current;
  function dialogcontent_autoClose_binding_1(value) {
    ctx[14](value);
  }
  __name(dialogcontent_autoClose_binding_1, "dialogcontent_autoClose_binding_1");
  function dialogcontent_dialogInstance_binding_1(value) {
    ctx[15](value);
  }
  __name(dialogcontent_dialogInstance_binding_1, "dialogcontent_dialogInstance_binding_1");
  let dialogcontent_props = { data: ctx[3] };
  if (ctx[9] !== void 0) {
    dialogcontent_props.autoClose = ctx[9];
  }
  if (ctx[2] !== void 0) {
    dialogcontent_props.dialogInstance = ctx[2];
  }
  dialogcontent = new DialogContent({ props: dialogcontent_props });
  binding_callbacks.push(() => bind$1(dialogcontent, "autoClose", dialogcontent_autoClose_binding_1));
  binding_callbacks.push(() => bind$1(dialogcontent, "dialogInstance", dialogcontent_dialogInstance_binding_1));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & 8)
        dialogcontent_changes.data = ctx2[3];
      if (!updating_autoClose && dirty & 512) {
        updating_autoClose = true;
        dialogcontent_changes.autoClose = ctx2[9];
        add_flush_callback(() => updating_autoClose = false);
      }
      if (!updating_dialogInstance && dirty & 4) {
        updating_dialogInstance = true;
        dialogcontent_changes.dialogInstance = ctx2[2];
        add_flush_callback(() => updating_dialogInstance = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
__name(create_default_slot_2, "create_default_slot_2");
function create_default_slot_1$3(ctx) {
  let dialogcontent;
  let updating_autoClose;
  let updating_dialogInstance;
  let current;
  function dialogcontent_autoClose_binding(value) {
    ctx[10](value);
  }
  __name(dialogcontent_autoClose_binding, "dialogcontent_autoClose_binding");
  function dialogcontent_dialogInstance_binding(value) {
    ctx[11](value);
  }
  __name(dialogcontent_dialogInstance_binding, "dialogcontent_dialogInstance_binding");
  let dialogcontent_props = {
    stopPropagation: true,
    data: ctx[3]
  };
  if (ctx[9] !== void 0) {
    dialogcontent_props.autoClose = ctx[9];
  }
  if (ctx[2] !== void 0) {
    dialogcontent_props.dialogInstance = ctx[2];
  }
  dialogcontent = new DialogContent({ props: dialogcontent_props });
  binding_callbacks.push(() => bind$1(dialogcontent, "autoClose", dialogcontent_autoClose_binding));
  binding_callbacks.push(() => bind$1(dialogcontent, "dialogInstance", dialogcontent_dialogInstance_binding));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & 8)
        dialogcontent_changes.data = ctx2[3];
      if (!updating_autoClose && dirty & 512) {
        updating_autoClose = true;
        dialogcontent_changes.autoClose = ctx2[9];
        add_flush_callback(() => updating_autoClose = false);
      }
      if (!updating_dialogInstance && dirty & 4) {
        updating_dialogInstance = true;
        dialogcontent_changes.dialogInstance = ctx2[2];
        add_flush_callback(() => updating_dialogInstance = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
__name(create_default_slot_1$3, "create_default_slot_1$3");
function create_default_slot$m(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [ctx[6], { appOffsetHeight: true }];
  function applicationshell_elementRoot_binding(value) {
    ctx[12](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_elementContent_binding(value) {
    ctx[13](value);
  }
  __name(applicationshell_elementContent_binding, "applicationshell_elementContent_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_1$3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < applicationshell_spread_levels.length; i += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i]);
  }
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  if (ctx[0] !== void 0) {
    applicationshell_props.elementContent = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  binding_callbacks.push(() => bind$1(applicationshell, "elementContent", applicationshell_elementContent_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & 64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(ctx2[6]),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & 1049100) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & 1) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = ctx2[0];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_default_slot$m, "create_default_slot$m");
function create_fragment$O(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$F, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_fragment$O, "create_fragment$O");
const s_MODAL_BACKGROUND = "#50505080";
function instance$O($$self, $$props, $$invalidate) {
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { data = {} } = $$props;
  let { dialogComponent = void 0 } = $$props;
  const application = getContext("external").application;
  const s_MODAL_TRANSITION = fade;
  const s_MODAL_TRANSITION_OPTIONS = { duration: 200 };
  let modal = void 0;
  const appProps = {
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0,
    stylesApp: void 0,
    stylesContent: void 0
  };
  const modalProps = {
    background: void 0,
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0
  };
  let zIndex = void 0;
  let autoClose = true;
  if (modal === void 0) {
    modal = typeof data?.modal === "boolean" ? data.modal : false;
  }
  function dialogcontent_autoClose_binding(value) {
    autoClose = value;
    $$invalidate(9, autoClose), $$invalidate(3, data), $$invalidate(5, modal), $$invalidate(8, zIndex), $$invalidate(4, application);
  }
  __name(dialogcontent_autoClose_binding, "dialogcontent_autoClose_binding");
  function dialogcontent_dialogInstance_binding(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  __name(dialogcontent_dialogInstance_binding, "dialogcontent_dialogInstance_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  function applicationshell_elementContent_binding(value) {
    elementContent = value;
    $$invalidate(0, elementContent);
  }
  __name(applicationshell_elementContent_binding, "applicationshell_elementContent_binding");
  function dialogcontent_autoClose_binding_1(value) {
    autoClose = value;
    $$invalidate(9, autoClose), $$invalidate(3, data), $$invalidate(5, modal), $$invalidate(8, zIndex), $$invalidate(4, application);
  }
  __name(dialogcontent_autoClose_binding_1, "dialogcontent_autoClose_binding_1");
  function dialogcontent_dialogInstance_binding_1(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  __name(dialogcontent_dialogInstance_binding_1, "dialogcontent_dialogInstance_binding_1");
  function applicationshell_elementRoot_binding_1(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding_1, "applicationshell_elementRoot_binding_1");
  function applicationshell_elementContent_binding_1(value) {
    elementContent = value;
    $$invalidate(0, elementContent);
  }
  __name(applicationshell_elementContent_binding_1, "applicationshell_elementContent_binding_1");
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(0, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("dialogComponent" in $$props2)
      $$invalidate(2, dialogComponent = $$props2.dialogComponent);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 312) {
      if (typeof data === "object") {
        $$invalidate(9, autoClose = typeof data.autoClose === "boolean" ? data.autoClose : true);
        const newZIndex = Number.isInteger(data.zIndex) || data.zIndex === null ? data.zIndex : modal ? Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER - 1;
        if (zIndex !== newZIndex) {
          $$invalidate(8, zIndex = newZIndex);
        }
        const newDraggable = data.draggable ?? true;
        if (application.reactive.draggable !== newDraggable) {
          $$invalidate(4, application.reactive.draggable = newDraggable, application);
        }
        const newPopOut = data.popOut ?? true;
        if (application.reactive.popOut !== newPopOut) {
          $$invalidate(4, application.reactive.popOut = newPopOut, application);
        }
        const newResizable = data.resizable ?? false;
        if (application.reactive.resizable !== newResizable) {
          $$invalidate(4, application.reactive.resizable = newResizable, application);
        }
        const newTitle = data.title ?? "Dialog";
        if (newTitle !== application?.options?.title) {
          $$invalidate(4, application.reactive.title = newTitle, application);
        }
        if (application.position.zIndex !== zIndex) {
          $$invalidate(4, application.position.zIndex = zIndex, application);
        }
      }
    }
    if ($$self.$$.dirty & 72) {
      if (typeof data?.transition === "object") {
        const d = data.transition;
        if (d?.transition !== appProps.transition) {
          $$invalidate(6, appProps.transition = d.transition, appProps);
        }
        if (d?.inTransition !== appProps.inTransition) {
          $$invalidate(6, appProps.inTransition = d.inTransition, appProps);
        }
        if (d?.outTransition !== appProps.outTransition) {
          $$invalidate(6, appProps.outTransition = d.outTransition, appProps);
        }
        if (d?.transitionOptions !== appProps.transitionOptions) {
          $$invalidate(6, appProps.transitionOptions = d.transitionOptions, appProps);
        }
        if (d?.inTransitionOptions !== appProps.inTransitionOptions) {
          $$invalidate(6, appProps.inTransitionOptions = d.inTransitionOptions, appProps);
        }
        if (d?.outTransitionOptions !== appProps.outTransitionOptions) {
          $$invalidate(6, appProps.outTransitionOptions = d.outTransitionOptions, appProps);
        }
      }
    }
    if ($$self.$$.dirty & 136) {
      {
        const newModalBackground = typeof data?.modalOptions?.background === "string" ? data.modalOptions.background : s_MODAL_BACKGROUND;
        if (newModalBackground !== modalProps.background) {
          $$invalidate(7, modalProps.background = newModalBackground, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & 136) {
      if (typeof data?.modalOptions?.transition === "object") {
        const d = data.modalOptions.transition;
        if (d?.transition !== modalProps.transition) {
          $$invalidate(
            7,
            modalProps.transition = typeof d?.transition === "function" ? d.transition : s_MODAL_TRANSITION,
            modalProps
          );
        }
        if (d?.inTransition !== modalProps.inTransition) {
          $$invalidate(7, modalProps.inTransition = d.inTransition, modalProps);
        }
        if (d?.outTransition !== modalProps.outTransition) {
          $$invalidate(7, modalProps.outTransition = d.outTransition, modalProps);
        }
        if (d?.transitionOptions !== modalProps.transitionOptions) {
          $$invalidate(
            7,
            modalProps.transitionOptions = typeof d?.transitionOptions === "object" ? d.transitionOptions : s_MODAL_TRANSITION_OPTIONS,
            modalProps
          );
        }
        if (d?.inTransitionOptions !== modalProps.inTransitionOptions) {
          $$invalidate(7, modalProps.inTransitionOptions = d.inTransitionOptions, modalProps);
        }
        if (d?.outTransitionOptions !== modalProps.outTransitionOptions) {
          $$invalidate(7, modalProps.outTransitionOptions = d.outTransitionOptions, modalProps);
        }
      } else {
        const newModalTransition = typeof data?.modalOptions?.transition?.transition === "function" ? data.modalOptions.transition.transition : s_MODAL_TRANSITION;
        if (newModalTransition !== modalProps.transition) {
          $$invalidate(7, modalProps.transition = newModalTransition, modalProps);
        }
        const newModalTransitionOptions = typeof data?.modalOptions?.transitionOptions === "object" ? data.modalOptions.transitionOptions : s_MODAL_TRANSITION_OPTIONS;
        if (newModalTransitionOptions !== modalProps.transitionOptions) {
          $$invalidate(7, modalProps.transitionOptions = newModalTransitionOptions, modalProps);
        }
      }
    }
  };
  return [
    elementContent,
    elementRoot,
    dialogComponent,
    data,
    application,
    modal,
    appProps,
    modalProps,
    zIndex,
    autoClose,
    dialogcontent_autoClose_binding,
    dialogcontent_dialogInstance_binding,
    applicationshell_elementRoot_binding,
    applicationshell_elementContent_binding,
    dialogcontent_autoClose_binding_1,
    dialogcontent_dialogInstance_binding_1,
    applicationshell_elementRoot_binding_1,
    applicationshell_elementContent_binding_1
  ];
}
__name(instance$O, "instance$O");
class DialogShell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$O, safe_not_equal, {
      elementContent: 0,
      elementRoot: 1,
      data: 3,
      dialogComponent: 2
    });
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get data() {
    return this.$$.ctx[3];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get dialogComponent() {
    return this.$$.ctx[2];
  }
  set dialogComponent(dialogComponent) {
    this.$$set({ dialogComponent });
    flush();
  }
}
__name(DialogShell, "DialogShell");
class DialogData {
  #application;
  constructor(application) {
    this.#application = application;
  }
  get(accessor, defaultValue) {
    return safeAccess(this, accessor, defaultValue);
  }
  merge(data) {
    deepMerge(this, data);
    const component = this.#application.svelte.component(0);
    if (component?.data) {
      component.data = this;
    }
  }
  set(accessor, value) {
    const success = safeSet(this, accessor, value);
    if (success) {
      const component = this.#application.svelte.component(0);
      if (component?.data) {
        component.data = this;
      }
    }
    return success;
  }
}
__name(DialogData, "DialogData");
class TJSDialog extends SvelteApplication {
  #data;
  constructor(data, options = {}) {
    super(options);
    this.#data = new DialogData(this);
    this.data = data;
    Object.defineProperty(this.svelte, "dialogComponent", {
      get: () => this.svelte?.applicationShell?.dialogComponent
    });
  }
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      classes: ["dialog"],
      width: 400,
      height: "auto",
      jQuery: true,
      svelte: {
        class: DialogShell,
        intro: true,
        target: document.body,
        props: function() {
          return { data: this.#data };
        }
      }
    });
  }
  get data() {
    return this.#data;
  }
  set data(data) {
    const descriptors = Object.getOwnPropertyDescriptors(this.#data);
    for (const descriptor in descriptors) {
      if (descriptors[descriptor].configurable) {
        delete this.#data[descriptor];
      }
    }
    this.#data.merge(data);
  }
  activateListeners(html) {
    super.activateListeners(html);
    if (this.data.render instanceof Function) {
      const actualHTML = typeof this.options.template === "string" ? html : this.options.jQuery ? $(this.elementContent) : this.elementContent;
      this.data.render(this.options.jQuery ? actualHTML : actualHTML[0]);
    }
  }
  async close(options) {
    if (this.data.close instanceof Function) {
      this.data.close(this.options.jQuery ? this.element : this.element[0]);
    }
    return super.close(options);
  }
  static async confirm({
    title,
    content,
    yes,
    no,
    render,
    defaultYes = true,
    rejectClose = false,
    options = {},
    buttons = {},
    draggable: draggable2 = true,
    modal = false,
    modalOptions = {},
    popOut = true,
    resizable = false,
    transition = {},
    zIndex
  } = {}) {
    const mergedButtons = deepMerge({
      yes: {
        icon: '<i class="fas fa-check"></i>',
        label: game.i18n.localize("Yes")
      },
      no: {
        icon: '<i class="fas fa-times"></i>',
        label: game.i18n.localize("No")
      }
    }, buttons);
    return new Promise((resolve, reject) => {
      const dialog = new this({
        title,
        content,
        render,
        draggable: draggable2,
        modal,
        modalOptions,
        popOut,
        resizable,
        transition,
        zIndex,
        buttons: deepMerge(mergedButtons, {
          yes: {
            callback: (html) => {
              const result = yes ? yes(html) : true;
              resolve(result);
            }
          },
          no: {
            callback: (html) => {
              const result = no ? no(html) : false;
              resolve(result);
            }
          }
        }),
        default: defaultYes ? "yes" : "no",
        close: () => {
          if (rejectClose) {
            reject("The confirmation Dialog was closed without a choice being made.");
          } else {
            resolve(null);
          }
        }
      }, options);
      dialog.render(true);
    });
  }
  static async prompt({
    title,
    content,
    label,
    callback,
    render,
    rejectClose = false,
    options = {},
    draggable: draggable2 = true,
    icon = '<i class="fas fa-check"></i>',
    modal = false,
    modalOptions = {},
    popOut = true,
    resizable = false,
    transition = {},
    zIndex
  } = {}) {
    return new Promise((resolve, reject) => {
      const dialog = new this({
        title,
        content,
        render,
        draggable: draggable2,
        modal,
        modalOptions,
        popOut,
        resizable,
        transition,
        zIndex,
        buttons: {
          ok: {
            icon,
            label,
            callback: (html) => {
              const result = callback ? callback(html) : null;
              resolve(result);
            }
          }
        },
        default: "ok",
        close: () => {
          if (rejectClose) {
            reject(new Error("The Dialog prompt was closed without being accepted."));
          } else {
            resolve(null);
          }
        }
      }, options);
      dialog.render(true);
    });
  }
}
__name(TJSDialog, "TJSDialog");
Hooks.on("PopOut:loading", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = false;
  }
});
Hooks.on("PopOut:popin", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
Hooks.on("PopOut:close", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
const CustomDialog_svelte_svelte_type_style_lang = "";
function get_each_context$q(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
__name(get_each_context$q, "get_each_context$q");
function create_if_block_2$p(ctx) {
  let p;
  let i;
  let i_class_value;
  return {
    c() {
      p = element("p");
      i = element("i");
      attr(i, "class", i_class_value = null_to_empty(ctx[0]) + " svelte-iivrm9");
      attr(p, "class", "header-icon svelte-iivrm9");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, i);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && i_class_value !== (i_class_value = null_to_empty(ctx2[0]) + " svelte-iivrm9")) {
        attr(i, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_2$p, "create_if_block_2$p");
function create_if_block_1$t(ctx) {
  let p;
  let strong;
  let t;
  return {
    c() {
      p = element("p");
      strong = element("strong");
      t = text(ctx[1]);
      attr(p, "class", "header svelte-iivrm9");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, strong);
      append(strong, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_1$t, "create_if_block_1$t");
function create_else_block$k(ctx) {
  let p;
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = ctx[2];
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        p.innerHTML = ctx2[2];
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block$k, "create_else_block$k");
function create_if_block$E(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$q(get_each_context$q(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$q(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$q(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
__name(create_if_block$E, "create_if_block$E");
function create_each_block$q(ctx) {
  let p;
  let raw_value = ctx[3] + "";
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & 4 && raw_value !== (raw_value = ctx2[3] + ""))
        p.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_each_block$q, "create_each_block$q");
function create_fragment$N(ctx) {
  let div;
  let t0;
  let t1;
  let show_if;
  let if_block0 = ctx[0] && create_if_block_2$p(ctx);
  let if_block1 = ctx[1] && create_if_block_1$t(ctx);
  function select_block_type(ctx2, dirty) {
    if (dirty & 4)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[2]);
    if (show_if)
      return create_if_block$E;
    return create_else_block$k;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx, -1);
  let if_block2 = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      attr(div, "class", "svelte-iivrm9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if_block2.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$p(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$t(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
    }
  };
}
__name(create_fragment$N, "create_fragment$N");
function instance$N($$self, $$props, $$invalidate) {
  let { icon = "fas fa-exclamation-triangle" } = $$props;
  let { header = "Item Piles" } = $$props;
  let { content } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("header" in $$props2)
      $$invalidate(1, header = $$props2.header);
    if ("content" in $$props2)
      $$invalidate(2, content = $$props2.content);
  };
  return [icon, header, content];
}
__name(instance$N, "instance$N");
class CustomDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$N, safe_not_equal, { icon: 0, header: 1, content: 2 });
  }
}
__name(CustomDialog, "CustomDialog");
const ActorDropSelect_svelte_svelte_type_style_lang = "";
function get_each_context$p(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
__name(get_each_context$p, "get_each_context$p");
function create_else_block_2$2(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Trade.Prompt.DropActor")}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block_2$2, "create_else_block_2$2");
function create_if_block_1$s(ctx) {
  let div;
  let t;
  let if_block0 = ctx[0].img && create_if_block_4$c(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block_2$o;
    return create_else_block_1$8;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      attr(div, "class", "align-center-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if_block1.m(div, null);
    },
    p(ctx2, dirty) {
      if (ctx2[0].img) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$c(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
__name(create_if_block_1$s, "create_if_block_1$s");
function create_if_block_4$c(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[0].img))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1fiqefb");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 3 && !src_url_equal(img.src, img_src_value = ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
__name(create_if_block_4$c, "create_if_block_4$c");
function create_else_block_1$8(ctx) {
  let span;
  let t_value = ctx[0].name + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "svelte-1fiqefb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_else_block_1$8, "create_else_block_1$8");
function create_if_block_2$o(ctx) {
  let span;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block_3$j;
    return create_else_block$j;
  }
  __name(select_block_type_2, "select_block_type_2");
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "class", "svelte-1fiqefb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if_block.d();
    }
  };
}
__name(create_if_block_2$o, "create_if_block_2$o");
function create_else_block$j(ctx) {
  let a;
  let t_value = ctx[0].name + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "class", "item-piles-change-actor item-piles-highlight");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
      if (!mounted) {
        dispose = listen(a, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$j, "create_else_block$j");
function create_if_block_3$j(ctx) {
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ctx[1];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[13].id, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$p(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$p(key, child_ctx));
  }
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "class", "item-piles-change-actor-select svelte-1fiqefb");
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[10].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[10]),
          listen(select, "change", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$p, null, get_each_context$p);
      }
      if (dirty & 3) {
        select_option(select, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$j, "create_if_block_3$j");
function create_each_block$p(key_1, ctx) {
  let option;
  let t_value = ctx[13].name + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[13];
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t_value !== (t_value = ctx[13].name + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx[13])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block$p, "create_each_block$p");
function create_if_block$D(ctx) {
  let div;
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Trade.Prompt.PickToken") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-expand");
      attr(button, "type", "button");
      attr(div, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$D, "create_if_block$D");
function create_fragment$M(ctx) {
  let div1;
  let div0;
  let t;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block_1$s;
    return create_else_block_2$2;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[5] && create_if_block$D(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "form-group item-piles-actor-container align-center-row svelte-1fiqefb");
      toggle_class(div0, "item-piles-box-highlight", ctx[3] > 0);
      attr(div1, "class", "item-piles-bottom-divider");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(div0, "dragstart", preventDefault$2),
          listen(div0, "drop", ctx[7]),
          listen(div0, "dragover", preventDefault$2),
          listen(div0, "dragenter", ctx[8]),
          listen(div0, "dragleave", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (dirty & 8) {
        toggle_class(div0, "item-piles-box-highlight", ctx2[3] > 0);
      }
      if (ctx2[5])
        if_block1.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$M, "create_fragment$M");
function preventDefault$2(event) {
  event.preventDefault();
}
__name(preventDefault$2, "preventDefault$2");
function instance$M($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let { actors } = $$props;
  let changingActor = false;
  let multipleActors = actors.length > 1 && !game.user.isGM;
  let hasUnlinkedTokenOwnership = actors.filter((a) => !a.prototypeToken.actorLink).length > 0;
  function setActorFromSelectedToken() {
    if (canvas.tokens.controlled.length === 0)
      return;
    $$invalidate(0, actor = canvas.tokens.controlled[0].actor);
  }
  __name(setActorFromSelectedToken, "setActorFromSelectedToken");
  async function dropData(event) {
    $$invalidate(3, counter = 0);
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
    } catch (err) {
      return false;
    }
    if (data.type !== "Actor")
      return;
    $$invalidate(0, actor = await fromUuid(data.uuid));
  }
  __name(dropData, "dropData");
  let counter = 0;
  function dragEnter() {
    $$invalidate(3, counter++, counter);
  }
  __name(dragEnter, "dragEnter");
  function dragLeave() {
    $$invalidate(3, counter--, counter);
  }
  __name(dragLeave, "dragLeave");
  function select_change_handler() {
    actor = select_value(this);
    $$invalidate(0, actor);
    $$invalidate(1, actors);
  }
  __name(select_change_handler, "select_change_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(2, changingActor = false);
  }, "change_handler");
  const click_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(2, changingActor = true);
  }, "click_handler");
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
    if ("actors" in $$props2)
      $$invalidate(1, actors = $$props2.actors);
  };
  return [
    actor,
    actors,
    changingActor,
    counter,
    multipleActors,
    hasUnlinkedTokenOwnership,
    setActorFromSelectedToken,
    dropData,
    dragEnter,
    dragLeave,
    select_change_handler,
    change_handler,
    click_handler
  ];
}
__name(instance$M, "instance$M");
class ActorDropSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$M, safe_not_equal, { actor: 0, actors: 1 });
  }
}
__name(ActorDropSelect, "ActorDropSelect");
const tradeDialogPrompt_svelte_svelte_type_style_lang = "";
function get_each_context$o(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
__name(get_each_context$o, "get_each_context$o");
function create_each_block$o(key_1, ctx) {
  let option;
  let t_value = ctx[13].name + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[13];
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t_value !== (t_value = ctx[13].name + ""))
        set_data(t, t_value);
      if (dirty & 4 && option_value_value !== (option_value_value = ctx[13])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block$o, "create_each_block$o");
function create_else_block$i(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Trade.Prompt.PickActor")}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block$i, "create_else_block$i");
function create_if_block$C(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Trade.Prompt.PickedActor")}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block$C, "create_if_block$C");
function create_default_slot$l(ctx) {
  let div4;
  let p0;
  let t0;
  let p1;
  let strong;
  let t2;
  let p2;
  let t4;
  let div1;
  let div0;
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t5;
  let div3;
  let div2;
  let label;
  let input;
  let t6;
  let span;
  let t8;
  let small;
  let t10;
  let t11;
  let actordropselect;
  let updating_actor;
  let t12;
  let footer;
  let button;
  let i1;
  let t13;
  let t14_value = localize("ITEM-PILES.Trade.Prompt.Label") + "";
  let t14;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[13].id, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$o(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$o(key, child_ctx));
  }
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block$C;
    return create_else_block$i;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  function actordropselect_actor_binding(value) {
    ctx[9](value);
  }
  __name(actordropselect_actor_binding, "actordropselect_actor_binding");
  let actordropselect_props = { actors: ctx[4] };
  if (ctx[5] !== void 0) {
    actordropselect_props.actor = ctx[5];
  }
  actordropselect = new ActorDropSelect({ props: actordropselect_props });
  binding_callbacks.push(() => bind$1(actordropselect, "actor", actordropselect_actor_binding));
  return {
    c() {
      div4 = element("div");
      p0 = element("p");
      p0.innerHTML = `<i class="item-piles-header-icon fas fa-handshake svelte-r6pfu5"></i>`;
      t0 = space();
      p1 = element("p");
      strong = element("strong");
      strong.textContent = `${localize("ITEM-PILES.Trade.Prompt.Title")}`;
      t2 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Trade.Prompt.User")}`;
      t4 = space();
      div1 = element("div");
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      label = element("label");
      input = element("input");
      t6 = space();
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Trade.Private")}`;
      t8 = space();
      small = element("small");
      small.textContent = `${localize("ITEM-PILES.Trade.PrivateExplanation")}`;
      t10 = space();
      if_block.c();
      t11 = space();
      create_component(actordropselect.$$.fragment);
      t12 = space();
      footer = element("footer");
      button = element("button");
      i1 = element("i");
      t13 = space();
      t14 = text(t14_value);
      set_style(strong, "font-size", "1.2rem");
      set_style(p1, "margin-bottom", "1rem");
      attr(select, "name", "user");
      set_style(select, "width", "66%");
      if (ctx[3] === void 0)
        add_render_callback(() => ctx[7].call(select));
      attr(div0, "class", "form-group align-center-row");
      attr(div1, "class", "item-piles-bottom-divider");
      attr(input, "type", "checkbox");
      attr(input, "name", "private");
      attr(label, "class", "align-center-row");
      attr(div2, "class", "form-group align-center-col");
      attr(div3, "class", "item-piles-bottom-divider");
      attr(i1, "class", "fas fa-check");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = !ctx[5];
      attr(button, "class", "svelte-r6pfu5");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      attr(div4, "class", "item-piles-flexcol trade-dialog svelte-r6pfu5");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, p0);
      append(div4, t0);
      append(div4, p1);
      append(p1, strong);
      append(div4, t2);
      append(div4, p2);
      append(div4, t4);
      append(div4, div1);
      append(div1, div0);
      append(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[3]);
      append(div4, t5);
      append(div4, div3);
      append(div3, div2);
      append(div2, label);
      append(label, input);
      input.checked = ctx[1];
      append(label, t6);
      append(label, span);
      append(div2, t8);
      append(div2, small);
      append(div4, t10);
      if_block.m(div4, null);
      append(div4, t11);
      mount_component(actordropselect, div4, null);
      append(div4, t12);
      append(div4, footer);
      append(footer, button);
      append(button, i1);
      append(button, t13);
      append(button, t14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[7]),
          listen(input, "change", ctx[8]),
          listen(button, "click", ctx[6], { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$o, null, get_each_context$o);
      }
      if (dirty & 12) {
        select_option(select, ctx2[3]);
      }
      if (dirty & 2) {
        input.checked = ctx2[1];
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div4, t11);
        }
      }
      const actordropselect_changes = {};
      if (dirty & 16)
        actordropselect_changes.actors = ctx2[4];
      if (!updating_actor && dirty & 32) {
        updating_actor = true;
        actordropselect_changes.actor = ctx2[5];
        add_flush_callback(() => updating_actor = false);
      }
      actordropselect.$set(actordropselect_changes);
      if (!current || dirty & 32 && button_disabled_value !== (button_disabled_value = !ctx2[5])) {
        button.disabled = button_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(actordropselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actordropselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if_block.d();
      destroy_component(actordropselect);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$l, "create_default_slot$l");
function create_fragment$L(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[10](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$l] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 65598) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$L, "create_fragment$L");
function instance$L($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { isPrivate } = $$props;
  let { users } = $$props;
  let { user } = $$props;
  let { actors } = $$props;
  let { actor } = $$props;
  let isGM = game.user.isGM;
  users = game.users.filter((user2) => user2.active && user2 !== game.user);
  user = user || users?.[0] || false;
  actors = actors || game.actors.filter((actor2) => actor2.isOwner);
  actor = actor || game.user.character || (!isGM ? actors?.[0] : false);
  function requestTrade() {
    application.options.resolve({ user, actor, isPrivate });
    application.close();
  }
  __name(requestTrade, "requestTrade");
  function select_change_handler() {
    user = select_value(this);
    $$invalidate(3, user);
    $$invalidate(2, users);
  }
  __name(select_change_handler, "select_change_handler");
  function input_change_handler() {
    isPrivate = this.checked;
    $$invalidate(1, isPrivate);
  }
  __name(input_change_handler, "input_change_handler");
  function actordropselect_actor_binding(value) {
    actor = value;
    $$invalidate(5, actor);
  }
  __name(actordropselect_actor_binding, "actordropselect_actor_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("isPrivate" in $$props2)
      $$invalidate(1, isPrivate = $$props2.isPrivate);
    if ("users" in $$props2)
      $$invalidate(2, users = $$props2.users);
    if ("user" in $$props2)
      $$invalidate(3, user = $$props2.user);
    if ("actors" in $$props2)
      $$invalidate(4, actors = $$props2.actors);
    if ("actor" in $$props2)
      $$invalidate(5, actor = $$props2.actor);
  };
  return [
    elementRoot,
    isPrivate,
    users,
    user,
    actors,
    actor,
    requestTrade,
    select_change_handler,
    input_change_handler,
    actordropselect_actor_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$L, "instance$L");
class Trade_dialog_prompt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$L, safe_not_equal, {
      elementRoot: 0,
      isPrivate: 1,
      users: 2,
      user: 3,
      actors: 4,
      actor: 5
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get isPrivate() {
    return this.$$.ctx[1];
  }
  set isPrivate(isPrivate) {
    this.$$set({ isPrivate });
    flush();
  }
  get users() {
    return this.$$.ctx[2];
  }
  set users(users) {
    this.$$set({ users });
    flush();
  }
  get user() {
    return this.$$.ctx[3];
  }
  set user(user) {
    this.$$set({ user });
    flush();
  }
  get actors() {
    return this.$$.ctx[4];
  }
  set actors(actors) {
    this.$$set({ actors });
    flush();
  }
  get actor() {
    return this.$$.ctx[5];
  }
  set actor(actor) {
    this.$$set({ actor });
    flush();
  }
}
__name(Trade_dialog_prompt, "Trade_dialog_prompt");
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
__name(is_date, "is_date");
function get_interpolator(a, b) {
  if (a === b || a !== a)
    return () => a;
  const type = typeof a;
  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a)) {
    const arr = b.map((bi, i) => {
      return get_interpolator(a[i], bi);
    });
    return (t) => arr.map((fn) => fn(t));
  }
  if (type === "object") {
    if (!a || !b)
      throw new Error("Object cannot be null");
    if (is_date(a) && is_date(b)) {
      a = a.getTime();
      b = b.getTime();
      const delta = b - a;
      return (t) => new Date(a + t * delta);
    }
    const keys2 = Object.keys(b);
    const interpolators = {};
    keys2.forEach((key) => {
      interpolators[key] = get_interpolator(a[key], b[key]);
    });
    return (t) => {
      const result = {};
      keys2.forEach((key) => {
        result[key] = interpolators[key](t);
      });
      return result;
    };
  }
  if (type === "number") {
    const delta = b - a;
    return (t) => a + t * delta;
  }
  throw new Error(`Cannot interpolate ${type} values`);
}
__name(get_interpolator, "get_interpolator");
function tweened(value, defaults = {}) {
  const store = writable(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set(value = new_value);
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set(value = target_value);
      return Promise.resolve();
    }
    const start = now() + delay;
    let fn;
    task = loop$1((now2) => {
      if (now2 < start)
        return true;
      if (!started) {
        fn = interpolate(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now2 - start;
      if (elapsed > duration) {
        store.set(value = new_value);
        return false;
      }
      store.set(value = fn(easing(elapsed / duration)));
      return true;
    });
    return task.promise;
  }
  __name(set, "set");
  return {
    set,
    update: (fn, opts) => set(fn(target_value, value), opts),
    subscribe: store.subscribe
  };
}
__name(tweened, "tweened");
const tradeDialogRequest_svelte_svelte_type_style_lang = "";
function create_else_block_1$7(ctx) {
  let p;
  let t_value = localize("ITEM-PILES.Trade.Request.Content", {
    trading_user_name: ctx[5].name,
    trading_actor_name: ctx[4].name
  }) + "";
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 48 && t_value !== (t_value = localize("ITEM-PILES.Trade.Request.Content", {
        trading_user_name: ctx2[5].name,
        trading_actor_name: ctx2[4].name
      }) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block_1$7, "create_else_block_1$7");
function create_if_block_1$r(ctx) {
  let p;
  let raw_value = localize("ITEM-PILES.Trade.Request.PrivateContent", {
    trading_user_name: ctx[5].name,
    trading_actor_name: ctx[4].name
  }) + "";
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & 48 && raw_value !== (raw_value = localize("ITEM-PILES.Trade.Request.PrivateContent", {
        trading_user_name: ctx2[5].name,
        trading_actor_name: ctx2[4].name
      }) + ""))
        p.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_1$r, "create_if_block_1$r");
function create_else_block$h(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Trade.Prompt.PickActor")}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block$h, "create_else_block$h");
function create_if_block$B(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Trade.Prompt.PickedActor")}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block$B, "create_if_block$B");
function create_default_slot$k(ctx) {
  let div2;
  let p0;
  let t0;
  let p1;
  let strong;
  let t2;
  let div0;
  let t3;
  let p2;
  let t5;
  let t6;
  let actordropselect;
  let updating_actor;
  let t7;
  let footer;
  let button0;
  let i1;
  let t8;
  let t9_value = localize("ITEM-PILES.Trade.Accept") + "";
  let t9;
  let button0_disabled_value;
  let t10;
  let button1;
  let i2;
  let t11;
  let t12_value = localize("ITEM-PILES.Trade.Decline") + "";
  let t12;
  let t13;
  let button2;
  let i3;
  let t14;
  let t15_value = localize("ITEM-PILES.Trade.Mute") + "";
  let t15;
  let t16;
  let div1;
  let span;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$r;
    return create_else_block_1$7;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$B;
    return create_else_block$h;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  function actordropselect_actor_binding(value) {
    ctx[14](value);
  }
  __name(actordropselect_actor_binding, "actordropselect_actor_binding");
  let actordropselect_props = { actors: ctx[1] };
  if (ctx[2] !== void 0) {
    actordropselect_props.actor = ctx[2];
  }
  actordropselect = new ActorDropSelect({ props: actordropselect_props });
  binding_callbacks.push(() => bind$1(actordropselect, "actor", actordropselect_actor_binding));
  return {
    c() {
      div2 = element("div");
      p0 = element("p");
      p0.innerHTML = `<i class="item-piles-header-icon fas fa-handshake svelte-bu4abp"></i>`;
      t0 = space();
      p1 = element("p");
      strong = element("strong");
      strong.textContent = `${localize("ITEM-PILES.Trade.Request.Title")}`;
      t2 = space();
      div0 = element("div");
      if_block0.c();
      t3 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Trade.Request.AcceptQuery")}`;
      t5 = space();
      if_block1.c();
      t6 = space();
      create_component(actordropselect.$$.fragment);
      t7 = space();
      footer = element("footer");
      button0 = element("button");
      i1 = element("i");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      button1 = element("button");
      i2 = element("i");
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      button2 = element("button");
      i3 = element("i");
      t14 = space();
      t15 = text(t15_value);
      t16 = space();
      div1 = element("div");
      span = element("span");
      set_style(strong, "font-size", "1.2rem");
      set_style(p1, "margin-bottom", "1rem");
      attr(div0, "class", "item-piles-bottom-divider");
      attr(i1, "class", "fas fa-check");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = !ctx[2];
      attr(button0, "class", "svelte-bu4abp");
      attr(i2, "class", "fas fa-times");
      attr(button1, "type", "button");
      attr(button1, "class", "svelte-bu4abp");
      attr(i3, "class", "fas fa-comment-slash");
      attr(button2, "type", "button");
      attr(button2, "class", "svelte-bu4abp");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      attr(span, "class", "progress-bar svelte-bu4abp");
      set_style(span, "width", ctx[6] + "%");
      attr(div1, "class", "item-piles-progress svelte-bu4abp");
      set_style(div1, "flex", "1 0 auto");
      toggle_class(div1, "active", ctx[6] > 0);
      attr(div2, "class", "item-piles-flexcol trade-dialog svelte-bu4abp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p0);
      append(div2, t0);
      append(div2, p1);
      append(p1, strong);
      append(div2, t2);
      append(div2, div0);
      if_block0.m(div0, null);
      append(div0, t3);
      append(div0, p2);
      append(div2, t5);
      if_block1.m(div2, null);
      append(div2, t6);
      mount_component(actordropselect, div2, null);
      append(div2, t7);
      append(div2, footer);
      append(footer, button0);
      append(button0, i1);
      append(button0, t8);
      append(button0, t9);
      append(footer, t10);
      append(footer, button1);
      append(button1, i2);
      append(button1, t11);
      append(button1, t12);
      append(footer, t13);
      append(footer, button2);
      append(button2, i3);
      append(button2, t14);
      append(button2, t15);
      append(div2, t16);
      append(div2, div1);
      append(div1, span);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[7], { once: true }),
          listen(button1, "click", ctx[8], { once: true }),
          listen(button2, "click", ctx[9], { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, t3);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, t6);
        }
      }
      const actordropselect_changes = {};
      if (dirty & 2)
        actordropselect_changes.actors = ctx2[1];
      if (!updating_actor && dirty & 4) {
        updating_actor = true;
        actordropselect_changes.actor = ctx2[2];
        add_flush_callback(() => updating_actor = false);
      }
      actordropselect.$set(actordropselect_changes);
      if (!current || dirty & 4 && button0_disabled_value !== (button0_disabled_value = !ctx2[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & 64) {
        set_style(span, "width", ctx2[6] + "%");
      }
      if (!current || dirty & 64) {
        toggle_class(div1, "active", ctx2[6] > 0);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(actordropselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actordropselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block0.d();
      if_block1.d();
      destroy_component(actordropselect);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$k, "create_default_slot$k");
function create_fragment$K(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[15](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$k] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 8388734) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$K, "create_fragment$K");
function instance$K($$self, $$props, $$invalidate) {
  let actualProgress;
  let $progress;
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { isPrivate } = $$props;
  let { tradingActor } = $$props;
  let { tradingUser } = $$props;
  let { users } = $$props;
  let { user } = $$props;
  let { actors } = $$props;
  let { actor } = $$props;
  let isGM = game.user.isGM;
  users = game.users.filter((user2) => user2.active && user2 !== game.user);
  user = user || users?.[0] || false;
  actors = actors || game.actors.filter((actor2) => actor2.isOwner);
  actor = actor || game.user.character || (!isGM ? actors?.[0] : false);
  let done = false;
  async function accept() {
    application.options.resolve(actor);
    close();
  }
  __name(accept, "accept");
  async function decline() {
    application.options.resolve(false);
    close();
  }
  __name(decline, "decline");
  async function mute() {
    application.options.resolve("mute");
    close();
  }
  __name(mute, "mute");
  async function disconnected() {
    custom_warning(game.i18n.localize("ITEM-PILES.Trade.Disconnected"), true);
    close();
  }
  __name(disconnected, "disconnected");
  const progress = tweened(0, { duration: 2e4, easing: identity });
  component_subscribe($$self, progress, (value) => $$invalidate(13, $progress = value));
  let timeout = setTimeout(
    () => {
      if (done)
        return;
      progress.set(1);
      timeout = setTimeout(
        () => {
          if (done)
            return;
          custom_warning(localize("ITEM-PILES.Trade.AutoDecline"), true);
          decline();
        },
        21e3
      );
    },
    14e3
  );
  const connection = setInterval(
    () => {
      const user2 = game.users.get(tradingUser.id);
      if (!user2.active) {
        disconnected();
      }
    },
    100
  );
  function close() {
    clearInterval(connection);
    clearTimeout(timeout);
    done = true;
    application.close();
  }
  __name(close, "close");
  function actordropselect_actor_binding(value) {
    actor = value;
    $$invalidate(2, actor);
  }
  __name(actordropselect_actor_binding, "actordropselect_actor_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("isPrivate" in $$props2)
      $$invalidate(3, isPrivate = $$props2.isPrivate);
    if ("tradingActor" in $$props2)
      $$invalidate(4, tradingActor = $$props2.tradingActor);
    if ("tradingUser" in $$props2)
      $$invalidate(5, tradingUser = $$props2.tradingUser);
    if ("users" in $$props2)
      $$invalidate(11, users = $$props2.users);
    if ("user" in $$props2)
      $$invalidate(12, user = $$props2.user);
    if ("actors" in $$props2)
      $$invalidate(1, actors = $$props2.actors);
    if ("actor" in $$props2)
      $$invalidate(2, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $$invalidate(6, actualProgress = $progress * 100);
    }
  };
  return [
    elementRoot,
    actors,
    actor,
    isPrivate,
    tradingActor,
    tradingUser,
    actualProgress,
    accept,
    decline,
    mute,
    progress,
    users,
    user,
    $progress,
    actordropselect_actor_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$K, "instance$K");
class Trade_dialog_request extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$K, safe_not_equal, {
      elementRoot: 0,
      isPrivate: 3,
      tradingActor: 4,
      tradingUser: 5,
      users: 11,
      user: 12,
      actors: 1,
      actor: 2
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get isPrivate() {
    return this.$$.ctx[3];
  }
  set isPrivate(isPrivate) {
    this.$$set({ isPrivate });
    flush();
  }
  get tradingActor() {
    return this.$$.ctx[4];
  }
  set tradingActor(tradingActor) {
    this.$$set({ tradingActor });
    flush();
  }
  get tradingUser() {
    return this.$$.ctx[5];
  }
  set tradingUser(tradingUser) {
    this.$$set({ tradingUser });
    flush();
  }
  get users() {
    return this.$$.ctx[11];
  }
  set users(users) {
    this.$$set({ users });
    flush();
  }
  get user() {
    return this.$$.ctx[12];
  }
  set user(user) {
    this.$$set({ user });
    flush();
  }
  get actors() {
    return this.$$.ctx[1];
  }
  set actors(actors) {
    this.$$set({ actors });
    flush();
  }
  get actor() {
    return this.$$.ctx[2];
  }
  set actor(actor) {
    this.$$set({ actor });
    flush();
  }
}
__name(Trade_dialog_request, "Trade_dialog_request");
class TradePromptDialog extends SvelteApplication {
  constructor(tradeOptions, options = {}) {
    super({
      svelte: {
        class: Trade_dialog_prompt,
        target: document.body,
        props: {
          ...tradeOptions
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Trade.Title"),
      width: 400,
      height: "auto",
      classes: ["dialog"]
    });
  }
  static show(tradeOptions, options = {}, dialogData = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(tradeOptions, options, dialogData).render(true);
    });
  }
}
__name(TradePromptDialog, "TradePromptDialog");
class TradeRequestDialog extends SvelteApplication {
  constructor(tradeOptions, options = {}) {
    super({
      svelte: {
        class: Trade_dialog_request,
        target: document.body,
        props: {
          ...tradeOptions
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
    this.tradeId = tradeOptions.tradeId;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Trade.Title"),
      width: 400,
      height: "auto",
      classes: ["dialog"]
    });
  }
  static show(tradeOptions, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(tradeOptions, options).render(true);
    });
  }
  static cancel(tradeId) {
    for (const app of Object.values(ui.windows)) {
      if (app instanceof this && app.tradeId === tradeId) {
        app.options.resolve({ type: "cancelled" });
        return app.close();
      }
    }
    return false;
  }
}
__name(TradeRequestDialog, "TradeRequestDialog");
class TradeStore {
  constructor(leftTrader, rightTrader, publicTradeId, privateTradeId = false, isPrivate = false) {
    this.publicTradeId = publicTradeId;
    this.privateTradeId = privateTradeId;
    this.isPrivate = isPrivate;
    this.leftTraderUser = leftTrader.user;
    this.leftTraderActor = leftTrader.actor;
    this.leftTraderItems = writable(leftTrader.items ?? []);
    this.leftTraderCurrencies = writable(leftTrader.currencies ?? []);
    this.leftTraderItemCurrencies = writable(leftTrader.itemCurrencies ?? []);
    this.leftTraderAccepted = writable(leftTrader.accepted ?? false);
    this.rightTraderUser = rightTrader.user;
    this.rightTraderActor = rightTrader.actor;
    this.rightTraderItems = writable(rightTrader.items ?? []);
    this.rightTraderCurrencies = writable(rightTrader.currencies ?? []);
    this.rightTraderItemCurrencies = writable(rightTrader.itemCurrencies ?? []);
    this.rightTraderAccepted = writable(rightTrader?.accepted ?? false);
  }
  static import(leftTraderData, rightTraderData, publicTradeId) {
    const leftTrader = {
      user: game.users.get(leftTraderData.userId),
      actor: fromUuidSync(leftTraderData.actorUiid),
      items: leftTraderData.items,
      currencies: leftTraderData.currencies,
      itemCurrencies: leftTraderData.itemCurrencies,
      accepted: leftTraderData.accepted
    };
    const rightTrader = {
      user: game.users.get(rightTraderData.userId),
      actor: fromUuidSync(rightTraderData.actorUiid),
      items: rightTraderData.items,
      currencies: rightTraderData.currencies,
      itemCurrencies: rightTraderData.itemCurrencies,
      accepted: rightTraderData.accepted
    };
    return new this(leftTrader, rightTrader, publicTradeId);
  }
  export() {
    return [{
      userId: this.leftTraderUser.id,
      actorUiid: getUuid(this.leftTraderActor),
      items: get_store_value(this.leftTraderItems),
      currencies: get_store_value(this.leftTraderCurrencies),
      itemCurrencies: get_store_value(this.leftTraderItemCurrencies),
      accepted: get_store_value(this.leftTraderAccepted)
    }, {
      userId: this.rightTraderUser.id,
      actorUiid: getUuid(this.rightTraderActor),
      items: get_store_value(this.rightTraderItems),
      currencies: get_store_value(this.rightTraderCurrencies),
      itemCurrencies: get_store_value(this.rightTraderItemCurrencies),
      accepted: get_store_value(this.rightTraderAccepted)
    }, this.publicTradeId];
  }
  getTradeData() {
    return {
      sourceActor: this.leftTraderActor,
      targetActor: this.rightTraderActor,
      remove: {
        items: get_store_value(this.leftTraderItems).concat(get_store_value(this.leftTraderItemCurrencies)),
        attributes: get_store_value(this.leftTraderCurrencies)
      },
      add: {
        items: get_store_value(this.rightTraderItems).concat(get_store_value(this.rightTraderItemCurrencies)),
        attributes: get_store_value(this.rightTraderCurrencies)
      }
    };
  }
  get isUserParticipant() {
    return game.user === this.leftTraderUser || game.user === this.rightTraderUser;
  }
  getExistingCurrencies() {
    return [...get_store_value(this.leftTraderCurrencies), ...get_store_value(this.leftTraderItemCurrencies)];
  }
  get tradeIsAccepted() {
    return get_store_value(this.leftTraderAccepted) && get_store_value(this.rightTraderAccepted);
  }
  async toggleAccepted() {
    this.leftTraderAccepted.set(!get_store_value(this.leftTraderAccepted));
  }
  updateItems(userId, inItems) {
    if (userId === game.user.id)
      return;
    this.leftTraderAccepted.set(false);
    this.rightTraderAccepted.set(false);
    if (userId === this.leftTraderUser.id) {
      this.leftTraderItems.set(inItems);
    }
    if (userId === this.rightTraderUser.id) {
      this.rightTraderItems.set(inItems);
    }
  }
  updateItemCurrencies(userId, itemCurrencies) {
    if (userId === game.user.id)
      return;
    this.leftTraderAccepted.set(false);
    this.rightTraderAccepted.set(false);
    if (userId === this.leftTraderUser.id) {
      this.leftTraderItemCurrencies.set(itemCurrencies);
    }
    if (userId === this.rightTraderUser.id) {
      this.rightTraderItemCurrencies.set(itemCurrencies);
    }
  }
  updateCurrencies(userId, inCurrencies) {
    if (userId === game.user.id)
      return;
    this.leftTraderAccepted.set(false);
    this.rightTraderAccepted.set(false);
    if (userId === this.leftTraderUser.id) {
      this.leftTraderCurrencies.set(inCurrencies);
    }
    if (userId === this.rightTraderUser.id) {
      this.rightTraderCurrencies.set(inCurrencies);
    }
  }
  updateAcceptedState(userId, state) {
    if (userId === game.user.id)
      return;
    if (userId === this.leftTraderUser.id) {
      this.leftTraderAccepted.set(state);
    }
    if (userId === this.rightTraderUser.id) {
      this.rightTraderAccepted.set(state);
    }
  }
  addItem(newItem, { quantity = false, currency = false } = {}) {
    const items = !currency ? get_store_value(this.leftTraderItems) : get_store_value(this.leftTraderItemCurrencies);
    const item = findSimilarItem(items, newItem);
    const maxQuantity = game.user.isGM ? Infinity : getItemQuantity(newItem);
    if (item && canItemStack(item)) {
      if (item.quantity >= maxQuantity)
        return;
      item.quantity = Math.min(quantity ? quantity : item.quantity + 1, maxQuantity);
      item.newQuantity = item.quantity;
      item.maxQuantity = maxQuantity;
    } else if (!item) {
      items.push({
        id: newItem.id,
        name: newItem.name,
        img: newItem?.img ?? "",
        type: newItem?.type,
        currency,
        quantity: quantity ? quantity : 1,
        newQuantity: quantity ? quantity : 1,
        maxQuantity,
        data: newItem instanceof Item ? newItem.toObject() : newItem
      });
    }
    if (!currency) {
      this.leftTraderItems.set(items);
    } else {
      this.leftTraderItemCurrencies.set(items);
    }
  }
  addAttribute(newCurrency) {
    const currencies = get_store_value(this.leftTraderCurrencies);
    const existingCurrency = currencies.find((currency) => currency.path === newCurrency.path);
    if (existingCurrency) {
      existingCurrency.quantity = newCurrency.quantity;
      existingCurrency.newQuantity = newCurrency.quantity;
    } else {
      currencies.push(newCurrency);
    }
    currencies.sort((a, b) => a.index - b.index);
    this.leftTraderCurrencies.set(currencies);
  }
  removeEntry(entry) {
    if (entry.id) {
      if (!entry.currency) {
        const items = get_store_value(this.leftTraderItems).filter((item) => item.id !== entry.id);
        this.leftTraderItems.set(items);
      } else {
        const items = get_store_value(this.leftTraderItemCurrencies).filter((item) => item.id !== entry.id);
        this.leftTraderItemCurrencies.set(items);
      }
    } else {
      const items = get_store_value(this.leftTraderCurrencies).filter((currency) => currency.path !== entry.path);
      this.leftTraderCurrencies.set(items);
    }
  }
}
__name(TradeStore, "TradeStore");
function create_fragment$J(ctx) {
  let div;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "style", div_style_value = ctx[3].style);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "dragenter", ctx[1]),
          listen(div, "dragleave", ctx[2]),
          listen(div, "dragstart", prevent_default(ctx[10])),
          listen(div, "dragover", prevent_default(ctx[11])),
          listen(div, "drop", prevent_default(ctx[0]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8 && div_style_value !== (div_style_value = ctx2[3].style)) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$J, "create_fragment$J");
function instance$J($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { callback } = $$props;
  let { isHovering } = $$props;
  let { active: active2 = true } = $$props;
  function dropData(event) {
    if (!active2)
      return;
    $$invalidate(7, counter = 0);
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
    } catch (err) {
      return false;
    }
    callback(data);
  }
  __name(dropData, "dropData");
  let counter = 0;
  function enter() {
    if (!active2)
      return;
    $$invalidate(7, counter++, counter);
  }
  __name(enter, "enter");
  function leave() {
    if (!active2)
      return;
    $$invalidate(7, counter--, counter);
  }
  __name(leave, "leave");
  function dragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  __name(dragstart_handler, "dragstart_handler");
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  __name(dragover_handler, "dragover_handler");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("callback" in $$new_props)
      $$invalidate(5, callback = $$new_props.callback);
    if ("isHovering" in $$new_props)
      $$invalidate(4, isHovering = $$new_props.isHovering);
    if ("active" in $$new_props)
      $$invalidate(6, active2 = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(4, isHovering = counter > 0);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    dropData,
    enter,
    leave,
    $$props,
    isHovering,
    callback,
    active2,
    counter,
    $$scope,
    slots,
    dragstart_handler,
    dragover_handler
  ];
}
__name(instance$J, "instance$J");
class DropZone extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$J, safe_not_equal, { callback: 5, isHovering: 4, active: 6 });
  }
}
__name(DropZone, "DropZone");
function create_if_block_4$b(ctx) {
  let div;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      a.innerHTML = `<i class="fas fa-times"></i>`;
      attr(a, "class", "item-piles-clickable-red");
      set_style(div, "flex", "0 1 auto");
      set_style(div, "margin", "0 6px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      if (!mounted) {
        dispose = listen(a, "click", ctx[8]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$b, "create_if_block_4$b");
function create_if_block_2$n(ctx) {
  let div;
  let if_block = ctx[0].editing && create_if_block_3$i(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_style(div, "flex", "0 1 17px");
      set_style(div, "margin", "0 5px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (ctx2[0].editing) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$i(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block_2$n, "create_if_block_2$n");
function create_if_block_3$i(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fas fa-check"></i>`;
      attr(a, "class", "item-piles-clickable-green item-piles-confirm-quantity");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$i, "create_if_block_3$i");
function create_else_block_1$6(ctx) {
  let span;
  let t_value = ctx[0].quantity + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "item-piles-text");
      set_style(span, "padding-right", "0.5rem");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].quantity + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_else_block_1$6, "create_else_block_1$6");
function create_if_block$A(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].editing)
      return create_if_block_1$q;
    return create_else_block$g;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "item-piles-quantity-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
__name(create_if_block$A, "create_if_block$A");
function create_else_block$g(ctx) {
  let span;
  let t_value = ctx[0].quantity + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "item-piles-quantity-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = listen(span, "click", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].quantity + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$g, "create_else_block$g");
function create_if_block_1$q(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "number");
      attr(div, "class", "item-piles-quantity-input-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0].newQuantity);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[9]),
          listen(input, "keydown", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && to_number(input.value) !== ctx2[0].newQuantity) {
        set_input_value(input, ctx2[0].newQuantity);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$q, "create_if_block_1$q");
function create_fragment$I(ctx) {
  let div4;
  let t0;
  let div0;
  let img;
  let img_src_value;
  let t1;
  let div2;
  let div1;
  let p;
  let t2_value = ctx[0].name + "";
  let t2;
  let t3;
  let t4;
  let div3;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_4$b(ctx);
  let if_block1 = ctx[2] && create_if_block_2$n(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$A;
    return create_else_block_1$6;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block2 = current_block_type(ctx);
  return {
    c() {
      div4 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      img = element("img");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      p = element("p");
      t2 = text(t2_value);
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      div3 = element("div");
      if_block2.c();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[0].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      toggle_class(p, "item-piles-clickable-link", ctx[3]);
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name item-piles-text");
      attr(div3, "class", "item-piles-text-right");
      toggle_class(div3, "item-piles-quantity-container", ctx[2]);
      attr(div4, "class", "item-piles-flexrow item-piles-item-row item-piles-even-color");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t0);
      append(div4, div0);
      append(div0, img);
      append(div4, t1);
      append(div4, div2);
      append(div2, div1);
      append(div1, p);
      append(p, t2);
      append(div4, t3);
      if (if_block1)
        if_block1.m(div4, null);
      append(div4, t4);
      append(div4, div3);
      if_block2.m(div3, null);
      if (!mounted) {
        dispose = [
          listen(window, "click", ctx[7]),
          listen(p, "click", ctx[4]),
          listen(div3, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$b(ctx2);
          if_block0.c();
          if_block0.m(div4, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].name + ""))
        set_data(t2, t2_value);
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$n(ctx2);
          if_block1.c();
          if_block1.m(div4, t4);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div3, null);
        }
      }
      if (dirty & 4) {
        toggle_class(div3, "item-piles-quantity-container", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$I, "create_fragment$I");
const click_handler_3 = /* @__PURE__ */ __name((evt) => evt.stopPropagation(), "click_handler_3");
function instance$I($$self, $$props, $$invalidate) {
  let { store } = $$props;
  let { data } = $$props;
  let { editable = true } = $$props;
  const canPreview = data.id && (getSetting(SETTINGS.INSPECT_ITEMS_IN_TRADE) || editable);
  function previewItem2() {
    if (!canPreview || !data.id)
      return;
    const item = store.leftTraderActor.items.get(data.id) ?? store.rightTraderActor.items.get(data.id);
    if (!item)
      return;
    if (game.user.isGM || item.permission[game.user.id] === 3) {
      return item.sheet.render(true);
    }
    const cls = item._getSheetClass();
    const sheet = new cls(item, { editable: false });
    return sheet._render(true);
  }
  __name(previewItem2, "previewItem");
  function onKeyDown(e) {
    if (e.keyCode === 13) {
      updateQuantity();
    }
  }
  __name(onKeyDown, "onKeyDown");
  function updateQuantity() {
    $$invalidate(0, data.quantity = Math.max(0, Math.min(data.maxQuantity, data.newQuantity)), data);
    if (data.quantity === 0) {
      return store.removeEntry(data);
    }
    $$invalidate(0, data.newQuantity = data.quantity, data);
    $$invalidate(0, data.editing = false, data);
  }
  __name(updateQuantity, "updateQuantity");
  const click_handler = /* @__PURE__ */ __name(() => {
    if (data.editing && editable)
      updateQuantity();
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    store.removeEntry(data);
  }, "click_handler_1");
  function input_input_handler() {
    data.newQuantity = to_number(this.value);
    $$invalidate(0, data);
  }
  __name(input_input_handler, "input_input_handler");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    $$invalidate(0, data.editing = true, data);
  }, "click_handler_2");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(1, store = $$props2.store);
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("editable" in $$props2)
      $$invalidate(2, editable = $$props2.editable);
  };
  return [
    data,
    store,
    editable,
    canPreview,
    previewItem2,
    onKeyDown,
    updateQuantity,
    click_handler,
    click_handler_1,
    input_input_handler,
    click_handler_22
  ];
}
__name(instance$I, "instance$I");
class TradeEntry extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$I, safe_not_equal, { store: 1, data: 0, editable: 2 });
  }
}
__name(TradeEntry, "TradeEntry");
function get_each_context$n(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
__name(get_each_context$n, "get_each_context$n");
function get_each_context_1$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[27] = list;
  child_ctx[25] = i;
  return child_ctx;
}
__name(get_each_context_1$9, "get_each_context_1$9");
function create_else_block_2$1(ctx) {
  let p;
  let t_value = localize("ITEM-PILES.Applications.DropCurrencies.NoCurrency", { actor_name: ctx[1].name }) + "";
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      set_style(p, "text-align", "center");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = localize("ITEM-PILES.Applications.DropCurrencies.NoCurrency", { actor_name: ctx2[1].name }) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_else_block_2$1, "create_else_block_2$1");
function create_if_block_1$p(ctx) {
  let p;
  let t0_value = (ctx[3]?.content ?? localize("ITEM-PILES.Applications.DropCurrencies." + (ctx[2] ? "Player" : "GM"))) + "";
  let t0;
  let t1;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t2;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let each1_anchor;
  let each_value_1 = ctx[4];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[26].path, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$9(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$9(key, child_ctx));
  }
  let each_value = ctx[5];
  const get_key_1 = /* @__PURE__ */ __name((ctx2) => ctx2[23].id, "get_key_1");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$n(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block$n(key, child_ctx));
  }
  return {
    c() {
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
      set_style(p, "text-align", "center");
      attr(p, "class", "item-piles-bottom-divider");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(target, anchor);
      }
      insert(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 12 && t0_value !== (t0_value = (ctx2[3]?.content ?? localize("ITEM-PILES.Applications.DropCurrencies." + (ctx2[2] ? "Player" : "GM"))) + ""))
        set_data(t0, t0_value);
      if (dirty & 24) {
        each_value_1 = ctx2[4];
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, t2.parentNode, destroy_block, create_each_block_1$9, t2, get_each_context_1$9);
      }
      if (dirty & 40) {
        each_value = ctx2[5];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, each1_anchor.parentNode, destroy_block, create_each_block$n, each1_anchor, get_each_context$n);
      }
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (detaching)
        detach(t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d(detaching);
      }
      if (detaching)
        detach(t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each1_anchor);
    }
  };
}
__name(create_if_block_1$p, "create_if_block_1$p");
function create_else_block_1$5(ctx) {
  let input0;
  let input0_max_value;
  let t0;
  let input1;
  let t1;
  let div;
  let t2;
  let t3_value = ctx[26].quantity + "";
  let t3;
  let mounted;
  let dispose;
  function input0_change_input_handler() {
    ctx[11].call(input0, ctx[27], ctx[25]);
  }
  __name(input0_change_input_handler, "input0_change_input_handler");
  function input1_input_handler() {
    ctx[12].call(input1, ctx[27], ctx[25]);
  }
  __name(input1_input_handler, "input1_input_handler");
  function click_handler() {
    return ctx[13](ctx[26], ctx[27], ctx[25]);
  }
  __name(click_handler, "click_handler");
  return {
    c() {
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      div = element("div");
      t2 = text("/ ");
      t3 = text(t3_value);
      attr(input0, "class", "item-piles-range-slider");
      set_style(input0, "flex", "5");
      attr(input0, "type", "range");
      attr(input0, "min", "0");
      attr(input0, "max", input0_max_value = ctx[26].quantity);
      attr(input1, "class", "item-piles-range-input");
      set_style(input1, "flex", "1.5");
      set_style(input1, "margin-left", "1rem");
      attr(input1, "type", "number");
      set_style(div, "flex", "0 1 50px");
      set_style(div, "margin", "0 5px");
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(input0, ctx[26].currentQuantity);
      insert(target, t0, anchor);
      insert(target, input1, anchor);
      set_input_value(input1, ctx[26].currentQuantity);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      append(div, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(input0, "change", input0_change_input_handler),
          listen(input0, "input", input0_change_input_handler),
          listen(input1, "input", input1_input_handler),
          listen(input1, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && input0_max_value !== (input0_max_value = ctx[26].quantity)) {
        attr(input0, "max", input0_max_value);
      }
      if (dirty & 16) {
        set_input_value(input0, ctx[26].currentQuantity);
      }
      if (dirty & 16 && to_number(input1.value) !== ctx[26].currentQuantity) {
        set_input_value(input1, ctx[26].currentQuantity);
      }
      if (dirty & 16 && t3_value !== (t3_value = ctx[26].quantity + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(input0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(input1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_else_block_1$5, "create_else_block_1$5");
function create_if_block_3$h(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[10].call(input, ctx[27], ctx[25]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    c() {
      input = element("input");
      attr(input, "class", "item-piles-range-input");
      set_style(input, "flex", "1.5");
      set_style(input, "margin-left", "1rem");
      attr(input, "type", "number");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[26].currentQuantity);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && to_number(input.value) !== ctx[26].currentQuantity) {
        set_input_value(input, ctx[26].currentQuantity);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$h, "create_if_block_3$h");
function create_each_block_1$9(key_1, ctx) {
  let div3;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let div1;
  let t1_value = ctx[26].name + "";
  let t1;
  let t2;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3]?.unlimitedCurrencies)
      return create_if_block_3$h;
    return create_else_block_1$5;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div3 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if_block.c();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[26].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      attr(div2, "class", "item-piles-name item-piles-text");
      attr(div3, "class", "form-group item-piles-slider-group item-piles-odd-color");
      this.first = div3;
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, t1);
      append(div3, t2);
      if_block.m(div3, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && !src_url_equal(img.src, img_src_value = ctx[26].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 16 && t1_value !== (t1_value = ctx[26].name + ""))
        set_data(t1, t1_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div3, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
__name(create_each_block_1$9, "create_each_block_1$9");
function create_else_block$f(ctx) {
  let input0;
  let input0_max_value;
  let t0;
  let input1;
  let t1;
  let div;
  let t2;
  let t3_value = ctx[23].quantity + "";
  let t3;
  let mounted;
  let dispose;
  function input0_change_input_handler_1() {
    ctx[15].call(input0, ctx[24], ctx[25]);
  }
  __name(input0_change_input_handler_1, "input0_change_input_handler_1");
  function input1_input_handler_1() {
    ctx[16].call(input1, ctx[24], ctx[25]);
  }
  __name(input1_input_handler_1, "input1_input_handler_1");
  function click_handler_1() {
    return ctx[17](ctx[23], ctx[24], ctx[25]);
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      div = element("div");
      t2 = text("/ ");
      t3 = text(t3_value);
      attr(input0, "class", "item-piles-range-slider");
      set_style(input0, "flex", "5");
      attr(input0, "type", "range");
      attr(input0, "min", "0");
      attr(input0, "max", input0_max_value = ctx[23].quantity);
      attr(input1, "class", "item-piles-range-input");
      set_style(input1, "flex", "1.5");
      set_style(input1, "margin-left", "1rem");
      attr(input1, "type", "number");
      set_style(div, "flex", "0 1 50px");
      set_style(div, "margin", "0 5px");
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(input0, ctx[23].currentQuantity);
      insert(target, t0, anchor);
      insert(target, input1, anchor);
      set_input_value(input1, ctx[23].currentQuantity);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      append(div, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(input0, "change", input0_change_input_handler_1),
          listen(input0, "input", input0_change_input_handler_1),
          listen(input1, "input", input1_input_handler_1),
          listen(input1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && input0_max_value !== (input0_max_value = ctx[23].quantity)) {
        attr(input0, "max", input0_max_value);
      }
      if (dirty & 32) {
        set_input_value(input0, ctx[23].currentQuantity);
      }
      if (dirty & 32 && to_number(input1.value) !== ctx[23].currentQuantity) {
        set_input_value(input1, ctx[23].currentQuantity);
      }
      if (dirty & 32 && t3_value !== (t3_value = ctx[23].quantity + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(input0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(input1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_else_block$f, "create_else_block$f");
function create_if_block_2$m(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[14].call(input, ctx[24], ctx[25]);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  return {
    c() {
      input = element("input");
      attr(input, "class", "item-piles-range-input");
      set_style(input, "flex", "1.5");
      set_style(input, "margin-left", "1rem");
      attr(input, "type", "number");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[23].currentQuantity);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && to_number(input.value) !== ctx[23].currentQuantity) {
        set_input_value(input, ctx[23].currentQuantity);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_2$m, "create_if_block_2$m");
function create_each_block$n(key_1, ctx) {
  let div3;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let div1;
  let t1_value = ctx[23].name + "";
  let t1;
  let t2;
  let t3;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[3]?.unlimitedCurrencies)
      return create_if_block_2$m;
    return create_else_block$f;
  }
  __name(select_block_type_2, "select_block_type_2");
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div3 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if_block.c();
      t3 = space();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[23].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      attr(div2, "class", "item-piles-name item-piles-text");
      attr(div3, "class", "form-group item-piles-slider-group item-piles-odd-color");
      this.first = div3;
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, t1);
      append(div3, t2);
      if_block.m(div3, null);
      append(div3, t3);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && !src_url_equal(img.src, img_src_value = ctx[23].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 32 && t1_value !== (t1_value = ctx[23].name + ""))
        set_data(t1, t1_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div3, t3);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
__name(create_each_block$n, "create_each_block$n");
function create_if_block$z(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = (ctx[3]?.button ?? localize("ITEM-PILES.Applications.DropCurrencies.AddToPile")) + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-download");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[8], { once: true });
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t1_value !== (t1_value = (ctx2[3]?.button ?? localize("ITEM-PILES.Applications.DropCurrencies.AddToPile")) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$z, "create_if_block$z");
function create_default_slot$j(ctx) {
  let form_1;
  let t0;
  let footer;
  let t1;
  let button;
  let i;
  let t2;
  let t3_value = localize("Cancel") + "";
  let t3;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].length || ctx2[5].length)
      return create_if_block_1$p;
    return create_else_block_2$1;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (ctx[4].length || ctx[5].length) && create_if_block$z(ctx);
  return {
    c() {
      form_1 = element("form");
      if_block0.c();
      t0 = space();
      footer = element("footer");
      if (if_block1)
        if_block1.c();
      t1 = space();
      button = element("button");
      i = element("i");
      t2 = space();
      t3 = text(t3_value);
      attr(i, "class", "fas fa-times");
      attr(button, "type", "button");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      set_style(footer, "margin-top", "1rem");
      attr(form_1, "class", "item-piles-flexcol");
      set_style(form_1, "padding", "0.5rem");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      if_block0.m(form_1, null);
      append(form_1, t0);
      append(form_1, footer);
      if (if_block1)
        if_block1.m(footer, null);
      append(footer, t1);
      append(footer, button);
      append(button, i);
      append(button, t2);
      append(button, t3);
      ctx[19](form_1);
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[18], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[9]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(form_1, t0);
        }
      }
      if (ctx2[4].length || ctx2[5].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$z(ctx2);
          if_block1.c();
          if_block1.m(footer, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$j, "create_default_slot$j");
function create_fragment$H(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[20](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$j] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 268435582) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$H, "create_fragment$H");
function instance$H($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { sourceActor } = $$props;
  let { targetActor } = $$props;
  let { settings } = $$props;
  let { elementRoot } = $$props;
  const targetCurrencyData = getCurrencyList(targetActor);
  const currencies = getActorCurrencies(sourceActor, {
    currencyList: targetActor ? targetCurrencyData.currencies : false,
    getAll: settings?.unlimitedCurrencies
  });
  let attributes2 = currencies.filter((entry) => entry.type === "attribute").map((currency) => {
    currency.currentQuantity = 0;
    return currency;
  });
  if (settings?.existingCurrencies) {
    attributes2.forEach((currency) => {
      const existingCurrency = settings?.existingCurrencies.find((existingCurrency2) => existingCurrency2.id === currency.id);
      if (existingCurrency) {
        currency.currentQuantity = existingCurrency.quantity;
      }
    });
  }
  let items = currencies.filter((entry) => entry.type !== "attribute").map((currency) => {
    currency.create = !currency.id;
    currency.id = currency.id ?? randomID();
    currency.currentQuantity = 0;
    return currency;
  });
  if (settings?.existingCurrencies) {
    items.forEach((currency) => {
      const existingCurrency = settings?.existingCurrencies.find((existingCurrency2) => existingCurrency2.id === currency.id);
      if (existingCurrency) {
        currency.currentQuantity = existingCurrency.quantity;
      }
    });
  }
  let form;
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function submit() {
    const itemsToUpdate = items.filter((item) => item.currentQuantity && !item.create).map((item) => ({
      _id: item.id,
      quantity: item.currentQuantity
    }));
    const itemsToCreate = items.filter((item) => item.currentQuantity && item.create).map((item) => ({
      item: item.data.item,
      quantity: item.currentQuantity
    }));
    application.options.resolve({
      attributes: Object.fromEntries(attributes2.filter((attribute) => attribute.currentQuantity).map((attribute) => [attribute.path, attribute.currentQuantity])),
      items: itemsToUpdate.concat(itemsToCreate)
    });
    application.close();
  }
  __name(submit, "submit");
  function input_input_handler(each_value_1, index) {
    each_value_1[index].currentQuantity = to_number(this.value);
    $$invalidate(4, attributes2);
  }
  __name(input_input_handler, "input_input_handler");
  function input0_change_input_handler(each_value_1, index) {
    each_value_1[index].currentQuantity = to_number(this.value);
    $$invalidate(4, attributes2);
  }
  __name(input0_change_input_handler, "input0_change_input_handler");
  function input1_input_handler(each_value_1, index) {
    each_value_1[index].currentQuantity = to_number(this.value);
    $$invalidate(4, attributes2);
  }
  __name(input1_input_handler, "input1_input_handler");
  const click_handler = /* @__PURE__ */ __name((attribute, each_value_1, index) => {
    $$invalidate(4, each_value_1[index].currentQuantity = Math.max(0, Math.min(attribute.quantity, attribute.currentQuantity)), attributes2);
  }, "click_handler");
  function input_input_handler_1(each_value, index) {
    each_value[index].currentQuantity = to_number(this.value);
    $$invalidate(5, items);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  function input0_change_input_handler_1(each_value, index) {
    each_value[index].currentQuantity = to_number(this.value);
    $$invalidate(5, items);
  }
  __name(input0_change_input_handler_1, "input0_change_input_handler_1");
  function input1_input_handler_1(each_value, index) {
    each_value[index].currentQuantity = to_number(this.value);
    $$invalidate(5, items);
  }
  __name(input1_input_handler_1, "input1_input_handler_1");
  const click_handler_1 = /* @__PURE__ */ __name((item, each_value, index) => {
    $$invalidate(5, each_value[index].currentQuantity = Math.max(0, Math.min(item.quantity, item.currentQuantity)), items);
  }, "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler_2");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(6, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("sourceActor" in $$props2)
      $$invalidate(1, sourceActor = $$props2.sourceActor);
    if ("targetActor" in $$props2)
      $$invalidate(2, targetActor = $$props2.targetActor);
    if ("settings" in $$props2)
      $$invalidate(3, settings = $$props2.settings);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [
    elementRoot,
    sourceActor,
    targetActor,
    settings,
    attributes2,
    items,
    form,
    application,
    requestSubmit,
    submit,
    input_input_handler,
    input0_change_input_handler,
    input1_input_handler,
    click_handler,
    input_input_handler_1,
    input0_change_input_handler_1,
    input1_input_handler_1,
    click_handler_1,
    click_handler_22,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$H, "instance$H");
class Drop_currency_dialog_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$H, safe_not_equal, {
      sourceActor: 1,
      targetActor: 2,
      settings: 3,
      elementRoot: 0
    });
  }
  get sourceActor() {
    return this.$$.ctx[1];
  }
  set sourceActor(sourceActor) {
    this.$$set({ sourceActor });
    flush();
  }
  get targetActor() {
    return this.$$.ctx[2];
  }
  set targetActor(targetActor) {
    this.$$set({ targetActor });
    flush();
  }
  get settings() {
    return this.$$.ctx[3];
  }
  set settings(settings) {
    this.$$set({ settings });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
__name(Drop_currency_dialog_shell, "Drop_currency_dialog_shell");
class DropCurrencyDialog extends SvelteApplication {
  constructor(sourceActor, targetActor, settings = {}, options = {}) {
    super({
      id: `item-pile-drop-currency-${sourceActor.id + (targetActor ? "-" + targetActor.id : "")}`,
      title: settings?.title ?? game.i18n.localize("ITEM-PILES.Applications.DropCurrencies.Title"),
      svelte: {
        class: Drop_currency_dialog_shell,
        target: document.body,
        props: {
          sourceActor,
          targetActor,
          settings
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 430,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-drop-currency-${id}`);
  }
  static async show(sourceActor, targetActor, settings = {}, options = {}) {
    const apps = this.getActiveApps(sourceActor ? sourceActor.id + "-" + targetActor.id : targetActor.id);
    if (apps.length) {
      for (let app of apps) {
        app.render(false, { focus: true });
      }
      return;
    }
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(sourceActor, targetActor, settings, options).render(true, { focus: true });
    });
  }
}
__name(DropCurrencyDialog, "DropCurrencyDialog");
const tradingAppShell_svelte_svelte_type_style_lang = "";
function get_each_context$m(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[34] = list;
  child_ctx[35] = i;
  return child_ctx;
}
__name(get_each_context$m, "get_each_context$m");
function get_each_context_1$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[37] = list;
  child_ctx[38] = i;
  return child_ctx;
}
__name(get_each_context_1$8, "get_each_context_1$8");
function get_each_context_2$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[39] = list;
  child_ctx[40] = i;
  return child_ctx;
}
__name(get_each_context_2$2, "get_each_context_2$2");
function get_each_context_3$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[41] = list;
  child_ctx[42] = i;
  return child_ctx;
}
__name(get_each_context_3$1, "get_each_context_3$1");
function get_each_context_4$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[43] = list;
  child_ctx[44] = i;
  return child_ctx;
}
__name(get_each_context_4$1, "get_each_context_4$1");
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[45] = list;
  child_ctx[46] = i;
  return child_ctx;
}
__name(get_each_context_5, "get_each_context_5");
function create_if_block_7$1(ctx) {
  let div4;
  let div4_transition;
  let current;
  return {
    c() {
      div4 = element("div");
      div4.innerHTML = `<div class="svelte-3zgsgo"></div> 
      <div class="svelte-3zgsgo"></div> 
      <div class="svelte-3zgsgo"></div> 
      <div class="svelte-3zgsgo"></div>`;
      attr(div4, "class", "lds-ellipsis svelte-3zgsgo");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div4_transition)
          div4_transition = create_bidirectional_transition(div4, fade, {}, true);
        div4_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div4_transition)
        div4_transition = create_bidirectional_transition(div4, fade, {}, false);
      div4_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching && div4_transition)
        div4_transition.end();
    }
  };
}
__name(create_if_block_7$1, "create_if_block_7$1");
function create_if_block_6$4(ctx) {
  let div;
  let h3;
  return {
    c() {
      div = element("div");
      h3 = element("h3");
      h3.textContent = `${localize("ITEM-PILES.Trade.DragDrop")}`;
      attr(h3, "class", "item-piles-text-center");
      attr(div, "class", "item-piles-flexcol");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_6$4, "create_if_block_6$4");
function create_each_block_5(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding(value) {
    ctx[22](value, ctx[33], ctx[45], ctx[46]);
  }
  __name(tradeentry_data_binding, "tradeentry_data_binding");
  let tradeentry_props = {
    store: ctx[1],
    editable: ctx[1].isUserParticipant
  };
  if (ctx[33] !== void 0) {
    tradeentry_props.data = ctx[33];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (dirty[0] & 2)
        tradeentry_changes.editable = ctx[1].isUserParticipant;
      if (!updating_data && dirty[0] & 16) {
        updating_data = true;
        tradeentry_changes.data = ctx[33];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block_5, "create_each_block_5");
function create_if_block_3$g(ctx) {
  let div;
  let t0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t1;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let current;
  let if_block = ctx[1].isUserParticipant && create_if_block_4$a(ctx);
  let each_value_4 = ctx[5];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[36].path, "get_key");
  for (let i = 0; i < each_value_4.length; i += 1) {
    let child_ctx = get_each_context_4$1(ctx, each_value_4, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_4$1(key, child_ctx));
  }
  let each_value_3 = ctx[6];
  const get_key_1 = /* @__PURE__ */ __name((ctx2) => ctx2[33].path, "get_key_1");
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3$1(ctx, each_value_3, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block_3$1(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "row item-piles-items-list item-piles-currency-list svelte-3zgsgo");
      toggle_class(div, "item-piles-top-divider", ctx[5].length || ctx[6].length);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div, null);
      }
      append(div, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].isUserParticipant) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$a(ctx2);
          if_block.c();
          if_block.m(div, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 34) {
        each_value_4 = ctx2[5];
        group_outros();
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_4, each0_lookup, div, outro_and_destroy_block, create_each_block_4$1, t1, get_each_context_4$1);
        check_outros();
      }
      if (dirty[0] & 66) {
        each_value_3 = ctx2[6];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_3, each1_lookup, div, outro_and_destroy_block, create_each_block_3$1, null, get_each_context_3$1);
        check_outros();
      }
      if (!current || dirty[0] & 96) {
        toggle_class(div, "item-piles-top-divider", ctx2[5].length || ctx2[6].length);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block_3$g, "create_if_block_3$g");
function create_if_block_4$a(ctx) {
  let div;
  let t0;
  let a;
  let i;
  let t1;
  let t2_value = localize("ITEM-PILES.Inspect.AddCurrency") + "";
  let t2;
  let mounted;
  let dispose;
  let if_block = ctx[18] && create_if_block_5$6(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      i = element("i");
      t1 = space();
      t2 = text(t2_value);
      attr(i, "class", "fas fa-plus");
      attr(a, "class", "item-piles-text-right item-piles-small-text item-piles-middle item-piles-add-currency");
      attr(div, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      append(div, a);
      append(a, i);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[18])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$a, "create_if_block_4$a");
function create_if_block_5$6(ctx) {
  let a;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Trade.GMAddCurrency") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-plus");
      attr(a, "class", "item-piles-text-right item-piles-small-text item-piles-middle item-piles-gm-add-currency");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", ctx[23]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_5$6, "create_if_block_5$6");
function create_each_block_4$1(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding_1(value) {
    ctx[25](value, ctx[36], ctx[43], ctx[44]);
  }
  __name(tradeentry_data_binding_1, "tradeentry_data_binding_1");
  let tradeentry_props = {
    store: ctx[1],
    editable: ctx[1].isUserParticipant
  };
  if (ctx[36] !== void 0) {
    tradeentry_props.data = ctx[36];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding_1));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (dirty[0] & 2)
        tradeentry_changes.editable = ctx[1].isUserParticipant;
      if (!updating_data && dirty[0] & 32) {
        updating_data = true;
        tradeentry_changes.data = ctx[36];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block_4$1, "create_each_block_4$1");
function create_each_block_3$1(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding_2(value) {
    ctx[26](value, ctx[33], ctx[41], ctx[42]);
  }
  __name(tradeentry_data_binding_2, "tradeentry_data_binding_2");
  let tradeentry_props = {
    store: ctx[1],
    editable: ctx[1].isUserParticipant
  };
  if (ctx[33] !== void 0) {
    tradeentry_props.data = ctx[33];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding_2));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (dirty[0] & 2)
        tradeentry_changes.editable = ctx[1].isUserParticipant;
      if (!updating_data && dirty[0] & 64) {
        updating_data = true;
        tradeentry_changes.data = ctx[33];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block_3$1, "create_each_block_3$1");
function create_if_block_1$o(ctx) {
  let button;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block_2$l;
    return create_else_block$e;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "type", "button");
      set_style(button, "flex", "0 1 auto");
      set_style(button, "margin-top", "0.25rem");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", ctx[27]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$o, "create_if_block_1$o");
function create_else_block$e(ctx) {
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Trade.Accept") + "";
  let t1;
  return {
    c() {
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-check");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
__name(create_else_block$e, "create_else_block$e");
function create_if_block_2$l(ctx) {
  let i;
  let t0;
  let t1_value = localize("Cancel") + "";
  let t1;
  return {
    c() {
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-times");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
__name(create_if_block_2$l, "create_if_block_2$l");
function create_each_block_2$2(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding_3(value) {
    ctx[28](value, ctx[33], ctx[39], ctx[40]);
  }
  __name(tradeentry_data_binding_3, "tradeentry_data_binding_3");
  let tradeentry_props = { store: ctx[1], editable: false };
  if (ctx[33] !== void 0) {
    tradeentry_props.data = ctx[33];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding_3));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (!updating_data && dirty[0] & 128) {
        updating_data = true;
        tradeentry_changes.data = ctx[33];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block_2$2, "create_each_block_2$2");
function create_if_block$y(ctx) {
  let div;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ctx[8];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[36].path, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$8(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$8(key, child_ctx));
  }
  let each_value = ctx[9];
  const get_key_1 = /* @__PURE__ */ __name((ctx2) => ctx2[33].path, "get_key_1");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$m(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block$m(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "row item-piles-items-list item-piles-currency-list svelte-3zgsgo");
      toggle_class(div, "item-piles-top-divider", ctx[8].length || ctx[9].length);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div, null);
      }
      append(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 258) {
        each_value_1 = ctx2[8];
        group_outros();
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, div, outro_and_destroy_block, create_each_block_1$8, t, get_each_context_1$8);
        check_outros();
      }
      if (dirty[0] & 514) {
        each_value = ctx2[9];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, div, outro_and_destroy_block, create_each_block$m, null, get_each_context$m);
        check_outros();
      }
      if (!current || dirty[0] & 768) {
        toggle_class(div, "item-piles-top-divider", ctx2[8].length || ctx2[9].length);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$y, "create_if_block$y");
function create_each_block_1$8(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding_4(value) {
    ctx[29](value, ctx[36], ctx[37], ctx[38]);
  }
  __name(tradeentry_data_binding_4, "tradeentry_data_binding_4");
  let tradeentry_props = { store: ctx[1], editable: false };
  if (ctx[36] !== void 0) {
    tradeentry_props.data = ctx[36];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding_4));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (!updating_data && dirty[0] & 256) {
        updating_data = true;
        tradeentry_changes.data = ctx[36];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block_1$8, "create_each_block_1$8");
function create_each_block$m(key_1, ctx) {
  let first;
  let tradeentry;
  let updating_data;
  let current;
  function tradeentry_data_binding_5(value) {
    ctx[30](value, ctx[33], ctx[34], ctx[35]);
  }
  __name(tradeentry_data_binding_5, "tradeentry_data_binding_5");
  let tradeentry_props = { store: ctx[1], editable: false };
  if (ctx[33] !== void 0) {
    tradeentry_props.data = ctx[33];
  }
  tradeentry = new TradeEntry({ props: tradeentry_props });
  binding_callbacks.push(() => bind$1(tradeentry, "data", tradeentry_data_binding_5));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tradeentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tradeentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tradeentry_changes = {};
      if (dirty[0] & 2)
        tradeentry_changes.store = ctx[1];
      if (!updating_data && dirty[0] & 512) {
        updating_data = true;
        tradeentry_changes.data = ctx[33];
        add_flush_callback(() => updating_data = false);
      }
      tradeentry.$set(tradeentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tradeentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tradeentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(tradeentry, detaching);
    }
  };
}
__name(create_each_block$m, "create_each_block$m");
function create_default_slot_1$2(ctx) {
  let div12;
  let div11;
  let div5;
  let div2;
  let img0;
  let img0_src_value;
  let t0;
  let h20;
  let div0;
  let t1_value = ctx[1].leftTraderActor.name + "";
  let t1;
  let t2;
  let div1;
  let i0;
  let t3;
  let div4;
  let div3;
  let t4;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t5;
  let t6;
  let t7;
  let div10;
  let div7;
  let div6;
  let i1;
  let t8;
  let h21;
  let t9_value = ctx[1].rightTraderActor.name + "";
  let t9;
  let t10;
  let img1;
  let img1_src_value;
  let t11;
  let div9;
  let div8;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let current;
  let if_block0 = !ctx[4].length && ctx[1].isUserParticipant && create_if_block_6$4();
  let each_value_5 = ctx[4];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[33].id, "get_key");
  for (let i = 0; i < each_value_5.length; i += 1) {
    let child_ctx = get_each_context_5(ctx, each_value_5, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_5(key, child_ctx));
  }
  let if_block1 = ctx[19] && create_if_block_3$g(ctx);
  let if_block2 = ctx[1].isUserParticipant && create_if_block_1$o(ctx);
  let each_value_2 = ctx[7];
  const get_key_1 = /* @__PURE__ */ __name((ctx2) => ctx2[33].id, "get_key_1");
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2$2(ctx, each_value_2, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block_2$2(key, child_ctx));
  }
  let if_block3 = ctx[19] && create_if_block$y(ctx);
  return {
    c() {
      div12 = element("div");
      div11 = element("div");
      div5 = element("div");
      div2 = element("div");
      img0 = element("img");
      t0 = space();
      h20 = element("h2");
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      i0 = element("i");
      t3 = space();
      div4 = element("div");
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t4 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t5 = space();
      if (if_block1)
        if_block1.c();
      t6 = space();
      if (if_block2)
        if_block2.c();
      t7 = space();
      div10 = element("div");
      div7 = element("div");
      div6 = element("div");
      i1 = element("i");
      t8 = space();
      h21 = element("h2");
      t9 = text(t9_value);
      t10 = space();
      img1 = element("img");
      t11 = space();
      div9 = element("div");
      div8 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      if (if_block3)
        if_block3.c();
      if (!src_url_equal(img0.src, img0_src_value = ctx[1].leftTraderActor.img))
        attr(img0, "src", img0_src_value);
      attr(h20, "class", "character-name");
      attr(i0, "class", "fas accepted-icon");
      toggle_class(i0, "accepted", ctx[2]);
      toggle_class(i0, "fa-user-check", ctx[2]);
      toggle_class(i0, "fa-user-times", !ctx[2]);
      attr(div2, "class", "character-header item-piles-bottom-divider");
      attr(div3, "class", "row item-piles-items-list svelte-3zgsgo");
      attr(div4, "class", "item-piles-flexcol");
      attr(div5, "class", "col item-piles-flexcol svelte-3zgsgo");
      attr(i1, "class", "fas accepted-icon");
      toggle_class(i1, "accepted", ctx[3]);
      toggle_class(i1, "fa-user-check", ctx[3]);
      toggle_class(i1, "fa-user-times", !ctx[3]);
      attr(h21, "class", "character-name");
      if (!src_url_equal(img1.src, img1_src_value = ctx[1].rightTraderActor.img))
        attr(img1, "src", img1_src_value);
      attr(div7, "class", "character-header trader item-piles-bottom-divider");
      attr(div8, "class", "row item-piles-items-list svelte-3zgsgo");
      attr(div9, "class", "item-piles-flexcol");
      attr(div10, "class", "col item-piles-flexcol svelte-3zgsgo");
      attr(div11, "class", "item-piles-flexrow");
      attr(div12, "class", "item-piles-flexcol");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div11);
      append(div11, div5);
      append(div5, div2);
      append(div2, img0);
      append(div2, t0);
      append(div2, h20);
      append(h20, div0);
      append(div0, t1);
      append(div2, t2);
      append(div2, div1);
      append(div1, i0);
      append(div5, t3);
      append(div5, div4);
      append(div4, div3);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t4);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div3, null);
      }
      append(div4, t5);
      if (if_block1)
        if_block1.m(div4, null);
      append(div5, t6);
      if (if_block2)
        if_block2.m(div5, null);
      append(div11, t7);
      append(div11, div10);
      append(div10, div7);
      append(div7, div6);
      append(div6, i1);
      append(div7, t8);
      append(div7, h21);
      append(h21, t9);
      append(div7, t10);
      append(div7, img1);
      append(div10, t11);
      append(div10, div9);
      append(div9, div8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div8, null);
      }
      append(div9, t12);
      if (if_block3)
        if_block3.m(div9, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 2 && !src_url_equal(img0.src, img0_src_value = ctx2[1].leftTraderActor.img)) {
        attr(img0, "src", img0_src_value);
      }
      if ((!current || dirty[0] & 2) && t1_value !== (t1_value = ctx2[1].leftTraderActor.name + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & 4) {
        toggle_class(i0, "accepted", ctx2[2]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(i0, "fa-user-check", ctx2[2]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(i0, "fa-user-times", !ctx2[2]);
      }
      if (!ctx2[4].length && ctx2[1].isUserParticipant) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$4();
          if_block0.c();
          if_block0.m(div3, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 18) {
        each_value_5 = ctx2[4];
        group_outros();
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_5, each0_lookup, div3, outro_and_destroy_block, create_each_block_5, null, get_each_context_5);
        check_outros();
      }
      if (ctx2[19])
        if_block1.p(ctx2, dirty);
      if (ctx2[1].isUserParticipant) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$o(ctx2);
          if_block2.c();
          if_block2.m(div5, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & 8) {
        toggle_class(i1, "accepted", ctx2[3]);
      }
      if (!current || dirty[0] & 8) {
        toggle_class(i1, "fa-user-check", ctx2[3]);
      }
      if (!current || dirty[0] & 8) {
        toggle_class(i1, "fa-user-times", !ctx2[3]);
      }
      if ((!current || dirty[0] & 2) && t9_value !== (t9_value = ctx2[1].rightTraderActor.name + ""))
        set_data(t9, t9_value);
      if (!current || dirty[0] & 2 && !src_url_equal(img1.src, img1_src_value = ctx2[1].rightTraderActor.img)) {
        attr(img1, "src", img1_src_value);
      }
      if (dirty[0] & 130) {
        each_value_2 = ctx2[7];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_2, each1_lookup, div8, outro_and_destroy_block, create_each_block_2$2, null, get_each_context_2$2);
        check_outros();
      }
      if (ctx2[19])
        if_block3.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(if_block1);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(if_block1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block3)
        if_block3.d();
    }
  };
}
__name(create_default_slot_1$2, "create_default_slot_1$2");
function create_default_slot$i(ctx) {
  let t;
  let dropzone;
  let current;
  let if_block = ctx[2] && ctx[3] && create_if_block_7$1();
  dropzone = new DropZone({
    props: {
      callback: ctx[20],
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(dropzone.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(dropzone, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2] && ctx2[3]) {
        if (if_block) {
          if (dirty[0] & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7$1();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const dropzone_changes = {};
      if (dirty[0] & 1022 | dirty[1] & 65536) {
        dropzone_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropzone.$set(dropzone_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(dropzone.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(dropzone.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_component(dropzone, detaching);
    }
  };
}
__name(create_default_slot$i, "create_default_slot$i");
function create_fragment$G(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[31](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$i] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 1022 | dirty[1] & 65536) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$G, "create_fragment$G");
function instance$G($$self, $$props, $$invalidate) {
  let $leftTraderAccepted;
  let $rightTraderAccepted;
  let $leftItems;
  let $leftCurrencies;
  let $leftItemCurrencies;
  let $rightItems;
  let $rightCurrencies;
  let $rightItemCurrencies;
  let { elementRoot } = $$props;
  let { store } = $$props;
  const leftItems = store.leftTraderItems;
  component_subscribe($$self, leftItems, (value) => $$invalidate(4, $leftItems = value));
  const leftCurrencies = store.leftTraderCurrencies;
  component_subscribe($$self, leftCurrencies, (value) => $$invalidate(5, $leftCurrencies = value));
  const leftItemCurrencies = store.leftTraderItemCurrencies;
  component_subscribe($$self, leftItemCurrencies, (value) => $$invalidate(6, $leftItemCurrencies = value));
  const leftTraderAccepted = store.leftTraderAccepted;
  component_subscribe($$self, leftTraderAccepted, (value) => $$invalidate(2, $leftTraderAccepted = value));
  const rightItems = store.rightTraderItems;
  component_subscribe($$self, rightItems, (value) => $$invalidate(7, $rightItems = value));
  const rightCurrencies = store.rightTraderCurrencies;
  component_subscribe($$self, rightCurrencies, (value) => $$invalidate(8, $rightCurrencies = value));
  const rightItemCurrencies = store.rightTraderItemCurrencies;
  component_subscribe($$self, rightItemCurrencies, (value) => $$invalidate(9, $rightItemCurrencies = value));
  const rightTraderAccepted = store.rightTraderAccepted;
  component_subscribe($$self, rightTraderAccepted, (value) => $$invalidate(3, $rightTraderAccepted = value));
  let isGM = game.user.isGM;
  let systemHasCurrencies = game.itempiles.API.CURRENCIES.length > 0;
  async function dropItem(data) {
    if (data.type !== "Item")
      return;
    let item = await Item.implementation.fromDropData(data);
    data.actorId = item.parent?.id;
    if (!data.actorId && !game.user.isGM) {
      return custom_warning(game.i18n.localize("ITEM-PILES.Errors.NoSourceDrop"), true);
    }
    if (!game.user.isGM && data.actorId && data.actorId !== store.leftTraderActor.id) {
      throw custom_error(`You cannot drop items into the trade UI from a different actor than ${store.leftTraderActor.name}!`);
    }
    const validItem = await checkItemType(store.rightTraderActor, item, {
      errorText: "ITEM-PILES.Errors.DisallowedItemTrade",
      warningTitle: "ITEM-PILES.Dialogs.TypeWarning.Title",
      warningContent: "ITEM-PILES.Dialogs.TypeWarning.TradeContent"
    });
    if (!validItem)
      return;
    const actorItemCurrencyList = getCurrencyList(store.leftTraderActor).filter((entry) => entry.type !== "attribute");
    const isCurrency = !!findSimilarItem(actorItemCurrencyList.map((item2) => item2.data), validItem);
    if (!validItem.id) {
      validItem.id = item.id;
    }
    return store.addItem(validItem, { currency: isCurrency });
  }
  __name(dropItem, "dropItem");
  if (store.isUserParticipant) {
    const itemsUpdatedDebounce = debounce(
      async (items) => {
        await ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.PRIVATE_TRADE_UPDATE_ITEMS, [store.leftTraderUser.id, store.rightTraderUser.id], store.privateTradeId, game.user.id, items);
        return executeSocketAction(ItemPileSocket.HANDLERS.PUBLIC_TRADE_UPDATE_ITEMS, store.publicTradeId, game.user.id, items);
      },
      20
    );
    leftItems.subscribe(itemsUpdatedDebounce);
    const itemCurrenciesUpdatedDebounce = debounce(
      async (items) => {
        await ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.PRIVATE_TRADE_UPDATE_ITEM_CURRENCIES, [store.leftTraderUser.id, store.rightTraderUser.id], store.privateTradeId, game.user.id, items);
        return executeSocketAction(ItemPileSocket.HANDLERS.PUBLIC_TRADE_UPDATE_ITEM_CURRENCIES, store.publicTradeId, game.user.id, items);
      },
      20
    );
    leftItemCurrencies.subscribe(itemCurrenciesUpdatedDebounce);
    const attributesUpdatedDebounce = debounce(
      async (attributes2) => {
        await ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.PRIVATE_TRADE_UPDATE_CURRENCIES, [store.leftTraderUser.id, store.rightTraderUser.id], store.privateTradeId, game.user.id, attributes2);
        return executeSocketAction(ItemPileSocket.HANDLERS.PUBLIC_TRADE_UPDATE_CURRENCIES, store.publicTradeId, game.user.id, attributes2);
      },
      40
    );
    leftCurrencies.subscribe(attributesUpdatedDebounce);
    const acceptedDebounce = debounce(
      async (acceptedState) => {
        await ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.PRIVATE_TRADE_STATE, [store.leftTraderUser.id, store.rightTraderUser.id], store.privateTradeId, game.user.id, acceptedState);
        return executeSocketAction(ItemPileSocket.HANDLERS.PUBLIC_TRADE_STATE, store.publicTradeId, game.user.id, acceptedState);
      },
      10
    );
    leftTraderAccepted.subscribe(acceptedDebounce);
  }
  async function executeSocketAction(socketHandler, ...args) {
    if (store.isPrivate) {
      return ItemPileSocket.executeForUsers(socketHandler, [store.leftTraderUser.id, store.rightTraderUser.id], ...args);
    }
    return ItemPileSocket.executeForEveryone(socketHandler, ...args);
  }
  __name(executeSocketAction, "executeSocketAction");
  async function addCurrency(asGM = false) {
    const currenciesToAdd = await DropCurrencyDialog.show(store.leftTraderActor, store.rightTraderActor, {
      existingCurrencies: store.getExistingCurrencies(),
      title: game.i18n.localize("ITEM-PILES.Trade.AddCurrency.Title"),
      content: game.i18n.format("ITEM-PILES.Trade.AddCurrency.Content", {
        trader_actor_name: store.rightTraderActor.name
      }),
      button: game.i18n.localize("ITEM-PILES.Trade.AddCurrency.Label"),
      unlimitedCurrencies: asGM
    });
    if (!currenciesToAdd || foundry.utils.isEmpty(currenciesToAdd.attributes) && !currenciesToAdd.items.length)
      return;
    currenciesToAdd.items.forEach((item) => {
      const itemData = store.leftTraderActor.items.get(item._id).toObject();
      store.addItem(itemData, { quantity: item.quantity, currency: true });
    });
    const currencies = getActorCurrencies(store.leftTraderActor, { getAll: asGM }).filter((currency) => currency.type === "attribute");
    Object.entries(currenciesToAdd.attributes).forEach(([path, quantity]) => {
      const currency = currencies.find((currency2) => currency2.path === path);
      store.addAttribute({
        path,
        quantity,
        newQuantity: quantity,
        name: currency.name,
        img: currency.img,
        maxQuantity: !game.user.isGM ? currency.quantity : Infinity,
        index: currency.index
      });
    });
  }
  __name(addCurrency, "addCurrency");
  function tradeentry_data_binding(value, item, each_value_5, item_index_3) {
    each_value_5[item_index_3] = value;
    leftItems.set($leftItems);
  }
  __name(tradeentry_data_binding, "tradeentry_data_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    addCurrency(true);
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    addCurrency();
  }, "click_handler_1");
  function tradeentry_data_binding_1(value, currency, each_value_4, currency_index_1) {
    each_value_4[currency_index_1] = value;
    leftCurrencies.set($leftCurrencies);
  }
  __name(tradeentry_data_binding_1, "tradeentry_data_binding_1");
  function tradeentry_data_binding_2(value, item, each_value_3, item_index_2) {
    each_value_3[item_index_2] = value;
    leftItemCurrencies.set($leftItemCurrencies);
  }
  __name(tradeentry_data_binding_2, "tradeentry_data_binding_2");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    store.toggleAccepted(store.leftTraderUser.id);
  }, "click_handler_2");
  function tradeentry_data_binding_3(value, item, each_value_2, item_index_1) {
    each_value_2[item_index_1] = value;
    rightItems.set($rightItems);
  }
  __name(tradeentry_data_binding_3, "tradeentry_data_binding_3");
  function tradeentry_data_binding_4(value, currency, each_value_1, currency_index) {
    each_value_1[currency_index] = value;
    rightCurrencies.set($rightCurrencies);
  }
  __name(tradeentry_data_binding_4, "tradeentry_data_binding_4");
  function tradeentry_data_binding_5(value, item, each_value, item_index) {
    each_value[item_index] = value;
    rightItemCurrencies.set($rightItemCurrencies);
  }
  __name(tradeentry_data_binding_5, "tradeentry_data_binding_5");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("store" in $$props2)
      $$invalidate(1, store = $$props2.store);
  };
  return [
    elementRoot,
    store,
    $leftTraderAccepted,
    $rightTraderAccepted,
    $leftItems,
    $leftCurrencies,
    $leftItemCurrencies,
    $rightItems,
    $rightCurrencies,
    $rightItemCurrencies,
    leftItems,
    leftCurrencies,
    leftItemCurrencies,
    leftTraderAccepted,
    rightItems,
    rightCurrencies,
    rightItemCurrencies,
    rightTraderAccepted,
    isGM,
    systemHasCurrencies,
    dropItem,
    addCurrency,
    tradeentry_data_binding,
    click_handler,
    click_handler_1,
    tradeentry_data_binding_1,
    tradeentry_data_binding_2,
    click_handler_22,
    tradeentry_data_binding_3,
    tradeentry_data_binding_4,
    tradeentry_data_binding_5,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$G, "instance$G");
class Trading_app_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$G, safe_not_equal, { elementRoot: 0, store: 1 }, null, [-1, -1]);
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get store() {
    return this.$$.ctx[1];
  }
  set store(store) {
    this.$$set({ store });
    flush();
  }
}
__name(Trading_app_shell, "Trading_app_shell");
class TradingApp extends SvelteApplication {
  constructor(store, options = {}, dialogData = {}) {
    super({
      title: game.i18n.format("ITEM-PILES.Trade.Between", {
        actor_1: store.leftTraderActor.name,
        actor_2: store.rightTraderActor.name
      }),
      svelte: {
        class: Trading_app_shell,
        target: document.body,
        props: {
          store
        }
      },
      ...options
    }, dialogData);
    this.store = store;
    this.publicTradeId = store.publicTradeId;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      zIndex: 100,
      classes: ["dialog", "item-piles-trading-sheet", "item-piles"],
      width: 800,
      height: "auto",
      closeOnSubmit: false
    });
  }
  async close(options = {}) {
    if (!options?.callback && this.store.isUserParticipant) {
      await ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.TRADE_CLOSED, this.publicTradeId, game.user.id);
    }
    return super.close(options);
  }
  static getActiveApp(publicTradeId) {
    for (const app of Object.values(ui.windows)) {
      if (app instanceof this && app?.publicTradeId === publicTradeId) {
        return app;
      }
    }
    return false;
  }
}
__name(TradingApp, "TradingApp");
class Transaction {
  constructor(actor) {
    this.actor = actor;
    this.itemsToCreate = [];
    this.itemsToUpdate = [];
    this.itemsToDelete = [];
    this.itemsToForceDelete = /* @__PURE__ */ new Set();
    this.itemsToNotDelete = /* @__PURE__ */ new Set();
    this.actorUpdates = {};
    this.attributeDeltas = /* @__PURE__ */ new Map();
    this.attributeTypeMap = /* @__PURE__ */ new Map();
    this.itemDeltas = /* @__PURE__ */ new Map();
    this.itemTypeMap = /* @__PURE__ */ new Map();
    this.preCommitted = false;
  }
  async appendItemChanges(items, { remove = false, type = "item", keepIfZero = false } = {}) {
    for (let data of items) {
      let item = data.item ?? data;
      let itemData = item instanceof Item ? item.toObject() : foundry.utils.duplicate(item);
      if (SYSTEMS.DATA.ITEM_TRANSFORMER && !remove) {
        itemData = await SYSTEMS.DATA.ITEM_TRANSFORMER(itemData);
      }
      const incomingQuantity = Math.abs(data.quantity ?? getItemQuantity(itemData)) * (remove ? -1 : 1);
      const actorExistingItem = findSimilarItem(this.actor.items, itemData);
      const canItemStack$1 = canItemStack(actorExistingItem ?? itemData);
      if (!canItemStack$1) {
        if (remove && actorExistingItem) {
          this.itemTypeMap.set(actorExistingItem.id, type);
          this.itemsToForceDelete.add(actorExistingItem.id);
          this.itemDeltas.set(actorExistingItem.id, -1);
        } else {
          if (!itemData._id) {
            itemData._id = randomID();
          }
          this.itemTypeMap.set(itemData._id, type);
          this.itemsToCreate.push(itemData);
        }
      } else if (actorExistingItem) {
        const existingItemUpdate = remove ? this.itemsToUpdate.find((item2) => item2._id === itemData._id) : findSimilarItem(this.itemsToUpdate, itemData);
        if (keepIfZero || type === "currency") {
          this.itemsToNotDelete.add(item.id);
        }
        if (existingItemUpdate) {
          const newQuantity = getItemQuantity(existingItemUpdate) + incomingQuantity;
          setItemQuantity(existingItemUpdate, newQuantity);
          if (keepIfZero && type !== "currency") {
            setProperty(existingItemUpdate, CONSTANTS.FLAGS.ITEM + ".notForSale", newQuantity === 0);
          }
        } else {
          const newQuantity = getItemQuantity(actorExistingItem) + incomingQuantity;
          const update2 = setItemQuantity({ _id: actorExistingItem.id }, newQuantity);
          if (keepIfZero && type !== "currency") {
            setProperty(update2, CONSTANTS.FLAGS.ITEM + ".notForSale", newQuantity === 0);
          }
          this.itemTypeMap.set(actorExistingItem.id, type);
          this.itemsToUpdate.push(update2);
          this.itemDeltas.set(
            actorExistingItem.id,
            (this.itemDeltas.has(actorExistingItem.id) ? this.itemDeltas.get(actorExistingItem.id) : 0) + incomingQuantity
          );
        }
      } else {
        if (!itemData._id) {
          itemData._id = randomID();
        }
        const existingItemCreation = findSimilarItem(this.itemsToCreate, itemData);
        if (existingItemCreation) {
          const newQuantity = getItemQuantity(existingItemCreation) + incomingQuantity;
          setItemQuantity(existingItemCreation, newQuantity);
        } else {
          setItemQuantity(itemData, incomingQuantity);
          this.itemsToCreate.push(itemData);
          this.itemTypeMap.set(itemData._id, type);
        }
      }
    }
  }
  async appendActorChanges(attributes2, { remove = false, type = "attribute" } = {}) {
    if (!Array.isArray(attributes2)) {
      attributes2 = Object.entries(attributes2).map((entry) => ({ path: entry[0], quantity: entry[1] }));
    }
    this.actorUpdates = attributes2.reduce((acc, attribute) => {
      const incomingQuantity = Math.abs(attribute.quantity) * (remove ? -1 : 1);
      acc[attribute.path] = acc[attribute.path] ?? Number(getProperty(this.actor, attribute.path));
      acc[attribute.path] += incomingQuantity;
      this.attributeDeltas.set(
        attribute.path,
        (this.attributeDeltas.has(attribute.path) ? this.attributeDeltas.get(attribute.path) : 0) + incomingQuantity
      );
      this.attributeTypeMap.set(attribute.path, type);
      return acc;
    }, this.actorUpdates);
  }
  prepare() {
    this.actorUpdates = Object.fromEntries(Object.entries(this.actorUpdates).filter((entry) => {
      if (this.attributeDeltas.get(entry[0]) === 0) {
        this.attributeDeltas.delete(entry[0]);
      }
      return Number(getProperty(this.actor, entry[0])) !== entry[1];
    }));
    this.itemsToCreate = this.itemsToCreate.filter((item) => {
      return !canItemStack(item) || getItemQuantity(item) > 0 || this.itemTypeMap.get(item._id) === "currency";
    });
    this.itemsToDelete = this.itemsToUpdate.filter((item) => {
      return getItemQuantity(item) <= 0 && this.itemTypeMap.get(item._id) !== "currency";
    }).map((item) => item._id).concat(Array.from(this.itemsToForceDelete));
    for (const itemId of this.itemsToDelete) {
      if (this.itemsToNotDelete.has(itemId)) {
        this.itemsToDelete.splice(this.itemsToDelete.indexOf(itemId), 1);
      }
    }
    this.itemDeltas = Array.from(this.itemDeltas).map(([id, quantity]) => {
      const item = this.actor.items.get(id).toObject();
      const type = this.itemTypeMap.get(id);
      setItemQuantity(item, quantity, true);
      return { item, quantity, type };
    }).filter((delta) => delta.quantity);
    this.itemsToUpdate = this.itemsToUpdate.filter((item) => getItemQuantity(item) > 0 || this.itemsToNotDelete.has(item._id) || this.itemTypeMap.get(item._id) === "currency").filter((itemData) => {
      const item = this.actor.items.get(itemData._id);
      return getItemQuantity(item) !== getItemQuantity(itemData);
    });
    this.attributeDeltas = Object.fromEntries(this.attributeDeltas);
    this.preCommitted = true;
    return {
      actorUpdates: this.actorUpdates,
      itemsToCreate: this.itemsToCreate,
      itemsToDelete: this.itemsToDelete,
      itemsToUpdate: this.itemsToUpdate,
      attributeDeltas: this.attributeDeltas,
      itemDeltas: this.itemDeltas
    };
  }
  async commit() {
    if (!this.preCommitted) {
      this.prepare();
    }
    let itemsCreated;
    const actorUuid = getUuid(this.actor);
    if (this.actor.isOwner) {
      itemsCreated = await PrivateAPI._commitActorChanges(actorUuid, this.actorUpdates, this.itemsToUpdate, this.itemsToDelete, this.itemsToCreate);
    } else {
      itemsCreated = await ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.COMMIT_ACTOR_CHANGES, actorUuid, this.actorUpdates, this.itemsToUpdate, this.itemsToDelete, this.itemsToCreate);
    }
    return {
      attributeDeltas: this.attributeDeltas,
      itemDeltas: this.itemDeltas.concat(itemsCreated.map((item) => {
        return {
          item,
          quantity: canItemStack(item) ? getItemQuantity(item) : 1
        };
      }))
    };
  }
}
__name(Transaction, "Transaction");
const mutedUsers = /* @__PURE__ */ new Set();
const ongoingTrades = /* @__PURE__ */ new Map();
class TradeAPI {
  static initialize() {
    Hooks.on("renderPlayerList", this._userDisconnected.bind(this));
  }
  static async _requestTrade(user = false) {
    const users = game.users.filter((user2) => user2.active && user2 !== game.user);
    if (!users.length) {
      return TJSDialog.prompt({
        title: game.i18n.localize("ITEM-PILES.Trade.Title"),
        content: {
          class: CustomDialog,
          props: {
            header: game.i18n.localize("ITEM-PILES.Trade.NoActiveUsers.Title"),
            content: game.i18n.localize("ITEM-PILES.Trade.NoActiveUsers.Content"),
            icon: "fas fa-heart-broken"
          }
        },
        modal: true,
        draggable: false,
        options: {
          height: "auto"
        }
      });
    }
    let userId;
    let actor;
    let isPrivate;
    const actors = game.actors.filter((actor2) => actor2.isOwner);
    if (actors.length === 1 && user) {
      userId = user.id;
      actor = actors[0];
      isPrivate = false;
    } else {
      const result = await TradePromptDialog.show({ actors, users, user });
      if (!result)
        return;
      userId = result.user.id;
      actor = result.actor;
      isPrivate = result.private;
    }
    if (!actor)
      return false;
    actor = actor?.actor ?? actor;
    const actorOwner = game.users.find((user2) => user2.character === actor && user2 !== game.user);
    if (actorOwner) {
      const doContinue = TJSDialog.confirm({
        title: game.i18n.localize("ITEM-PILES.Trade.Title"),
        content: {
          class: CustomDialog,
          props: {
            header: game.i18n.localize("ITEM-PILES.Trade.Title"),
            content: actorOwner.active ? game.i18n.format("ITEM-PILES.Trade.UserActiveCharacterWarning", {
              actor_name: actor.name,
              player_name: actorOwner.name
            }) : game.i18n.format("ITEM-PILES.Trade.UserCharacterWarning", {
              actor_name: actor.name,
              player_name: actorOwner.name
            }),
            icon: "fas fa-exclamation-triangle"
          }
        },
        modal: true,
        draggable: false,
        rejectClose: false,
        defaultYes: true,
        options: {
          height: "auto"
        }
      });
      if (!doContinue) {
        return;
      }
    }
    const privateTradeId = randomID();
    const publicTradeId = randomID();
    const cancelDialog = new Dialog({
      title: game.i18n.localize("ITEM-PILES.Trade.Title"),
      content: `<p style="text-align: center">${game.i18n.format("ITEM-PILES.Trade.OngoingRequest.Content", { user_name: game.users.get(userId).name })}</p>`,
      buttons: {
        confirm: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("ITEM-PILES.Trade.OngoingRequest.Label"),
          callback: () => {
            ItemPileSocket.executeAsUser(ItemPileSocket.HANDLERS.TRADE_REQUEST_CANCELLED, userId, game.user.id, privateTradeId);
          }
        }
      }
    }, {
      top: 50,
      width: 300
    }).render(true);
    return ItemPileSocket.executeAsUser(ItemPileSocket.HANDLERS.TRADE_REQUEST_PROMPT, userId, game.user.id, actor.uuid, privateTradeId, publicTradeId, isPrivate).then(async (data) => {
      if (data === "cancelled")
        return;
      cancelDialog.close();
      if (data === "same-actor") {
        return custom_warning(game.i18n.localize("ITEM-PILES.Trade.SameActor"), true);
      }
      if (!data || !data.fullPrivateTradeId.includes(privateTradeId)) {
        return custom_warning(game.i18n.localize("ITEM-PILES.Trade.Declined"), true);
      }
      const traderActor = getActor(data.actorUuid);
      if (traderActor === actor) {
        return custom_warning(game.i18n.localize("ITEM-PILES.Trade.SameActor"), true);
      }
      const store = new TradeStore({
        user: game.user,
        actor
      }, {
        user: game.users.get(userId),
        actor: traderActor
      }, data.fullPublicTradeId, data.fullPrivateTradeId, isPrivate);
      const app = new TradingApp(store, this.getAppOptions(actor).tradeApp).render(true);
      ongoingTrades.set(data.fullPublicTradeId, { app, store });
      actor.sheet.render(true, this.getAppOptions(actor).actorSheet);
      if (isPrivate) {
        return ItemPileSocket.callHookForUsers(HOOKS.TRADE.STARTED, [game.user.id, userId], {
          user: game.user.id,
          actor: actor.uuid
        }, { user: userId, actor: data.actorUuid }, data.fullPublicTradeId, isPrivate);
      }
      return ItemPileSocket.callHook(HOOKS.TRADE.STARTED, {
        user: game.user.id,
        actor: actor.uuid
      }, { user: userId, actor: data.actorUuid }, data.fullPublicTradeId, isPrivate);
    }).catch((err) => {
      console.error(err);
      custom_warning(game.i18n.localize("ITEM-PILES.Trade.Disconnected"), true);
      cancelDialog.close();
    });
  }
  static async _respondPrompt(tradingUserId, tradingActorUuid, privateTradeId, publicTradeId, isPrivate) {
    if (mutedUsers.has(tradingUserId)) {
      await wait$1(Math.random() * 15e3);
      return false;
    }
    const fullPrivateTradeId = privateTradeId + randomID();
    const fullPublicTradeId = publicTradeId + randomID();
    const tradingUser = game.users.get(tradingUserId);
    let tradingActor = fromUuidSync(tradingActorUuid);
    tradingActor = tradingActor?.actor ?? tradingActor;
    const result = await TradeRequestDialog.show({ tradeId: privateTradeId, tradingUser, tradingActor, isPrivate });
    if (!result)
      return false;
    if (result === "cancelled") {
      return "cancelled";
    }
    if (result === "mute") {
      mutedUsers.push(tradingUserId);
      return false;
    }
    const actor = result.actor ?? result;
    if (actor === tradingActor) {
      custom_warning(game.i18n.localize("ITEM-PILES.Trade.SameActor"), true);
      return "same-actor";
    }
    const store = new TradeStore({ user: game.user, actor }, {
      user: tradingUser,
      actor: tradingActor
    }, fullPublicTradeId, fullPrivateTradeId, isPrivate);
    const app = new TradingApp(store, this.getAppOptions(actor).tradeApp).render(true);
    ongoingTrades.set(fullPublicTradeId, { app, store });
    actor.sheet.render(true, this.getAppOptions(actor).actorSheet);
    return {
      fullPrivateTradeId,
      fullPublicTradeId,
      actorUuid: result.uuid
    };
  }
  static getAppOptions(actor) {
    const midPoint = window.innerWidth / 2 - 200;
    return {
      actorSheet: { left: midPoint - actor.sheet.position.width - 25 },
      tradeApp: { left: midPoint + 25 }
    };
  }
  static async _tradeCancelled(userId, privateTradeId) {
    TJSDialog.prompt({
      title: game.i18n.localize("ITEM-PILES.Trade.Title"),
      content: {
        class: CustomDialog,
        props: {
          header: game.i18n.localize("ITEM-PILES.Trade.Title"),
          content: game.i18n.format("ITEM-PILES.Trade.CancelledRequest.Content", { user_name: game.users.get(userId).name }),
          icon: "fas fa-exclamation-triangle"
        }
      },
      modal: true,
      draggable: false,
      options: {
        height: "auto"
      }
    });
    return TradeRequestDialog.cancel(privateTradeId);
  }
  static async _requestTradeData({ tradeId, tradeUser } = {}) {
    const ongoingTrade = this._getOngoingTrade(tradeId);
    if (ongoingTrade) {
      return ongoingTrade.store.export();
    }
    const user = game.users.get(tradeUser);
    if (!user?.active) {
      return false;
    }
    const ongoingTradeData = await ItemPileSocket.executeAsUser(ItemPileSocket.HANDLERS.REQUEST_TRADE_DATA, tradeUser, tradeId, game.user.id);
    if (!ongoingTradeData) {
      return false;
    }
    return ongoingTradeData;
  }
  static async _spectateTrade({ tradeId, tradeUser } = {}) {
    const existingApp = TradingApp.getActiveApp(tradeId);
    if (existingApp) {
      return existingApp.render(false, { focus: true });
    }
    const ongoingTradeData = await this._requestTradeData({ tradeId, tradeUser });
    if (!ongoingTradeData) {
      if (isGMConnected()) {
        ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DISABLE_CHAT_TRADE_BUTTON, tradeId);
      }
      return custom_warning(game.i18n.localize("ITEM-PILES.Trade.Over"), true);
    }
    const store = TradeStore.import(...ongoingTradeData);
    const app = new TradingApp(store).render(true);
    ongoingTrades.set(store.publicTradeId, { app, store });
  }
  static async _respondActiveTradeData(tradeId, requesterId) {
    const trade = this._getOngoingTrade(tradeId, requesterId);
    if (!trade)
      return;
    return trade.store.export();
  }
  static _getOngoingTrade(tradeId, requesterId = game.user.id) {
    if (!ongoingTrades.has(tradeId))
      return false;
    const trade = ongoingTrades.get(tradeId);
    if (!trade.store.isPrivate) {
      return trade;
    }
    if (trade.store.leftTraderUser.id !== requesterId && trade.store.rightTraderUser.id !== requesterId)
      return false;
    return trade;
  }
  static async _updateItems(tradeId, userId, items) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    trade.store.updateItems(userId, items);
  }
  static async _updateItemCurrencies(tradeId, userId, items) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    trade.store.updateItemCurrencies(userId, items);
  }
  static async _updateCurrencies(tradeId, userId, currencies) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    trade.store.updateCurrencies(userId, currencies);
  }
  static async _updateAcceptedState(tradeId, userId, status) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    trade.store.updateAcceptedState(userId, status);
    if (userId === game.user.id && (trade.store.leftTraderUser.id === game.user.id || trade.store.rightTraderUser.id === game.user.id)) {
      if (trade.store.tradeIsAccepted) {
        setTimeout(async () => {
          if (trade.store.tradeIsAccepted) {
            ItemPileSocket.executeForUsers(
              ItemPileSocket.HANDLERS.EXECUTE_TRADE,
              [trade.store.leftTraderUser.id, trade.store.rightTraderUser.id],
              trade.store.publicTradeId,
              trade.store.privateTradeId,
              userId
            );
          }
        }, 2e3);
      }
    }
  }
  static async _userDisconnected() {
    const tradesToDelete = [];
    const activeUsers = game.users.filter((user) => user.active);
    for (let [tradeId, trade] of ongoingTrades) {
      const foundLeft = activeUsers.find((u) => u === trade.store.leftTraderUser);
      const foundRight = activeUsers.find((u) => u === trade.store.rightTraderUser);
      if (foundLeft && foundRight)
        continue;
      tradesToDelete.push(tradeId);
      custom_warning(game.i18n.localize("ITEM-PILES.Trade.Disconnected"), true);
      await trade.app.close({ callback: true });
      if (foundLeft === game.user || foundRight === game.user) {
        if (isGMConnected()) {
          await ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DISABLE_CHAT_TRADE_BUTTON, tradeId);
        }
      }
    }
    tradesToDelete.forEach((tradeId) => ongoingTrades.delete(tradeId));
  }
  static async _tradeClosed(tradeId, closeUserId) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    if (trade.store.leftTraderUser.id === game.user.id || trade.store.rightTraderUser.id === game.user.id) {
      if (closeUserId === trade.store.rightTraderUser.id) {
        TJSDialog.prompt({
          title: game.i18n.localize("ITEM-PILES.Trade.Closed.Title"),
          content: {
            class: CustomDialog,
            props: {
              header: game.i18n.localize("ITEM-PILES.Trade.Closed.Title"),
              content: game.i18n.format("ITEM-PILES.Trade.Closed.Them", {
                user_name: trade.store.rightTraderUser.name
              }),
              icon: "fas fa-exclamation-triangle"
            }
          },
          modal: false,
          draggable: true,
          options: {
            height: "auto"
          }
        });
      } else {
        if (trade.store.isPrivate) {
          const otherUserId = trade.store.leftTraderUser.id === game.user.id ? trade.store.rightTraderUser.id : trade.store.leftTraderUser.id;
          ItemPileSocket.executeAsUser(ItemPileSocket.HANDLERS.TRADE_CLOSED, otherUserId, tradeId, game.user.id);
        } else {
          ItemPileSocket.executeForOthers(ItemPileSocket.HANDLERS.TRADE_CLOSED, tradeId, game.user.id);
        }
        TJSDialog.prompt({
          title: game.i18n.localize("ITEM-PILES.Trade.Closed.Title"),
          content: {
            class: CustomDialog,
            props: {
              header: game.i18n.localize("ITEM-PILES.Trade.Closed.Title"),
              content: game.i18n.format("ITEM-PILES.Trade.Closed.You"),
              icon: "fas fa-exclamation-triangle"
            }
          },
          modal: false,
          draggable: true,
          options: {
            height: "auto"
          }
        });
        if (isGMConnected()) {
          await ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DISABLE_CHAT_TRADE_BUTTON, tradeId);
        }
      }
    } else {
      custom_warning(game.i18n.localize("ITEM-PILES.Trade.Closed.Someone"), true);
    }
    trade.app.close({ callback: true });
    ongoingTrades.delete(tradeId);
  }
  static async _executeTrade(tradeId, privateId, userId) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    if (trade.store.privateTradeId !== privateId)
      return;
    const updates = trade.store.getTradeData();
    const itemsToAdd = updates.add.items.map((entry) => {
      const itemData = updates.targetActor.items.get(entry.id).toObject();
      return setItemQuantity(itemData, entry.quantity, true);
    });
    const itemsToRemove = updates.remove.items.map((entry) => {
      const itemData = updates.sourceActor.items.get(entry.id).toObject();
      return setItemQuantity(itemData, entry.quantity, true);
    });
    const transaction = new Transaction(updates.sourceActor);
    await transaction.appendItemChanges(itemsToAdd);
    await transaction.appendItemChanges(itemsToRemove, { remove: true });
    await transaction.appendActorChanges(updates.add.attributes);
    await transaction.appendActorChanges(updates.remove.attributes, { remove: true });
    await transaction.commit();
    if (trade.store.isPrivate) {
      trade.app.close({ callback: true });
      ongoingTrades.delete(tradeId);
    } else if (userId === game.user.id) {
      if (isGMConnected()) {
        await ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DISABLE_CHAT_TRADE_BUTTON, tradeId);
      }
      return ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.TRADE_COMPLETED, tradeId, updates);
    }
  }
  static async _tradeCompleted(tradeId, updates) {
    const trade = this._getOngoingTrade(tradeId);
    if (!trade)
      return;
    hooks.callAll(HOOKS.TRADE.COMPLETE, updates, tradeId);
    trade.app.close({ callback: true });
    ongoingTrades.delete(tradeId);
  }
}
__name(TradeAPI, "TradeAPI");
class ChatAPI {
  static initialize() {
    Hooks.on("preCreateChatMessage", this._preCreateChatMessage.bind(this));
    Hooks.on("renderChatMessage", this._renderChatMessage.bind(this));
    Hooks.on(HOOKS.ITEM.TRANSFER, this._outputTransferItem.bind(this));
    Hooks.on(HOOKS.ATTRIBUTE.TRANSFER, this._outputTransferCurrency.bind(this));
    Hooks.on(HOOKS.TRANSFER_EVERYTHING, this._outputTransferEverything.bind(this));
    Hooks.on(HOOKS.PILE.SPLIT_INVENTORY, this._outputSplitItemPileInventory.bind(this));
    Hooks.on(HOOKS.TRADE.STARTED, this._outputTradeStarted.bind(this));
    Hooks.on(HOOKS.TRADE.COMPLETE, this._outputTradeComplete.bind(this));
    Hooks.on(HOOKS.ITEM.TRADE, this._outputMerchantTradeComplete.bind(this));
    $(document).on("click", ".item-piles-chat-card .item-piles-collapsible", async function() {
      if ($(this).attr("open"))
        return;
      await wait$1(25);
      $(this).parent()[0].scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
    });
  }
  static _preCreateChatMessage(chatMessage) {
    if (!getSetting(SETTINGS.ENABLE_TRADING))
      return;
    const content = chatMessage.content.toLowerCase();
    if (!(content.startsWith("!itempiles") || content.startsWith("!ip")))
      return;
    const args = content.split(" ").slice(1);
    if (args[0] === "trade") {
      setTimeout(() => {
        game.itempiles.API.requestTrade();
      });
    }
    return false;
  }
  static _renderChatMessage(app, html) {
    html.find(".item-piles-specate-trade").click(function() {
      game.itempiles.API.spectateTrade($(this).data());
    });
  }
  static _disableTradingButton(publicTradeId) {
    const message = Array.from(game.messages).find((message2) => {
      return getProperty(message2, CONSTANTS.FLAGS.PUBLIC_TRADE_ID) === publicTradeId;
    });
    if (!message)
      return;
    const update2 = this._replaceChatContent(message);
    return message.update(update2);
  }
  static async disablePastTradingButtons() {
    if (!game.user.isGM)
      return;
    const messages = Array.from(game.messages).filter((message) => {
      return getProperty(message, CONSTANTS.FLAGS.PUBLIC_TRADE_ID);
    });
    if (!messages.length)
      return;
    const updates = [];
    for (let message of messages) {
      const update2 = this._replaceChatContent(message);
      const tradeId = getProperty(message, CONSTANTS.FLAGS.PUBLIC_TRADE_ID);
      const tradeUsers = getProperty(message, CONSTANTS.FLAGS.TRADE_USERS);
      const bothUsersActive = tradeUsers.filter((userId) => game.users.get(userId).active).length === tradeUsers.length;
      if (!bothUsersActive) {
        updates.push(update2);
      } else {
        const otherUsers = tradeUsers.filter((userId) => userId !== game.user.id);
        const tradeData = await TradeAPI._requestTradeData({ tradeId, tradeUser: otherUsers[0] });
        if (!tradeData) {
          updates.push(update2);
        }
      }
    }
    if (!updates.length)
      return;
    return ChatMessage.updateDocuments(updates);
  }
  static _replaceChatContent(message) {
    const tradeId = getProperty(message, CONSTANTS.FLAGS.PUBLIC_TRADE_ID);
    const stringToFind = `data-trade-id="${tradeId}"`;
    let content = message.content;
    content = content.replace(stringToFind, "");
    content = content.replace(stringToFind, "disabled");
    content = content.replace(game.i18n.localize("ITEM-PILES.Chat.TradeSpectate"), game.i18n.localize("ITEM-PILES.Chat.SpectateDisabled"));
    return {
      _id: message.id,
      content,
      [`flags.-=${CONSTANTS.MODULE_NAME}`]: null
    };
  }
  static async _outputTransferItem(source, target, items, userId, interactionId) {
    if (!isValidItemPile(source))
      return;
    if (!interactionId || game.user.id !== userId || !getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    const itemData = await this._formatItemData(items);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.PICKUP_CHAT_MESSAGE, source.uuid, target.uuid, itemData, [], userId, interactionId);
  }
  static async _outputTransferCurrency(source, target, currencies, userId, interactionId) {
    if (!isValidItemPile(source))
      return;
    if (!interactionId || game.user.id !== userId || !getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    const currencyData = this._formatCurrencyData(source, currencies);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.PICKUP_CHAT_MESSAGE, source.uuid, target.uuid, [], currencyData, userId, interactionId);
  }
  static async _outputTransferEverything(source, target, items, currencies, userId, interactionId) {
    if (!isValidItemPile(source))
      return;
    if (!interactionId || game.user.id !== userId || !getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    const itemData = await this._formatItemData(items);
    const currencyData = this._formatCurrencyData(source, currencies);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.PICKUP_CHAT_MESSAGE, source.uuid, target.uuid, itemData, currencyData, userId, interactionId);
  }
  static _outputSplitItemPileInventory(source, pileDeltas, actorDeltas, userId) {
    if (!isValidItemPile(source))
      return;
    if (game.user.id !== userId || !getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.SPLIT_CHAT_MESSAGE, source.uuid, pileDeltas, actorDeltas, userId);
  }
  static async _outputTradeStarted(party_1, party_2, publicTradeId, isPrivate) {
    if (party_1.user !== game.user.id || !getSetting(SETTINGS.OUTPUT_TO_CHAT) || isPrivate)
      return;
    return this._outputTradeStartedToChat(party_1, party_2, publicTradeId);
  }
  static async _outputTradeComplete(party_1, party_2, publicTradeId, isPrivate) {
    if (!getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    return this._outputTradeCompleteToChat(party_1, party_2, publicTradeId, isPrivate);
  }
  static async _outputMerchantTradeComplete(source, target, priceInformation, userId, interactionId) {
    if (!getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    if (!isItemPileMerchant(source))
      return;
    if (!interactionId || game.user.id !== userId || !getSetting(SETTINGS.OUTPUT_TO_CHAT))
      return;
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.MERCHANT_TRADE_CHAT_MESSAGE, source.uuid, target.uuid, priceInformation, userId, interactionId);
  }
  static async _formatItemData(items, divideBy = 1) {
    const formattedItems = [];
    for (const itemData of items) {
      const tempItem = await Item.implementation.create(itemData.item, { temporary: true });
      formattedItems.push({
        name: game.i18n.localize(tempItem.name),
        img: itemData.item.img ?? "",
        quantity: Math.abs(itemData.quantity) / divideBy
      });
    }
    return formattedItems;
  }
  static _formatCurrencyData(itemPile, currencies, divideBy = 1) {
    const currencyList = getActorCurrencies(itemPile, { getAll: true });
    return Object.entries(currencies).map((entry) => {
      const currency = currencyList.find((currency2) => currency2.id === entry[0]);
      return {
        name: game.i18n.localize(currency.name),
        img: currency.img ?? "",
        quantity: Math.abs(entry[1]) / divideBy,
        index: currencyList.indexOf(currency)
      };
    });
  }
  static async _outputPickupToChat(sourceUuid, targetUuid, items, currencies, userId, interactionId) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const now2 = +new Date();
    const messages = Array.from(game.messages).filter((message) => now2 - message.timestamp <= 108e5).slice(-10);
    messages.reverse();
    for (let [index, message] of messages.entries()) {
      const flags = getProperty(message, CONSTANTS.FLAGS.PILE);
      if (flags && flags.source === sourceUuid && flags.target === targetUuid && (flags.interactionId === interactionId || index === 0)) {
        return this._updateExistingPickupMessage(message, sourceActor, targetActor, items, currencies, interactionId);
      }
    }
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/looted.html", {
      message: game.i18n.format("ITEM-PILES.Chat.Pickup", { name: targetActor.name }),
      itemPile: sourceActor,
      actor: targetActor,
      items,
      currencies
    });
    return this._createNewChatMessage(userId, {
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.OTHER,
      content: chatCardHtml,
      flavor: "Item Piles",
      speaker: ChatMessage.getSpeaker({ alias: game.user.name }),
      [CONSTANTS.FLAGS.PILE]: {
        source: sourceUuid,
        target: targetUuid,
        items,
        currencies,
        interactionId
      }
    });
  }
  static _matchEntries(existingEntries, incomingEntries) {
    const combinedEntries = existingEntries.map((existingEntry) => {
      const foundEntry = incomingEntries.find((item) => item.name === existingEntry.name && existingEntry.img === item.img);
      if (foundEntry) {
        existingEntry.quantity += foundEntry.quantity;
        incomingEntries.splice(incomingEntries.indexOf(foundEntry), 1);
      }
      return existingEntry;
    });
    incomingEntries.forEach((item) => combinedEntries.push(item));
    return combinedEntries;
  }
  static async _updateExistingPickupMessage(message, sourceActor, targetActor, items, currencies, interactionId) {
    const flags = getProperty(message, CONSTANTS.FLAGS.PILE);
    const newItems = this._matchEntries(flags.items, items);
    const newCurrencies = this._matchEntries(flags.currencies, currencies);
    newCurrencies.sort((a, b) => {
      return a.index - b.index;
    });
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/looted.html", {
      message: game.i18n.format("ITEM-PILES.Chat.Pickup", { name: targetActor.name }),
      itemPile: sourceActor,
      actor: targetActor,
      items: newItems,
      currencies: newCurrencies
    });
    return message.update({
      content: chatCardHtml,
      [`${CONSTANTS.FLAGS.PILE}.interactionId`]: interactionId,
      [`${CONSTANTS.FLAGS.PILE}.items`]: newItems,
      [`${CONSTANTS.FLAGS.PILE}.currencies`]: newCurrencies
    });
  }
  static async _outputSplitToChat(sourceUuid, pileDeltas, actorDeltas, userId) {
    const source = fromUuidSync(sourceUuid);
    const sourceActor = source?.actor ?? source;
    const divideBy = Object.values(actorDeltas).length;
    const items = await this._formatItemData(pileDeltas.itemDeltas, divideBy);
    const currencies = this._formatCurrencyData(sourceActor, pileDeltas.attributeDeltas, divideBy);
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/looted.html", {
      message: game.i18n.format("ITEM-PILES.Chat.Split", { num_players: divideBy }),
      itemPile: sourceActor,
      items,
      currencies
    });
    return this._createNewChatMessage(userId, {
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.OTHER,
      content: chatCardHtml,
      flavor: "Item Piles",
      speaker: ChatMessage.getSpeaker({ alias: game.user.name })
    });
  }
  static async _outputTradeStartedToChat(party_1, party_2, publicTradeId) {
    const party_1_actor = getActor(party_1.actor);
    const party_2_actor = getActor(party_2.actor);
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/trade-started.html", {
      party_1_actor,
      party_2_actor,
      publicTradeId,
      userId: game.user.id
    });
    return this._createNewChatMessage(game.user.id, {
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.OTHER,
      content: chatCardHtml,
      flavor: "Item Piles",
      speaker: ChatMessage.getSpeaker({ alias: game.user.name }),
      [CONSTANTS.FLAGS.PUBLIC_TRADE_ID]: publicTradeId,
      [CONSTANTS.FLAGS.TRADE_USERS]: [party_1.user, party_2.user]
    });
  }
  static async _outputTradeCompleteToChat(party_1, party_2, publicTradeId, isPrivate) {
    if (party_1.user !== game.user.id)
      return;
    let party_1_actor = fromUuidSync(party_1.actor);
    party_1_actor = party_1_actor?.actor ?? party_1_actor;
    const party_1_data = {
      actor: party_1_actor,
      items: party_2.items,
      currencies: party_2.currencies
    };
    party_1_data.got_nothing = !party_1_data.items.length && !party_1_data.currencies.length;
    let party_2_actor = fromUuidSync(party_2.actor);
    party_2_actor = party_2_actor?.actor ?? party_2_actor;
    const party_2_data = {
      actor: party_2_actor,
      items: party_1.items,
      currencies: party_1.currencies
    };
    party_2_data.got_nothing = !party_2_data.items.length && !party_2_data.currencies.length;
    if (party_1.got_nothing && party_2.got_nothing)
      return;
    const enableCollapse = party_1_data.items.length + party_1_data.currencies.length + party_2_data.items.length + party_2_data.currencies.length > 6;
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/trade-complete.html", {
      party_1: party_1_data,
      party_2: party_2_data,
      publicTradeId,
      isPrivate,
      enableCollapse
    });
    return this._createNewChatMessage(game.user.id, {
      user: game.user.id,
      type: isPrivate ? CONST.CHAT_MESSAGE_TYPES.WHISPER : CONST.CHAT_MESSAGE_TYPES.OTHER,
      content: chatCardHtml,
      flavor: "Item Piles" + (isPrivate ? ": " + game.i18n.localize("ITEM-PILES.Chat.PrivateTrade") : ""),
      speaker: ChatMessage.getSpeaker({ alias: game.user.name }),
      whisper: isPrivate ? [party_2.user] : []
    });
  }
  static async _outputMerchantTradeToChat(sourceUuid, targetUuid, priceInformation, userId, interactionId) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const newItems = priceInformation.buyerReceive;
    const now2 = +new Date();
    const messages = Array.from(game.messages).filter((message) => now2 - message.timestamp <= 108e5).slice(-10);
    messages.reverse();
    for (let [index, message] of messages.entries()) {
      const flags = getProperty(message, CONSTANTS.FLAGS.PILE);
      if (flags && flags.source === sourceUuid && flags.target === targetUuid && (flags.interactionId === interactionId || index === 0)) {
        return this._updateExistingMerchantMessage(message, sourceActor, targetActor, newItems, interactionId);
      }
    }
    const pileData = getActorFlagData(sourceActor);
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/merchant-traded.html", {
      message: game.i18n.format("ITEM-PILES.Chat.MerchantTraded", {
        name: targetActor.name,
        merchant: sourceActor.name
      }),
      merchant: {
        name: sourceActor.name,
        img: pileData.merchantImage || sourceActor.img
      },
      actor: targetActor,
      items: newItems
    });
    return this._createNewChatMessage(userId, {
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.OTHER,
      content: chatCardHtml,
      flavor: "Item Piles",
      speaker: ChatMessage.getSpeaker({ alias: game.user.name }),
      [CONSTANTS.FLAGS.PILE]: {
        source: sourceUuid,
        target: targetUuid,
        items: newItems,
        interactionId
      }
    });
  }
  static async _updateExistingMerchantMessage(message, sourceActor, targetActor, newItems, interactionId) {
    const flags = getProperty(message, CONSTANTS.FLAGS.PILE);
    const mergedItems = this._matchEntries(flags.items, newItems);
    const pileData = getActorFlagData(sourceActor);
    const chatCardHtml = await renderTemplate(CONSTANTS.PATH + "templates/chat/merchant-traded.html", {
      message: game.i18n.format("ITEM-PILES.Chat.MerchantTraded", {
        name: targetActor.name,
        merchant: sourceActor.name
      }),
      merchant: {
        name: sourceActor.name,
        img: pileData.merchantImage || sourceActor.img
      },
      actor: targetActor,
      items: mergedItems
    });
    return message.update({
      content: chatCardHtml,
      [`${CONSTANTS.FLAGS.PILE}.interactionId`]: interactionId,
      [`${CONSTANTS.FLAGS.PILE}.items`]: mergedItems
    });
  }
  static _createNewChatMessage(userId, chatData) {
    if (!chatData.whisper) {
      const mode = getSetting(SETTINGS.OUTPUT_TO_CHAT);
      if (mode > 1) {
        chatData.whisper = Array.from(game.users).filter((user) => user.isGM).map((user) => user.id);
        if (mode === 2) {
          chatData.whisper.push(userId);
        }
        chatData.type = CONST.CHAT_MESSAGE_TYPES.WHISPER;
      }
    }
    return ChatMessage.create(chatData);
  }
}
__name(ChatAPI, "ChatAPI");
class ItemPileSocket {
  static ready = false;
  static HANDLERS = {
    CALL_HOOK: "callHook",
    PICKUP_CHAT_MESSAGE: "pickupChatMessage",
    SPLIT_CHAT_MESSAGE: "splitChatMessage",
    MERCHANT_TRADE_CHAT_MESSAGE: "merchantTradeChatMessage",
    DISABLE_CHAT_TRADE_BUTTON: "disableChatTradeButton",
    CREATE_PILE: "createItemPile",
    UPDATE_PILE: "updateItemPile",
    UPDATED_PILE: "updatedPile",
    DELETE_PILE: "deleteItemPile",
    TURN_INTO_PILE: "turnIntoPiles",
    REVERT_FROM_PILE: "revertFromPiles",
    REFRESH_PILE: "refreshItemPile",
    SPLIT_PILE: "splitItemPileContent",
    RENDER_INTERFACE: "renderItemPileApplication",
    RERENDER_TOKEN_HUD: "rerenderTokenHud",
    USER_OPENED_INTERFACE: "userOpenedInterface",
    USER_CLOSED_INTERFACE: "userClosedInterface",
    GIVE_ITEMS: "giveItems",
    GIVE_ITEMS_RESPONSE: "giveItemsResponse",
    DROP_ITEMS: "dropItems",
    ADD_ITEMS: "addItems",
    REMOVE_ITEMS: "removeItems",
    TRANSFER_ITEMS: "transferItems",
    TRANSFER_ALL_ITEMS: "transferAllItems",
    ADD_CURRENCIES: "addCurrencies",
    REMOVE_CURRENCIES: "removeCurrencies",
    TRANSFER_CURRENCIES: "transferCurrencies",
    TRANSFER_ALL_CURRENCIES: "transferAllCurrencies",
    SET_ATTRIBUTES: "setAttributes",
    ADD_ATTRIBUTES: "addAttributes",
    REMOVE_ATTRIBUTES: "removeAttributes",
    TRANSFER_ATTRIBUTES: "transferAttributes",
    TRANSFER_ALL_ATTRIBUTES: "transferAllAttributes",
    TRANSFER_EVERYTHING: "transferEverything",
    COMMIT_ACTOR_CHANGES: "commitActorChanges",
    ROLL_ITEM_TABLE: "rollItemTable",
    TRADE_REQUEST_PROMPT: "tradePrompt",
    TRADE_REQUEST_CANCELLED: "tradeCancelled",
    REQUEST_TRADE_DATA: "requestTradeData",
    TRADE_CLOSED: "publicTradeClosed",
    PUBLIC_TRADE_UPDATE_ITEMS: "publicTradeUpdateItems",
    PUBLIC_TRADE_UPDATE_ITEM_CURRENCIES: "publicTradeUpdateItemCurrencies",
    PUBLIC_TRADE_UPDATE_CURRENCIES: "publicTradeUpdateCurrencies",
    PUBLIC_TRADE_STATE: "publicTradeAcceptedState",
    PRIVATE_TRADE_UPDATE_ITEMS: "privateTradeUpdateItems",
    PRIVATE_TRADE_UPDATE_ITEM_CURRENCIES: "privateTradeUpdateItemCurrencies",
    PRIVATE_TRADE_UPDATE_CURRENCIES: "privateTradeUpdateCurrencies",
    PRIVATE_TRADE_STATE: "privateTradeAcceptedState",
    EXECUTE_TRADE: "executeTrade",
    TRADE_COMPLETED: "tradeCompleted",
    TRADE_ITEMS: "tradeItems"
  };
  static BINDINGS = {
    [this.HANDLERS.CALL_HOOK]: (hook, response, ...args) => callHook(hook, response, ...args),
    [this.HANDLERS.DROP_ITEMS]: (args) => PrivateAPI._dropItems(args),
    [this.HANDLERS.GIVE_ITEMS]: (...args) => PrivateAPI._giveItems(...args),
    [this.HANDLERS.GIVE_ITEMS_RESPONSE]: (...args) => PrivateAPI._giveItemsResponse(...args),
    [this.HANDLERS.ADD_ITEMS]: (...args) => PrivateAPI._addItems(...args),
    [this.HANDLERS.REMOVE_ITEMS]: (...args) => PrivateAPI._removeItems(...args),
    [this.HANDLERS.TRANSFER_ITEMS]: (...args) => PrivateAPI._transferItems(...args),
    [this.HANDLERS.TRANSFER_ALL_ITEMS]: (...args) => PrivateAPI._transferAllItems(...args),
    [this.HANDLERS.ADD_CURRENCIES]: (...args) => PrivateAPI._addCurrencies(...args),
    [this.HANDLERS.REMOVE_CURRENCIES]: (...args) => PrivateAPI._removeCurrencies(...args),
    [this.HANDLERS.TRANSFER_CURRENCIES]: (...args) => PrivateAPI._transferCurrencies(...args),
    [this.HANDLERS.TRANSFER_ALL_CURRENCIES]: (...args) => PrivateAPI._transferAllCurrencies(...args),
    [this.HANDLERS.SET_ATTRIBUTES]: (...args) => PrivateAPI._setAttributes(...args),
    [this.HANDLERS.ADD_ATTRIBUTES]: (...args) => PrivateAPI._addAttributes(...args),
    [this.HANDLERS.REMOVE_ATTRIBUTES]: (...args) => PrivateAPI._removeAttributes(...args),
    [this.HANDLERS.TRANSFER_ATTRIBUTES]: (...args) => PrivateAPI._transferAttributes(...args),
    [this.HANDLERS.TRANSFER_ALL_ATTRIBUTES]: (...args) => PrivateAPI._transferAllAttributes(...args),
    [this.HANDLERS.TRANSFER_EVERYTHING]: (...args) => PrivateAPI._transferEverything(...args),
    [this.HANDLERS.COMMIT_ACTOR_CHANGES]: (...args) => PrivateAPI._commitActorChanges(...args),
    [this.HANDLERS.ROLL_ITEM_TABLE]: (...args) => PrivateAPI._rollItemTable(...args),
    [this.HANDLERS.CREATE_PILE]: (...args) => PrivateAPI._createItemPile(...args),
    [this.HANDLERS.UPDATE_PILE]: (...args) => PrivateAPI._updateItemPile(...args),
    [this.HANDLERS.UPDATED_PILE]: (...args) => PrivateAPI._updatedItemPile(...args),
    [this.HANDLERS.DELETE_PILE]: (...args) => PrivateAPI._deleteItemPile(...args),
    [this.HANDLERS.TURN_INTO_PILE]: (...args) => PrivateAPI._turnTokensIntoItemPiles(...args),
    [this.HANDLERS.REVERT_FROM_PILE]: (...args) => PrivateAPI._revertTokensFromItemPiles(...args),
    [this.HANDLERS.SPLIT_PILE]: (...args) => PrivateAPI._splitItemPileContents(...args),
    [this.HANDLERS.TRADE_REQUEST_PROMPT]: (...args) => TradeAPI._respondPrompt(...args),
    [this.HANDLERS.TRADE_REQUEST_CANCELLED]: (...args) => TradeAPI._tradeCancelled(...args),
    [this.HANDLERS.EXECUTE_TRADE]: (...args) => TradeAPI._executeTrade(...args),
    [this.HANDLERS.TRADE_COMPLETED]: (...args) => TradeAPI._tradeCompleted(...args),
    [this.HANDLERS.REQUEST_TRADE_DATA]: (...args) => TradeAPI._respondActiveTradeData(...args),
    [this.HANDLERS.TRADE_CLOSED]: (...args) => TradeAPI._tradeClosed(...args),
    [this.HANDLERS.PUBLIC_TRADE_UPDATE_ITEMS]: (...args) => TradeAPI._updateItems(...args),
    [this.HANDLERS.PUBLIC_TRADE_UPDATE_ITEM_CURRENCIES]: (...args) => TradeAPI._updateItemCurrencies(...args),
    [this.HANDLERS.PUBLIC_TRADE_UPDATE_CURRENCIES]: (...args) => TradeAPI._updateCurrencies(...args),
    [this.HANDLERS.PUBLIC_TRADE_STATE]: (...args) => TradeAPI._updateAcceptedState(...args),
    [this.HANDLERS.PRIVATE_TRADE_UPDATE_ITEMS]: (...args) => TradeAPI._updateItems(...args),
    [this.HANDLERS.PRIVATE_TRADE_UPDATE_ITEM_CURRENCIES]: (...args) => TradeAPI._updateItemCurrencies(...args),
    [this.HANDLERS.PRIVATE_TRADE_UPDATE_CURRENCIES]: (...args) => TradeAPI._updateCurrencies(...args),
    [this.HANDLERS.PRIVATE_TRADE_STATE]: (...args) => TradeAPI._updateAcceptedState(...args),
    [this.HANDLERS.PICKUP_CHAT_MESSAGE]: (...args) => ChatAPI._outputPickupToChat(...args),
    [this.HANDLERS.SPLIT_CHAT_MESSAGE]: (...args) => ChatAPI._outputSplitToChat(...args),
    [this.HANDLERS.MERCHANT_TRADE_CHAT_MESSAGE]: (...args) => ChatAPI._outputMerchantTradeToChat(...args),
    [this.HANDLERS.DISABLE_CHAT_TRADE_BUTTON]: (...args) => ChatAPI._disableTradingButton(...args),
    [this.HANDLERS.RENDER_INTERFACE]: (...args) => PrivateAPI._renderItemPileInterface(...args),
    [this.HANDLERS.RERENDER_TOKEN_HUD]: (...args) => PrivateAPI._updateTokenHud(...args),
    [this.HANDLERS.USER_OPENED_INTERFACE]: (...args) => InterfaceTracker.userOpened(...args),
    [this.HANDLERS.USER_CLOSED_INTERFACE]: (...args) => InterfaceTracker.userClosed(...args),
    [this.HANDLERS.TRADE_ITEMS]: (...args) => PrivateAPI._tradeItems(...args)
  };
  static _socket;
  static initialize() {
    InterfaceTracker.initialize();
    this._socket = socketlib.registerModule(CONSTANTS.MODULE_NAME);
    for (let [key, callback] of Object.entries(this.BINDINGS)) {
      this._socket.register(key, callback);
      debug(`Registered itemPileSocket: ${key}`);
    }
    debug("Registered all Item Piles sockets");
    this.ready = true;
  }
  static executeAsGM(handler, ...args) {
    return this._socket.executeAsGM(handler, ...args);
  }
  static executeAsUser(handler, userId, ...args) {
    return this._socket.executeAsUser(handler, userId, ...args);
  }
  static executeForAllGMs(handler, ...args) {
    return this._socket.executeForAllGMs(handler, ...args);
  }
  static executeForOtherGMs(handler, ...args) {
    return this._socket.executeForOtherGMs(handler, ...args);
  }
  static executeForEveryone(handler, ...args) {
    return this._socket.executeForEveryone(handler, ...args);
  }
  static executeForOthers(handler, ...args) {
    return this._socket.executeForOthers(handler, ...args);
  }
  static executeForUsers(handler, userIds, ...args) {
    return this._socket.executeForUsers(handler, userIds, ...args);
  }
  static callHook(hook, ...args) {
    if (!hooks.run)
      return;
    return this._socket.executeForEveryone(this.HANDLERS.CALL_HOOK, hook, ...args);
  }
  static callHookForUsers(hook, users, ...args) {
    if (!hooks.run)
      return;
    return this._socket.executeForUsers(this.HANDLERS.CALL_HOOK, users, hook, ...args);
  }
}
__name(ItemPileSocket, "ItemPileSocket");
async function callHook(hook, ...args) {
  const newArgs = [];
  for (let arg of args) {
    if (stringIsUuid(arg)) {
      const testArg = fromUuidSync(arg);
      if (testArg) {
        arg = testArg;
      }
    }
    newArgs.push(arg);
  }
  return Hooks.callAll(hook, ...newArgs);
}
__name(callHook, "callHook");
const InterfaceTracker = {
  users: {},
  initialize() {
    this.users = {};
    Array.from(game.users).forEach((user) => {
      this.users[user.id] = /* @__PURE__ */ new Set();
    });
    Hooks.on(HOOKS.OPEN_INTERFACE, (app) => {
      ItemPileSocket.executeForOthers(ItemPileSocket.HANDLERS.USER_OPENED_INTERFACE, game.user.id, app.id);
    });
    Hooks.on(HOOKS.CLOSE_INTERFACE, (app) => {
      ItemPileSocket.executeForOthers(ItemPileSocket.HANDLERS.USER_CLOSED_INTERFACE, game.user.id, app.id);
    });
  },
  userOpened(userId, id) {
    if (!this.users[userId])
      return;
    this.users[userId].add(id);
  },
  userClosed(userId, id) {
    if (!this.users[userId])
      return;
    this.users[userId].delete(id);
  },
  isOpened(id) {
    return Object.values(this.users).some((interfaceList) => interfaceList.has(id));
  }
};
const SliderInput_svelte_svelte_type_style_lang = "";
function create_fragment$F(ctx) {
  let div;
  let input0;
  let t;
  let input1;
  let div_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t = space();
      input1 = element("input");
      attr(input0, "type", "range");
      attr(input0, "min", ctx[0]);
      attr(input0, "step", ctx[3]);
      attr(input0, "max", ctx[1]);
      attr(input0, "class", "svelte-zay8hl");
      attr(input1, "type", "number");
      attr(input1, "min", ctx[0]);
      attr(input1, "step", ctx[3]);
      attr(input1, "max", ctx[2]);
      input1.required = true;
      attr(input1, "class", "svelte-zay8hl");
      attr(div, "class", "slider-group svelte-zay8hl");
      attr(div, "style", div_style_value = ctx[5].style);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[4]);
      append(div, t);
      append(div, input1);
      set_input_value(input1, ctx[4]);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[8]),
          listen(input0, "input", ctx[8]),
          listen(input1, "input", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(input0, "min", ctx2[0]);
      }
      if (dirty & 8) {
        attr(input0, "step", ctx2[3]);
      }
      if (dirty & 2) {
        attr(input0, "max", ctx2[1]);
      }
      if (dirty & 16) {
        set_input_value(input0, ctx2[4]);
      }
      if (dirty & 1) {
        attr(input1, "min", ctx2[0]);
      }
      if (dirty & 8) {
        attr(input1, "step", ctx2[3]);
      }
      if (dirty & 4) {
        attr(input1, "max", ctx2[2]);
      }
      if (dirty & 16 && to_number(input1.value) !== ctx2[4]) {
        set_input_value(input1, ctx2[4]);
      }
      if (dirty & 32 && div_style_value !== (div_style_value = ctx2[5].style)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$F, "create_fragment$F");
function instance$F($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { min = 0 } = $$props;
  let { max = 200 } = $$props;
  let { maxInput = Infinity } = $$props;
  let { step = 1 } = $$props;
  let { divideBy = 100 } = $$props;
  let displayValue = value * divideBy;
  function input0_change_input_handler() {
    displayValue = to_number(this.value);
    $$invalidate(4, displayValue);
  }
  __name(input0_change_input_handler, "input0_change_input_handler");
  function input1_input_handler() {
    displayValue = to_number(this.value);
    $$invalidate(4, displayValue);
  }
  __name(input1_input_handler, "input1_input_handler");
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(0, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(1, max = $$new_props.max);
    if ("maxInput" in $$new_props)
      $$invalidate(2, maxInput = $$new_props.maxInput);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("divideBy" in $$new_props)
      $$invalidate(7, divideBy = $$new_props.divideBy);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 144) {
      {
        $$invalidate(6, value = displayValue / divideBy);
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    min,
    max,
    maxInput,
    step,
    displayValue,
    $$props,
    value,
    divideBy,
    input0_change_input_handler,
    input1_input_handler
  ];
}
__name(instance$F, "instance$F");
class SliderInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$F, safe_not_equal, {
      value: 6,
      min: 0,
      max: 1,
      maxInput: 2,
      step: 3,
      divideBy: 7
    });
  }
}
__name(SliderInput, "SliderInput");
function create_if_block_2$k(ctx) {
  let p;
  let t_value = localize(
    `ITEM-PILES.Applications.${ctx[6] ? "DropItem.ExistingPiles" : "GiveItem.TargetActor"}`,
    { target_name: ctx[2].name }
  ) + "";
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      attr(p, "class", "item-piles-text-center");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = localize(
        `ITEM-PILES.Applications.${ctx2[6] ? "DropItem.ExistingPiles" : "GiveItem.TargetActor"}`,
        { target_name: ctx2[2].name }
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_2$k, "create_if_block_2$k");
function create_if_block_1$n(ctx) {
  let div;
  let label;
  let t0_value = localize(
    `ITEM-PILES.Applications.${ctx[6] ? "DropItem.QuantityToDrop" : "GiveItem.QuantityToGive"}`,
    {
      quantity: ctx[7],
      itemName: ctx[1].name
    }
  ) + "";
  let t0;
  let t1;
  let sliderinput;
  let updating_value;
  let current;
  function sliderinput_value_binding(value) {
    ctx[10](value);
  }
  __name(sliderinput_value_binding, "sliderinput_value_binding");
  let sliderinput_props = {
    min: 1,
    max: ctx[7],
    maxInput: ctx[7],
    divideBy: 1
  };
  if (ctx[4] !== void 0) {
    sliderinput_props.value = ctx[4];
  }
  sliderinput = new SliderInput({ props: sliderinput_props });
  binding_callbacks.push(() => bind$1(sliderinput, "value", sliderinput_value_binding));
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      create_component(sliderinput.$$.fragment);
      attr(div, "class", "form-group item-piles-text-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      insert(target, t1, anchor);
      mount_component(sliderinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t0_value !== (t0_value = localize(
        `ITEM-PILES.Applications.${ctx2[6] ? "DropItem.QuantityToDrop" : "GiveItem.QuantityToGive"}`,
        {
          quantity: ctx2[7],
          itemName: ctx2[1].name
        }
      ) + ""))
        set_data(t0, t0_value);
      const sliderinput_changes = {};
      if (!updating_value && dirty & 16) {
        updating_value = true;
        sliderinput_changes.value = ctx2[4];
        add_flush_callback(() => updating_value = false);
      }
      sliderinput.$set(sliderinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sliderinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sliderinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(sliderinput, detaching);
    }
  };
}
__name(create_if_block_1$n, "create_if_block_1$n");
function create_else_block$d(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Applications.DropItem.NewPile") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-box");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[8], { once: true });
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$d, "create_else_block$d");
function create_if_block$x(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize(`ITEM-PILES.Applications.${ctx[6] ? "DropItem.AddToPile" : "GiveItem.Give"}`) + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-download");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[8], { once: true });
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$x, "create_if_block$x");
function create_default_slot$h(ctx) {
  let form_1;
  let h3;
  let t0_value = localize(
    `ITEM-PILES.Applications.${ctx[6] ? "DropItem.Dropping" : "GiveItem.Giving"}`,
    { item_name: ctx[1].name }
  ) + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let footer;
  let t4;
  let button;
  let i;
  let t5;
  let t6_value = localize("Cancel") + "";
  let t6;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_2$k(ctx);
  let if_block1 = ctx[7] > 1 && create_if_block_1$n(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$x;
    return create_else_block$d;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block2 = current_block_type(ctx);
  return {
    c() {
      form_1 = element("form");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      footer = element("footer");
      if_block2.c();
      t4 = space();
      button = element("button");
      i = element("i");
      t5 = space();
      t6 = text(t6_value);
      set_style(h3, "text-align", "center");
      attr(i, "class", "fas fa-times");
      attr(button, "type", "button");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      set_style(footer, "margin-top", "1rem");
      attr(form_1, "class", "item-piles-flexcol");
      set_style(form_1, "padding", "0.5rem");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, h3);
      append(h3, t0);
      append(form_1, t1);
      if (if_block0)
        if_block0.m(form_1, null);
      append(form_1, t2);
      if (if_block1)
        if_block1.m(form_1, null);
      append(form_1, t3);
      append(form_1, footer);
      if_block2.m(footer, null);
      append(footer, t4);
      append(footer, button);
      append(button, i);
      append(button, t5);
      append(button, t6);
      ctx[12](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[11]),
          listen(form_1, "submit", prevent_default(ctx[9]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t0_value !== (t0_value = localize(
        `ITEM-PILES.Applications.${ctx2[6] ? "DropItem.Dropping" : "GiveItem.Giving"}`,
        { item_name: ctx2[1].name }
      ) + ""))
        set_data(t0, t0_value);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$k(ctx2);
          if_block0.c();
          if_block0.m(form_1, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[7] > 1)
        if_block1.p(ctx2, dirty);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(footer, t4);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$h, "create_default_slot$h");
function create_fragment$E(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[13](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$h] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 16414) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$E, "create_fragment$E");
function instance$E($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { item } = $$props;
  let { elementRoot } = $$props;
  let { target = false } = $$props;
  let form;
  let sliderValue = 1;
  const isItemPile = !target || isValidItemPile(target);
  const itemQuantity = getItemQuantity(item);
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function submit() {
    application.options.resolve(sliderValue);
    application.close();
  }
  __name(submit, "submit");
  function sliderinput_value_binding(value) {
    sliderValue = value;
    $$invalidate(4, sliderValue);
  }
  __name(sliderinput_value_binding, "sliderinput_value_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
  };
  return [
    elementRoot,
    item,
    target,
    form,
    sliderValue,
    application,
    isItemPile,
    itemQuantity,
    requestSubmit,
    submit,
    sliderinput_value_binding,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$E, "instance$E");
class Drop_item_dialog_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$E, safe_not_equal, { item: 1, elementRoot: 0, target: 2 });
  }
  get item() {
    return this.$$.ctx[1];
  }
  set item(item) {
    this.$$set({ item });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get target() {
    return this.$$.ctx[2];
  }
  set target(target) {
    this.$$set({ target });
    flush();
  }
}
__name(Drop_item_dialog_shell, "Drop_item_dialog_shell");
class DropItemDialog extends SvelteApplication {
  constructor(item, target, options = {}) {
    super({
      title: options.giving ? game.i18n.localize("ITEM-PILES.Applications.GiveItem.Title") : game.i18n.localize("ITEM-PILES.Applications.DropItem.Title"),
      id: `item-pile-drop-item-${item.id}${target ? "-" + target.id : ""}`,
      svelte: {
        class: Drop_item_dialog_shell,
        target: document.body,
        props: {
          item,
          target
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
    this.item = item;
    this.target = target;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 430,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-drop-item-${id}`);
  }
  static async show(item, target, options = {}) {
    const apps = this.getActiveApps(item.id + (target ? "-" + target.id : ""));
    if (apps.length) {
      for (let app of apps) {
        app.render(false, { focus: true });
      }
      return;
    }
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(item, target, options).render(true, { focus: true });
    });
  }
}
__name(DropItemDialog, "DropItemDialog");
function create_if_block_5$5(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("(x");
      t1 = text(ctx[6]);
      t2 = text(")");
      attr(span, "class", "item-piles-small-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 64)
        set_data(t1, ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_if_block_5$5, "create_if_block_5$5");
function create_if_block_2$j(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_3$f;
    if (ctx2[3])
      return create_if_block_4$9;
    return create_else_block$c;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "item-piles-quantity-container");
      set_style(div, "flex", "2.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
__name(create_if_block_2$j, "create_if_block_2$j");
function create_else_block$c(ctx) {
  let span;
  let t_value = localize(`ITEM-PILES.Inspect.${ctx[1].toShare ? "NoShareLeft" : "NoneLeft"}`) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = localize(`ITEM-PILES.Inspect.${ctx2[1].toShare ? "NoShareLeft" : "NoneLeft"}`) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_else_block$c, "create_else_block$c");
function create_if_block_4$9(ctx) {
  let div;
  let input;
  let input_disabled_value;
  let t0;
  let span;
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text("/ ");
      t2 = text(ctx[3]);
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "number");
      attr(input, "min", "1");
      attr(input, "max", ctx[6]);
      input.disabled = input_disabled_value = !ctx[6];
      attr(span, "class", "item-piles-input-divider");
      toggle_class(span, "item-piles-text-right", !ctx[0].recipient);
      attr(div, "class", "item-piles-quantity-input-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[7]);
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(span, t2);
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        attr(input, "max", ctx2[6]);
      }
      if (dirty & 64 && input_disabled_value !== (input_disabled_value = !ctx2[6])) {
        input.disabled = input_disabled_value;
      }
      if (dirty & 128 && to_number(input.value) !== ctx2[7]) {
        set_input_value(input, ctx2[7]);
      }
      if (dirty & 8)
        set_data(t2, ctx2[3]);
      if (dirty & 1) {
        toggle_class(span, "item-piles-text-right", !ctx2[0].recipient);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$9, "create_if_block_4$9");
function create_if_block_3$f(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "draggable", "true");
      attr(div, "class", "item-piles-quantity-input-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[6]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[19]),
          listen(input, "dragstart", stop_propagation(prevent_default(ctx[18])))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64 && to_number(input.value) !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$f, "create_if_block_3$f");
function create_if_block_1$m(ctx) {
  let button;
  let t_value = localize("Remove") + "";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "item-piles-item-take-button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = !ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[22]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && button_disabled_value !== (button_disabled_value = !ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$m, "create_if_block_1$m");
function create_if_block$w(ctx) {
  let button;
  let t_value = localize("ITEM-PILES.Inspect.Take") + "";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "item-piles-item-take-button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = !ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && button_disabled_value !== (button_disabled_value = !ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$w, "create_if_block$w");
function create_fragment$D(ctx) {
  let div3;
  let div0;
  let img_1;
  let img_1_src_value;
  let t0;
  let div2;
  let div1;
  let p;
  let t1;
  let t2;
  let t3;
  let t4;
  let div3_draggable_value;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[15] && ctx[1].canStack && create_if_block_5$5(ctx);
  let if_block1 = (ctx[1].canStack || !ctx[1].id) && create_if_block_2$j(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[15])
      return create_if_block$w;
    if (!ctx2[1].canStack && !ctx2[1].isCurrency)
      return create_if_block_1$m;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block2 = current_block_type && current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      p = element("p");
      t1 = text(ctx[5]);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(img_1, "class", "item-piles-img");
      if (!src_url_equal(img_1.src, img_1_src_value = ctx[4]))
        attr(img_1, "src", img_1_src_value);
      attr(div0, "class", "item-piles-img-container");
      toggle_class(p, "item-piles-clickable-link", ctx[2]);
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name");
      attr(div3, "class", "item-piles-flexrow item-piles-item-row item-piles-even-color");
      attr(div3, "draggable", div3_draggable_value = !!ctx[1].id);
      toggle_class(div3, "item-piles-disabled", !ctx[15] && !ctx[3]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img_1);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, p);
      append(p, t1);
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div3, t3);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t4);
      if (if_block2)
        if_block2.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(p, "click", ctx[14]),
          listen(div3, "dragstart", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 16 && !src_url_equal(img_1.src, img_1_src_value = ctx2[4])) {
        attr(img_1, "src", img_1_src_value);
      }
      if (!current || dirty & 32)
        set_data(t1, ctx2[5]);
      if (!current || dirty & 4) {
        toggle_class(p, "item-piles-clickable-link", ctx2[2]);
      }
      if (!ctx2[15] && ctx2[1].canStack) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5$5(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1].canStack || !ctx2[1].id) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$j(ctx2);
          if_block1.c();
          if_block1.m(div3, t4);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if (if_block2)
          if_block2.d(1);
        if_block2 = current_block_type && current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div3, null);
        }
      }
      if (!current || dirty & 2 && div3_draggable_value !== (div3_draggable_value = !!ctx2[1].id)) {
        attr(div3, "draggable", div3_draggable_value);
      }
      if (!current || dirty & 32776) {
        toggle_class(div3, "item-piles-disabled", !ctx2[15] && !ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, fade, { duration: 250 }, true);
        div3_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div3_transition)
        div3_transition = create_bidirectional_transition(div3, fade, { duration: 250 }, false);
      div3_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2) {
        if_block2.d();
      }
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$D, "create_fragment$D");
function instance$D($$self, $$props, $$invalidate) {
  let canInspectItems;
  let $pileData;
  let $quantityLeft;
  let $img;
  let $name;
  let $quantity;
  let $currentQuantity;
  let { store } = $$props;
  let { entry } = $$props;
  const name = entry.name;
  component_subscribe($$self, name, (value) => $$invalidate(5, $name = value));
  const img = entry.img;
  component_subscribe($$self, img, (value) => $$invalidate(4, $img = value));
  const quantityLeft = entry.quantityLeft;
  component_subscribe($$self, quantityLeft, (value) => $$invalidate(3, $quantityLeft = value));
  const quantity = entry.quantity;
  component_subscribe($$self, quantity, (value) => $$invalidate(6, $quantity = value));
  const currentQuantity = entry.currentQuantity;
  component_subscribe($$self, currentQuantity, (value) => $$invalidate(7, $currentQuantity = value));
  const pileData = store.pileData;
  component_subscribe($$self, pileData, (value) => $$invalidate(17, $pileData = value));
  function previewItem2() {
    if (!canInspectItems)
      return;
    const item = store.actor.items.get(entry.id);
    if (!item)
      return;
    if (game.user.isGM || item.permission[game.user.id] === 3) {
      return item.sheet.render(true);
    }
    const cls = item._getSheetClass();
    const sheet = new cls(item, { editable: false });
    return sheet._render(true);
  }
  __name(previewItem2, "previewItem");
  const editQuantities = store.editQuantities;
  function dragStart(event) {
    event.dataTransfer.setData("text/plain", JSON.stringify({ type: "Item", uuid: entry.item.uuid }));
  }
  __name(dragStart, "dragStart");
  function dragstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  __name(dragstart_handler, "dragstart_handler");
  function input_input_handler() {
    $quantity = to_number(this.value);
    quantity.set($quantity);
  }
  __name(input_input_handler, "input_input_handler");
  function input_input_handler_1() {
    $currentQuantity = to_number(this.value);
    currentQuantity.set($currentQuantity);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  const click_handler = /* @__PURE__ */ __name(() => {
    entry.take();
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    entry.remove();
  }, "click_handler_1");
  const dragstart_handler_1 = /* @__PURE__ */ __name((event) => {
    dragStart(event);
  }, "dragstart_handler_1");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
    if ("entry" in $$props2)
      $$invalidate(1, entry = $$props2.entry);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 131074) {
      $$invalidate(2, canInspectItems = entry.id && $pileData.canInspectItems);
    }
  };
  return [
    store,
    entry,
    canInspectItems,
    $quantityLeft,
    $img,
    $name,
    $quantity,
    $currentQuantity,
    name,
    img,
    quantityLeft,
    quantity,
    currentQuantity,
    pileData,
    previewItem2,
    editQuantities,
    dragStart,
    $pileData,
    dragstart_handler,
    input_input_handler,
    input_input_handler_1,
    click_handler,
    click_handler_1,
    dragstart_handler_1
  ];
}
__name(instance$D, "instance$D");
class ListEntry extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$D, safe_not_equal, { store: 0, entry: 1 });
  }
}
__name(ListEntry, "ListEntry");
function get_each_context$l(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[7] = list;
  child_ctx[8] = i;
  return child_ctx;
}
__name(get_each_context$l, "get_each_context$l");
function create_if_block$v(ctx) {
  let div1;
  let div0;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div1_intro;
  let current;
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[6].identifier, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$l(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$l(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = `${localize("ITEM-PILES.Items")}`;
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(div1, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        if (!div1_intro) {
          add_render_callback(() => {
            div1_intro = create_in_transition(div1, fade, { duration: 150 });
            div1_intro.start();
          });
        }
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$v, "create_if_block$v");
function create_each_block$l(key_1, ctx) {
  let first;
  let listentry;
  let updating_entry;
  let current;
  function listentry_entry_binding(value) {
    ctx[5](value, ctx[6], ctx[7], ctx[8]);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  let listentry_props = { store: ctx[0] };
  if (ctx[6] !== void 0) {
    listentry_props.entry = ctx[6];
  }
  listentry = new ListEntry({ props: listentry_props });
  binding_callbacks.push(() => bind$1(listentry, "entry", listentry_entry_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(listentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(listentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listentry_changes = {};
      if (dirty & 1)
        listentry_changes.store = ctx[0];
      if (!updating_entry && dirty & 4) {
        updating_entry = true;
        listentry_changes.entry = ctx[6];
        add_flush_callback(() => updating_entry = false);
      }
      listentry.$set(listentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(listentry, detaching);
    }
  };
}
__name(create_each_block$l, "create_each_block$l");
function create_fragment$C(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] > 0 && create_if_block$v(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$v(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_fragment$C, "create_fragment$C");
function instance$C($$self, $$props, $$invalidate) {
  let $numItems;
  let $items;
  let { store } = $$props;
  const items = store.items;
  component_subscribe($$self, items, (value) => $$invalidate(2, $items = value));
  const numItems = store.numItems;
  component_subscribe($$self, numItems, (value) => $$invalidate(1, $numItems = value));
  function listentry_entry_binding(value, item, each_value, item_index) {
    each_value[item_index] = value;
    items.set($items);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  return [store, $numItems, $items, items, numItems, listentry_entry_binding];
}
__name(instance$C, "instance$C");
class ItemList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$C, safe_not_equal, { store: 0 });
  }
}
__name(ItemList, "ItemList");
function get_each_context$k(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  child_ctx[11] = list;
  child_ctx[12] = i;
  return child_ctx;
}
__name(get_each_context$k, "get_each_context$k");
function create_if_block_1$l(ctx) {
  let h3;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${localize("ITEM-PILES.Currencies")}:`;
    },
    m(target, anchor) {
      insert(target, h3, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
__name(create_if_block_1$l, "create_if_block_1$l");
function create_if_block$u(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[3];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[10].identifier, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$k(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$k(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value = ctx2[3];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$k, null, get_each_context$k);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$u, "create_if_block$u");
function create_each_block$k(key_1, ctx) {
  let first;
  let listentry;
  let updating_entry;
  let current;
  function listentry_entry_binding(value) {
    ctx[9](value, ctx[10], ctx[11], ctx[12]);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  let listentry_props = { store: ctx[0] };
  if (ctx[10] !== void 0) {
    listentry_props.entry = ctx[10];
  }
  listentry = new ListEntry({ props: listentry_props });
  binding_callbacks.push(() => bind$1(listentry, "entry", listentry_entry_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(listentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(listentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listentry_changes = {};
      if (dirty & 1)
        listentry_changes.store = ctx[0];
      if (!updating_entry && dirty & 8) {
        updating_entry = true;
        listentry_changes.entry = ctx[10];
        add_flush_callback(() => updating_entry = false);
      }
      listentry.$set(listentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(listentry, detaching);
    }
  };
}
__name(create_each_block$k, "create_each_block$k");
function create_fragment$B(ctx) {
  let div1;
  let div0;
  let t0;
  let a;
  let i;
  let t1;
  let t2_value = localize("ITEM-PILES.Inspect.AddCurrency") + "";
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[1] > 0 || ctx[2] > 0) && create_if_block_1$l();
  let if_block1 = (ctx[1] > 0 || ctx[7]) && create_if_block$u(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      a = element("a");
      i = element("i");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(i, "class", "fas fa-plus");
      attr(a, "class", "item-piles-clickable item-piles-text-right item-piles-small-text item-piles-middle");
      attr(div0, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      append(div0, a);
      append(a, i);
      append(a, t1);
      append(a, t2);
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] > 0 || ctx2[2] > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$l();
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1] > 0 || ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$u(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$B, "create_fragment$B");
function instance$B($$self, $$props, $$invalidate) {
  let $numCurrencies;
  let $numItems;
  let $currencies;
  let { store } = $$props;
  const currencies = store.currencies;
  component_subscribe($$self, currencies, (value) => $$invalidate(3, $currencies = value));
  const numItems = store.numItems;
  component_subscribe($$self, numItems, (value) => $$invalidate(2, $numItems = value));
  const numCurrencies = store.numCurrencies;
  component_subscribe($$self, numCurrencies, (value) => $$invalidate(1, $numCurrencies = value));
  const editQuantities = store.editQuantities;
  async function addCurrency() {
    const result = store.recipient ? await DropCurrencyDialog.show(store.recipient, store.actor) : await DropCurrencyDialog.show(store.actor, false, { unlimitedCurrencies: true });
    if (!result)
      return;
    if (!store.recipient) {
      await game.itempiles.API.addItems(store.actor, result.items);
    } else {
      if (!foundry.utils.isEmpty(result.attributes)) {
        await game.itempiles.API.transferAttributes(store.recipient, store.actor, result.attributes, { interactionId: store.interactionId });
      }
      if (result.items.length) {
        await game.itempiles.API.transferItems(store.recipient, store.actor, result.items, { interactionId: store.interactionId });
      }
    }
  }
  __name(addCurrency, "addCurrency");
  function listentry_entry_binding(value, currency, each_value, index) {
    each_value[index] = value;
    currencies.set($currencies);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  return [
    store,
    $numCurrencies,
    $numItems,
    $currencies,
    currencies,
    numItems,
    numCurrencies,
    editQuantities,
    addCurrency,
    listentry_entry_binding
  ];
}
__name(instance$B, "instance$B");
class CurrencyList$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$B, safe_not_equal, { store: 0 });
  }
}
__name(CurrencyList$1, "CurrencyList$1");
function get_each_context$j(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
}
__name(get_each_context$j, "get_each_context$j");
function create_else_block$b(ctx) {
  let p;
  let t0_value = localize("ITEM-PILES.Inspect.AsActor", {
    actorName: ctx[0].recipient.name
  }) + "";
  let t0;
  let t1;
  let if_block = ctx[4].length > 1 && create_if_block_1$k(ctx);
  return {
    c() {
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      set_style(p, "text-align", "center");
      set_style(p, "flex", "0 1 auto");
      set_style(p, "height", "27px");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
      if (if_block)
        if_block.m(p, null);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = localize("ITEM-PILES.Inspect.AsActor", {
        actorName: ctx2[0].recipient.name
      }) + ""))
        set_data(t0, t0_value);
      if (ctx2[4].length > 1)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(p);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_else_block$b, "create_else_block$b");
function create_if_block$t(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Inspect.Owner")}`;
      set_style(p, "text-align", "center");
      set_style(p, "flex", "0 1 auto");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block$t, "create_if_block$t");
function create_if_block_1$k(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[1])
      return create_if_block_2$i;
    return create_else_block_1$4;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_1$k, "create_if_block_1$k");
function create_else_block_1$4(ctx) {
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ctx[4];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[10], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$j(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$j(key, child_ctx));
  }
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "class", "item-piles-change-actor-select");
      set_style(select, "height", "auto");
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[7].call(select));
      toggle_class(select, "active", ctx[1]);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[2]);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[7]),
          listen(select, "change", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        each_value = ctx2[4];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$j, null, get_each_context$j);
      }
      if (dirty & 20) {
        select_option(select, ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(select, "active", ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_else_block_1$4, "create_else_block_1$4");
function create_if_block_2$i(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Change\r\n            actor.";
      attr(a, "class", "item-piles-highlight");
      toggle_class(a, "active", !ctx[1]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        toggle_class(a, "active", !ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_2$i, "create_if_block_2$i");
function create_each_block$j(key_1, ctx) {
  let option;
  let t_value = ctx[8].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = getUuid(ctx[8].uuid);
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block$j, "create_each_block$j");
function create_fragment$A(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block$t;
    return create_else_block$b;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
__name(create_fragment$A, "create_fragment$A");
function instance$A($$self, $$props, $$invalidate) {
  let { store } = $$props;
  let editQuantities = store.editQuantities;
  let changingActor = false;
  let playerActors = game.actors.filter((actor) => actor.isOwner && actor !== store.pileActor && actor.prototypeToken.actorLink);
  let recipientUuid = getUuid(store.recipient);
  function changeRecipientActor() {
    $$invalidate(0, store.recipient = playerActors.find((actor) => getUuid(actor) === recipientUuid), store);
    store.update();
    $$invalidate(1, changingActor = false);
  }
  __name(changeRecipientActor, "changeRecipientActor");
  const click_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(1, changingActor = true);
  }, "click_handler");
  function select_change_handler() {
    recipientUuid = select_value(this);
    $$invalidate(2, recipientUuid);
    $$invalidate(4, playerActors);
  }
  __name(select_change_handler, "select_change_handler");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  return [
    store,
    changingActor,
    recipientUuid,
    editQuantities,
    playerActors,
    changeRecipientActor,
    click_handler,
    select_change_handler
  ];
}
__name(instance$A, "instance$A");
class ActorPicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$A, safe_not_equal, { store: 0 });
  }
}
__name(ActorPicker, "ActorPicker");
class PileBaseItem {
  constructor(store, data, isCurrency = false) {
    this.store = store;
    this.subscriptions = [];
    this.isCurrency = isCurrency;
    this.setup(data);
  }
  setupStores() {
    this.category = writable({ service: false, type: "", label: "" });
    this.quantity = writable(1);
    this.currentQuantity = writable(1);
    this.quantityLeft = writable(1);
    this.filtered = writable(true);
    this.presentFromTheStart = writable(false);
  }
  setupSubscriptions() {
  }
  setup(data) {
    this.unsubscribe();
    this.setupStores(data);
    this.setupSubscriptions(data);
  }
  subscribeTo(target, callback) {
    this.subscriptions.push(target.subscribe(callback));
  }
  unsubscribe() {
    this.subscriptions.forEach((unsubscribe) => unsubscribe());
    this.subscriptions = [];
  }
}
__name(PileBaseItem, "PileBaseItem");
class PileItem extends PileBaseItem {
  setupStores(item) {
    super.setupStores();
    this.item = item;
    this.itemDocument = new TJSDocument(this.item);
    this.canStack = canItemStack(this.item);
    this.presentFromTheStart.set(getItemQuantity(this.item) > 0 || !this.canStack);
    this.quantity.set(this.canStack ? getItemQuantity(this.item) : 1);
    this.currentQuantity.set(Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft), get_store_value(this.quantity)));
    this.id = this.item.id;
    this.type = this.item.type;
    this.name = writable(this.item.name);
    this.img = writable(this.item.img);
    this.abbreviation = this.item.abbreviation;
    this.identifier = this.id;
    this.itemFlagData = writable(getItemFlagData(this.item));
  }
  setupSubscriptions() {
    super.setupSubscriptions();
    this.subscribeTo(this.store.pileData, this.setupProperties.bind(this));
    this.subscribeTo(this.store.shareData, () => {
      if (!this.toShare) {
        this.quantityLeft.set(get_store_value(this.quantity));
        return;
      }
      const quantityLeft = getItemSharesLeftForActor(this.store.actor, this.item, this.store.recipient);
      this.quantityLeft.set(quantityLeft);
    });
    this.subscribeTo(this.itemDocument, () => {
      const { data } = this.itemDocument.updateOptions;
      this.name.set(this.item.name);
      this.img.set(this.item.img);
      this.similarities = setSimilarityProperties({}, this.item);
      if (canItemStack(this.item) && hasItemQuantity(data)) {
        this.quantity.set(getItemQuantity(data));
        const quantity = Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft), get_store_value(this.quantity));
        this.currentQuantity.set(quantity);
      }
      if (hasProperty(data, CONSTANTS.FLAGS.ITEM)) {
        this.itemFlagData.set(getItemFlagData(this.item));
        this.updateCategory();
        this.store.refreshItems();
      }
    });
    this.updateCategory();
    this.subscribeTo(this.quantity, this.filter.bind(this));
    this.subscribeTo(this.store.search, this.filter.bind(this));
    this.subscribeTo(this.category, this.filter.bind(this));
  }
  setupProperties() {
    this.isCurrency = isItemCurrency(this.item, { target: this.store.actor });
    this.similarities = setSimilarityProperties({}, this.item);
    this.toShare = this.isCurrency ? get_store_value(this.store.pileData).shareCurrenciesEnabled && !!this.store.recipient : get_store_value(this.store.pileData).shareItemsEnabled && !!this.store.recipient;
  }
  updateCategory() {
    const pileData = get_store_value(this.store.pileData);
    const itemFlagData = get_store_value(this.itemFlagData);
    this.category.update((cat) => {
      cat.service = itemFlagData?.isService;
      if (itemFlagData.customCategory) {
        cat.type = itemFlagData.customCategory.toLowerCase();
        cat.label = itemFlagData.customCategory;
      } else if (cat.service && pileData.enabled && pileData.isMerchant) {
        cat.type = "item-piles-service";
        cat.label = "ITEM-PILES.Merchant.Service";
      } else {
        cat.type = this.type;
        cat.label = CONFIG.Item.typeLabels[this.type];
      }
      return cat;
    });
  }
  filter() {
    const name = get_store_value(this.name).trim();
    const search = get_store_value(this.store.search).trim();
    const presentFromTheSTart = get_store_value(this.presentFromTheStart);
    const quantity = get_store_value(this.quantity);
    if (quantity === 0 && !presentFromTheSTart) {
      this.filtered.set(true);
    } else if (search) {
      this.filtered.set(!name.toLowerCase().includes(search.toLowerCase()));
    } else {
      this.filtered.set(!presentFromTheSTart && quantity === 0);
    }
  }
  take() {
    const quantity = Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft));
    if (!quantity)
      return;
    return game.itempiles.API.transferItems(
      this.store.actor,
      this.store.recipient,
      [{ _id: this.id, quantity }],
      { interactionId: this.store.interactionId }
    );
  }
  async remove() {
    return game.itempiles.API.removeItems(this.store.actor, [this.id]);
  }
  updateQuantity(quantity) {
    const roll = new Roll(quantity).evaluate({ async: false });
    this.quantity.set(roll.total);
    return this.item.update(setItemQuantity({}, roll.total));
  }
}
__name(PileItem, "PileItem");
class PileAttribute extends PileBaseItem {
  setupStores(attribute) {
    super.setupStores();
    this.attribute = attribute;
    this.path = this.attribute.path;
    this.name = writable(this.attribute.name);
    this.img = writable(this.attribute.img);
    this.abbreviation = this.attribute.abbreviation;
    this.identifier = this.attribute.path;
    const startingQuantity = Number(getProperty(this.store.actor, this.path) ?? 0);
    this.presentFromTheStart.set(startingQuantity > 0);
    this.quantity.set(startingQuantity);
    this.currentQuantity.set(Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft), get_store_value(this.quantity)));
    this.category.set({ type: "currency", label: "ITEM-PILES.Currency" });
  }
  setupSubscriptions() {
    super.setupSubscriptions();
    this.subscribeTo(this.store.pileData, this.setupProperties.bind(this));
    this.subscribeTo(this.store.shareData, (val) => {
      if (!this.toShare) {
        this.quantityLeft.set(get_store_value(this.quantity));
        return;
      }
      const quantityLeft = getAttributeSharesLeftForActor(this.store.actor, this.path, this.store.recipient);
      this.quantityLeft.set(quantityLeft);
    });
    this.subscribeTo(this.store.document, () => {
      const { data } = this.store.document.updateOptions;
      this.path = this.attribute.path;
      this.name.set(this.attribute.name);
      this.img.set(this.attribute.img);
      if (hasProperty(data, this.path)) {
        this.quantity.set(Number(getProperty(data, this.path) ?? 0));
        this.currentQuantity.set(Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft), get_store_value(this.quantity)));
      }
    });
    this.subscribeTo(this.quantity, this.filter.bind(this));
    this.subscribeTo(this.store.search, this.filter.bind(this));
  }
  setupProperties() {
    this.toShare = get_store_value(this.store.pileData).shareCurrenciesEnabled && !!this.store.recipient;
  }
  filter() {
    const name = get_store_value(this.name);
    const search = get_store_value(this.store.search);
    const presentFromTheSTart = get_store_value(this.presentFromTheStart);
    const quantity = get_store_value(this.quantity);
    if (quantity === 0 && !presentFromTheSTart && !this.store.editQuantities) {
      this.filtered.set(true);
    } else if (search) {
      this.filtered.set(!name.toLowerCase().includes(search.toLowerCase()));
    } else {
      this.filtered.set(!presentFromTheSTart && quantity === 0 && !this.store.editQuantities);
    }
  }
  take() {
    const quantity = Math.min(get_store_value(this.currentQuantity), get_store_value(this.quantityLeft));
    return game.itempiles.API.transferAttributes(
      this.store.actor,
      this.store.recipient,
      { [this.path]: quantity },
      { interactionId: this.store.interactionId }
    );
  }
  updateQuantity() {
    return this.store.actor.update({
      [this.path]: get_store_value(this.quantity)
    });
  }
}
__name(PileAttribute, "PileAttribute");
const __STORES__ = /* @__PURE__ */ new Map();
class ItemPileStore {
  constructor(application, source, recipient = false, { recipientPileData = false } = {}) {
    this.subscriptions = [];
    this.interactionId = randomID();
    this.application = application;
    this.uuid = getUuid(source);
    this.actor = getActor(source);
    this.recipient = recipient ? getActor(recipient) : false;
    this.document = new TJSDocument(this.actor);
    this.recipientDocument = recipient ? new TJSDocument(this.recipient) : false;
    this.recipientPileData = recipientPileData;
    __STORES__.set(this.uuid, this);
    this.setupStores();
    this.setupSubscriptions();
  }
  get ItemClass() {
    return PileItem;
  }
  get AttributeClass() {
    return PileAttribute;
  }
  setupStores() {
    this.pileData = writable(getActorFlagData(this.actor));
    this.shareData = writable(getItemPileSharingData(this.actor));
    this.recipientPileData = this.recipientPileData || writable(this.recipient ? getActorFlagData(this.recipient) : {});
    this.recipientShareData = writable(this.recipient ? getItemPileSharingData(this.recipient) : {});
    this.deleted = writable(false);
    this.search = writable("");
    this.editQuantities = !this.recipient;
    this.allItems = writable([]);
    this.attributes = writable([]);
    this.items = writable([]);
    this.currencies = writable([]);
    this.allCurrencies = writable([]);
    this.visibleItems = writable([]);
    this.itemsPerCategory = writable({});
    this.categories = writable([]);
    this.itemCategories = writable([]);
    this.numItems = writable(0);
    this.numCurrencies = writable(0);
    this.name = writable("");
    this.img = writable("");
  }
  getActorImage() {
    return this.actor.img;
  }
  setupSubscriptions() {
    this.subscribeTo(this.document, () => {
      const { data } = this.document.updateOptions;
      if (hasProperty(data, CONSTANTS.FLAGS.SHARING)) {
        this.shareData.set(getItemPileSharingData(this.actor));
        this.refreshItems();
      }
      if (hasProperty(data, CONSTANTS.FLAGS.PILE)) {
        this.pileData.set(getActorFlagData(this.actor));
        this.refreshItems();
      }
      this.name.set(this.actor.name);
      this.img.set(this.getActorImage());
    });
    if (this.recipientDocument) {
      this.subscribeTo(this.recipientDocument, () => {
        const { data } = this.document.updateOptions;
        if (hasProperty(data, CONSTANTS.FLAGS.SHARING)) {
          this.recipientShareData.set(getItemPileSharingData(this.recipient));
          this.refreshItems();
        }
        if (hasProperty(data, CONSTANTS.FLAGS.PILE)) {
          this.recipientPileData.set(getActorFlagData(this.recipient));
          this.refreshItems();
        }
      });
    }
    const items = [];
    const attributes2 = [];
    getActorItems(this.actor).map((item) => {
      items.push(new this.ItemClass(this, item));
    });
    getActorCurrencies(this.actor, { forActor: this.recipient, getAll: true }).forEach((currency) => {
      if (currency.type === "item") {
        if (!currency.item)
          return;
        items.push(new this.ItemClass(this, currency.item ?? currency.data, true));
      } else {
        attributes2.push(new this.AttributeClass(this, currency, true));
      }
    });
    this.allItems.set(items);
    this.attributes.set(attributes2);
    this.subscribeTo(this.allItems, (val) => {
      if (!val)
        return;
      this.refreshItems();
    });
    this.subscribeTo(this.attributes, (val) => {
      if (!val)
        return;
      this.refreshItems();
    });
    const filterDebounce = foundry.utils.debounce(() => {
      this.refreshItems();
    }, 300);
    this.subscribeTo(this.search, (val) => {
      filterDebounce();
    });
  }
  static getStore(actor) {
    const uuid = getUuid(actor);
    return __STORES__.get(uuid);
  }
  static notifyChanges(event, actor, ...args) {
    const store = this.getStore(actor);
    if (store) {
      store[event](...args);
    }
  }
  refreshItems() {
    const allItems = get_store_value(this.allItems);
    const actorIsMerchant = isItemPileMerchant(this.actor, get_store_value(this.pileData));
    const visibleItems = allItems.filter((entry) => {
      const itemFlagData = entry.itemFlagData ? get_store_value(entry.itemFlagData) : {};
      return !entry.isCurrency && (game.user.isGM || !actorIsMerchant || !itemFlagData?.hidden);
    });
    const itemCurrencies = allItems.filter((entry) => entry.isCurrency);
    this.visibleItems.set(visibleItems);
    const items = visibleItems.filter((entry) => !get_store_value(entry.filtered));
    this.numItems.set(items.filter((entry) => get_store_value(entry.quantity) > 0).length);
    this.items.set(items.sort((a, b) => {
      return a.item.name < b.item.name ? -1 : 1;
    }));
    const currencies = get_store_value(this.attributes).concat(itemCurrencies);
    this.numCurrencies.set(currencies.filter((entry) => get_store_value(entry.quantity) > 0).length);
    this.currencies.set(currencies.filter((entry) => !get_store_value(entry.filtered)));
    this.allCurrencies.set(currencies);
    this.itemCategories.set(Object.values(visibleItems.reduce((acc, item) => {
      const category = get_store_value(item.category);
      if (!acc[category.type]) {
        acc[category.type] = { ...category };
      }
      return acc;
    }, {})).sort((a, b) => a.label < b.label ? -1 : 1));
    const itemsPerCategory = items.reduce((acc, item) => {
      const category = get_store_value(item.category);
      if (!acc[category.type]) {
        acc[category.type] = {
          service: category.service,
          type: category.type,
          label: category.label,
          items: []
        };
      }
      acc[category.type].items.push(item);
      return acc;
    }, {});
    Object.values(itemsPerCategory).forEach((category) => category.items.sort((a, b) => {
      return a.item.name < b.item.name ? -1 : 1;
    }));
    this.itemsPerCategory.set(itemsPerCategory);
    this.categories.set(Object.values(itemsPerCategory).map((category) => {
      return {
        service: category.service,
        label: category.label,
        type: category.type
      };
    }).sort((a, b) => a.label < b.label ? -1 : 1));
  }
  createItem(item) {
    if (isItemInvalid(this.actor, item))
      return;
    const items = get_store_value(this.allItems);
    const deletedItems = items.filter((item2) => item2.id === null).map((item2) => ({
      pileItem: item2,
      ...item2.similarities
    }));
    const previouslyDeletedItem = findSimilarItem(deletedItems, item);
    if (previouslyDeletedItem) {
      previouslyDeletedItem.pileItem.setup(item);
    } else {
      items.push(new PileItem(this, item));
    }
    this.allItems.set(items);
    this.refreshItems();
  }
  deleteItem(item) {
    if (isItemInvalid(this.actor, item))
      return;
    const items = get_store_value(this.allItems);
    const pileItem = items.find((pileItem2) => pileItem2.id === item.id);
    if (!pileItem)
      return;
    if (this.editQuantities || !InterfaceTracker.isOpened(this.application.id)) {
      items.splice(items.indexOf(pileItem), 1);
      this.allItems.set(items);
    } else {
      pileItem.id = null;
      pileItem.quantity.set(0);
      pileItem.quantityLeft.set(0);
    }
    pileItem.unsubscribe();
    this.refreshItems();
  }
  delete() {
    this.deleted.set(true);
  }
  async update() {
    const itemsToUpdate = [];
    const itemsToDelete = [];
    const attributesToUpdate = {};
    const items = get_store_value(this.allItems).filter((item) => item.id);
    for (let item of items) {
      const itemQuantity = get_store_value(item.quantity);
      if (itemQuantity === 0) {
        itemsToDelete.push(item.id);
      } else {
        if (canItemStack(item.item)) {
          itemsToUpdate.push(setItemQuantity({ _id: item.id }, itemQuantity));
        }
      }
    }
    const attributes2 = get_store_value(this.attributes);
    for (let attribute of attributes2) {
      attributesToUpdate[attribute.path] = get_store_value(attribute.quantity);
    }
    const pileSharingData = getItemPileSharingData(this.actor);
    await this.actor.update(attributesToUpdate);
    if (pileSharingData?.currencies) {
      pileSharingData.currencies = pileSharingData.currencies.map((currency) => {
        if (attributesToUpdate[currency.path] !== void 0) {
          currency.actors = currency.actors.map((actor) => {
            actor.quantity = Math.max(0, Math.min(actor.quantity, attributesToUpdate[currency.path]));
            return actor;
          });
        }
        return currency;
      });
    }
    await this.actor.updateEmbeddedDocuments("Item", itemsToUpdate);
    await this.actor.deleteEmbeddedDocuments("Item", itemsToDelete);
    if (pileSharingData?.items) {
      pileSharingData.items = pileSharingData.items.map((item) => {
        const sharingItem = itemsToUpdate.find((item2) => item2._id === item2.id);
        if (sharingItem) {
          item.actors = item.actors.map((actor) => {
            actor.quantity = Math.max(0, Math.min(actor.quantity, sharingItem.quantity));
            return actor;
          });
        }
        return item;
      });
    }
    await updateItemPileSharingData(this.actor, pileSharingData);
    custom_notify("Item Pile successfully updated.");
    this.refreshItems();
  }
  takeAll() {
    game.itempiles.API.transferEverything(
      this.actor,
      this.recipient,
      { interactionId: this.interactionId }
    );
  }
  splitAll() {
    return game.itempiles.API.splitItemPileContents(this.actor, { instigator: this.recipient });
  }
  closeContainer() {
    if (!InterfaceTracker.isOpened(this.application.id)) {
      return game.itempiles.API.closeItemPile(this.actor, this.recipient);
    }
  }
  subscribeTo(target, callback) {
    this.subscriptions.push(target.subscribe(callback));
  }
  unsubscribe() {
    this.subscriptions.forEach((unsubscribe) => unsubscribe());
    this.subscriptions = [];
  }
  onDestroy() {
    this.unsubscribe();
    __STORES__.delete(this.uuid);
  }
}
__name(ItemPileStore, "ItemPileStore");
const CategorizedItemList_svelte_svelte_type_style_lang = "";
function get_each_context$i(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
}
__name(get_each_context$i, "get_each_context$i");
function get_each_context_1$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[12] = list;
  child_ctx[13] = i;
  return child_ctx;
}
__name(get_each_context_1$7, "get_each_context_1$7");
function create_if_block$s(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_intro;
  let current;
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[8].type, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$i(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 13) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        if (!div_intro) {
          add_render_callback(() => {
            div_intro = create_in_transition(div, fade, { duration: 150 });
            div_intro.start();
          });
        }
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$s, "create_if_block$s");
function create_each_block_1$7(key_1, ctx) {
  let first;
  let listentry;
  let updating_entry;
  let current;
  function listentry_entry_binding(value) {
    ctx[7](value, ctx[11], ctx[12], ctx[13]);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  let listentry_props = { store: ctx[0] };
  if (ctx[11] !== void 0) {
    listentry_props.entry = ctx[11];
  }
  listentry = new ListEntry({ props: listentry_props });
  binding_callbacks.push(() => bind$1(listentry, "entry", listentry_entry_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(listentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(listentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const listentry_changes = {};
      if (dirty & 1)
        listentry_changes.store = ctx[0];
      if (!updating_entry && dirty & 12) {
        updating_entry = true;
        listentry_changes.entry = ctx[11];
        add_flush_callback(() => updating_entry = false);
      }
      listentry.$set(listentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(listentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(listentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(listentry, detaching);
    }
  };
}
__name(create_each_block_1$7, "create_each_block_1$7");
function create_each_block$i(key_1, ctx) {
  let div0;
  let h3;
  let t0_value = localize(ctx[8].label) + "";
  let t0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let current;
  let each_value_1 = ctx[3][ctx[8].type].items;
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[11].id, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$7(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$7(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      attr(div0, "class", "item-group-type item-piles-flexrow svelte-bdb8qc");
      attr(div1, "class", "item-piles-items-list");
      this.first = div0;
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h3);
      append(h3, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append(div1, t2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 4) && t0_value !== (t0_value = localize(ctx[8].label) + ""))
        set_data(t0, t0_value);
      if (dirty & 13) {
        each_value_1 = ctx[3][ctx[8].type].items;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, outro_and_destroy_block, create_each_block_1$7, t2, get_each_context_1$7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_each_block$i, "create_each_block$i");
function create_fragment$z(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] > 0 && create_if_block$s(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_fragment$z, "create_fragment$z");
function instance$z($$self, $$props, $$invalidate) {
  let $numItems;
  let $categories;
  let $itemsPerCategory;
  let { store } = $$props;
  const numItems = store.numItems;
  component_subscribe($$self, numItems, (value) => $$invalidate(1, $numItems = value));
  const categories = store.categories;
  component_subscribe($$self, categories, (value) => $$invalidate(2, $categories = value));
  const itemsPerCategory = store.itemsPerCategory;
  component_subscribe($$self, itemsPerCategory, (value) => $$invalidate(3, $itemsPerCategory = value));
  function listentry_entry_binding(value, item, each_value_1, item_index) {
    each_value_1[item_index] = value;
    itemsPerCategory.set($itemsPerCategory);
  }
  __name(listentry_entry_binding, "listentry_entry_binding");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  return [
    store,
    $numItems,
    $categories,
    $itemsPerCategory,
    numItems,
    categories,
    itemsPerCategory,
    listentry_entry_binding
  ];
}
__name(instance$z, "instance$z");
class CategorizedItemList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$z, safe_not_equal, { store: 0 });
  }
}
__name(CategorizedItemList, "CategorizedItemList");
const itemPileInventoryShell_svelte_svelte_type_style_lang = "";
function create_else_block_1$3(ctx) {
  let actorpicker;
  let t0;
  let t1;
  let t2;
  let div;
  let t3;
  let current_block_type_index;
  let if_block3;
  let t4;
  let t5;
  let currencylist;
  let current;
  let mounted;
  let dispose;
  actorpicker = new ActorPicker({ props: { store: ctx[1] } });
  let if_block0 = ctx[4] && create_if_block_10(ctx);
  let if_block1 = ctx[6] && create_if_block_9();
  let if_block2 = ctx[3] && create_if_block_8();
  const if_block_creators = [create_if_block_7, create_else_block_2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[9].displayItemTypes)
      return 0;
    return 1;
  }
  __name(select_block_type_1, "select_block_type_1");
  current_block_type_index = select_block_type_1(ctx);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block4 = ctx[5] && create_if_block_6$3();
  currencylist = new CurrencyList$1({ props: { store: ctx[1] } });
  return {
    c() {
      create_component(actorpicker.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div = element("div");
      if (if_block2)
        if_block2.c();
      t3 = space();
      if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      create_component(currencylist.$$.fragment);
      attr(div, "class", "item-piles-items-list svelte-1543648");
    },
    m(target, anchor) {
      mount_component(actorpicker, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t3);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t4);
      if (if_block4)
        if_block4.m(div, null);
      append(div, t5);
      mount_component(currencylist, div, null);
      ctx[25](div);
      current = true;
      if (!mounted) {
        dispose = listen(div, "scroll", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const actorpicker_changes = {};
      if (dirty[0] & 2)
        actorpicker_changes.store = ctx2[1];
      actorpicker.$set(actorpicker_changes);
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9();
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[3]) {
        if (if_block2) {
          if (dirty[0] & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_8();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(div, t4);
      }
      if (ctx2[5]) {
        if (if_block4)
          ;
        else {
          if_block4 = create_if_block_6$3();
          if_block4.c();
          if_block4.m(div, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      const currencylist_changes = {};
      if (dirty[0] & 2)
        currencylist_changes.store = ctx2[1];
      currencylist.$set(currencylist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actorpicker.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(currencylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actorpicker.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(currencylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actorpicker, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div);
      if (if_block2)
        if_block2.d();
      if_blocks[current_block_type_index].d();
      if (if_block4)
        if_block4.d();
      destroy_component(currencylist);
      ctx[25](null);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block_1$3, "create_else_block_1$3");
function create_if_block_5$4(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Inspect.Destroyed")}`;
      set_style(p, "text-align", "center");
      set_style(p, "flex", "0 1 auto");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_5$4, "create_if_block_5$4");
function create_if_block_10(ctx) {
  let div;
  let label;
  let t1;
  let input;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Search:";
      t1 = space();
      input = element("input");
      set_style(label, "flex", "0 1 auto");
      set_style(label, "margin-right", "5px");
      attr(input, "type", "text");
      attr(div, "class", "form-group item-piles-flexrow item-piles-top-divider item-piles-bottom-divider");
      set_style(div, "margin-bottom", "0.5rem");
      set_style(div, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      set_input_value(input, ctx[8]);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256 && input.value !== ctx2[8]) {
        set_input_value(input, ctx2[8]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: 250 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, { duration: 250 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_10, "create_if_block_10");
function create_if_block_9(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Inspect.Empty")}`;
      attr(p, "class", "item-piles-top-divider");
      set_style(p, "text-align", "center");
      set_style(p, "flex", "0 1 auto");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
__name(create_if_block_9, "create_if_block_9");
function create_if_block_8(ctx) {
  let div0;
  let div0_transition;
  let t;
  let div1;
  let current;
  return {
    c() {
      div0 = element("div");
      t = space();
      div1 = element("div");
      attr(div0, "class", "item-pile-shadow scroll-shadow-top svelte-1543648");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(div0, fade, { duration: 300 }, true);
        div0_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(div0, fade, { duration: 300 }, false);
      div0_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching && div0_transition)
        div0_transition.end();
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
    }
  };
}
__name(create_if_block_8, "create_if_block_8");
function create_else_block_2(ctx) {
  let itemlist;
  let current;
  itemlist = new ItemList({ props: { store: ctx[1] } });
  return {
    c() {
      create_component(itemlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(itemlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const itemlist_changes = {};
      if (dirty[0] & 2)
        itemlist_changes.store = ctx2[1];
      itemlist.$set(itemlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(itemlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itemlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(itemlist, detaching);
    }
  };
}
__name(create_else_block_2, "create_else_block_2");
function create_if_block_7(ctx) {
  let categorizeditemlist;
  let current;
  categorizeditemlist = new CategorizedItemList({ props: { store: ctx[1] } });
  return {
    c() {
      create_component(categorizeditemlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(categorizeditemlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const categorizeditemlist_changes = {};
      if (dirty[0] & 2)
        categorizeditemlist_changes.store = ctx2[1];
      categorizeditemlist.$set(categorizeditemlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(categorizeditemlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(categorizeditemlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(categorizeditemlist, detaching);
    }
  };
}
__name(create_if_block_7, "create_if_block_7");
function create_if_block_6$3(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(hr);
    }
  };
}
__name(create_if_block_6$3, "create_if_block_6$3");
function create_if_block_4$8(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Applications.ItemPileConfig.Update") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-save");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[26]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$8, "create_if_block_4$8");
function create_if_block_2$h(ctx) {
  let button;
  let i;
  let t;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[9].shareItemsEnabled)
      return create_if_block_3$e;
    return create_else_block$a;
  }
  __name(select_block_type_2, "select_block_type_2");
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      i = element("i");
      t = space();
      if_block.c();
      attr(i, "class", "fas fa-handshake");
      attr(button, "type", "button");
      button.disabled = ctx[6];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", ctx[27]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & 64) {
        button.disabled = ctx2[6];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_2$h, "create_if_block_2$h");
function create_else_block$a(ctx) {
  let t_value = localize("ITEM-PILES.Inspect.SplitCurrencies", { num_players: ctx[17] }) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_else_block$a, "create_else_block$a");
function create_if_block_3$e(ctx) {
  let t_value = localize("ITEM-PILES.Inspect.SplitAll", { num_players: ctx[17] }) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_if_block_3$e, "create_if_block_3$e");
function create_if_block_1$j(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Inspect.TakeAll") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-fist-raised");
      attr(button, "type", "submit");
      button.disabled = ctx[6];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[28]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64) {
        button.disabled = ctx2[6];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$j, "create_if_block_1$j");
function create_if_block$r(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Inspect.Close") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-box");
      attr(button, "type", "submit");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[29]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$r, "create_if_block$r");
function create_default_slot$g(ctx) {
  let main;
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let footer;
  let t1;
  let t2;
  let t3;
  let t4;
  let button;
  let i;
  let t5;
  let t6_value = localize("ITEM-PILES.Inspect.Leave") + "";
  let t6;
  let main_intro;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_5$4, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7])
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[12] && create_if_block_4$8(ctx);
  let if_block2 = ctx[9].splitAllEnabled && create_if_block_2$h(ctx);
  let if_block3 = ctx[1].recipient && ctx[9].takeAllEnabled && create_if_block_1$j(ctx);
  let if_block4 = ctx[9].isContainer && !ctx[10].options.remote && create_if_block$r(ctx);
  return {
    c() {
      main = element("main");
      div = element("div");
      if_block0.c();
      t0 = space();
      footer = element("footer");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      button = element("button");
      i = element("i");
      t5 = space();
      t6 = text(t6_value);
      attr(i, "class", "fas fa-sign-out-alt");
      attr(button, "type", "submit");
      attr(footer, "class", "sheet-footer item-piles-flexrow item-piles-top-divider");
      attr(div, "class", "item-piles-item-drop-container");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t0);
      append(div, footer);
      if (if_block1)
        if_block1.m(footer, null);
      append(footer, t1);
      if (if_block2)
        if_block2.m(footer, null);
      append(footer, t2);
      if (if_block3)
        if_block3.m(footer, null);
      append(footer, t3);
      if (if_block4)
        if_block4.m(footer, null);
      append(footer, t4);
      append(footer, button);
      append(button, i);
      append(button, t5);
      append(button, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[30]),
          listen(div, "dragstart", preventDefaultGM),
          listen(div, "drop", ctx[18]),
          listen(div, "dragover", preventDefault$1)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t0);
      }
      if (ctx2[12])
        if_block1.p(ctx2, dirty);
      if (ctx2[9].splitAllEnabled) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$h(ctx2);
          if_block2.c();
          if_block2.m(footer, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[1].recipient && ctx2[9].takeAllEnabled) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$j(ctx2);
          if_block3.c();
          if_block3.m(footer, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (ctx2[9].isContainer && !ctx2[10].options.remote) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block$r(ctx2);
          if_block4.c();
          if_block4.m(footer, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (!main_intro) {
        add_render_callback(() => {
          main_intro = create_in_transition(main, fade, { duration: 500 });
          main_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$g, "create_default_slot$g");
function create_fragment$y(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[31](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$g] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 1022 | dirty[1] & 2) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$y, "create_fragment$y");
function preventDefaultGM(event) {
  if (game.user.isGM)
    return;
  event.preventDefault();
}
__name(preventDefaultGM, "preventDefaultGM");
function preventDefault$1(event) {
  event.preventDefault();
}
__name(preventDefault$1, "preventDefault$1");
function instance$y($$self, $$props, $$invalidate) {
  let isPileEmpty;
  let hasItems;
  let showSearchBar;
  let $numCurrencies;
  let $numItems;
  let $deleted;
  let $searchStore;
  let $pileData;
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { actor } = $$props;
  let { recipient } = $$props;
  let { store = new ItemPileStore(application, actor, recipient) } = $$props;
  let searchStore = store.search;
  component_subscribe($$self, searchStore, (value) => $$invalidate(8, $searchStore = value));
  let editQuantities = store.editQuantities;
  let pileData = store.pileData;
  component_subscribe($$self, pileData, (value) => $$invalidate(9, $pileData = value));
  let deleted = store.deleted;
  component_subscribe($$self, deleted, (value) => $$invalidate(7, $deleted = value));
  let numItems = store.numItems;
  component_subscribe($$self, numItems, (value) => $$invalidate(23, $numItems = value));
  let numCurrencies = store.numCurrencies;
  component_subscribe($$self, numCurrencies, (value) => $$invalidate(22, $numCurrencies = value));
  let num_players = getPlayersForItemPile(actor).length;
  function dropData(event) {
    event.preventDefault();
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
    } catch (err) {
      return false;
    }
    return PrivateAPI._dropData(canvas, data, { target: store.actor });
  }
  __name(dropData, "dropData");
  let itemListElement;
  let scrolled = false;
  function evaluateShadow() {
    $$invalidate(3, scrolled = itemListElement.scrollTop > 20);
  }
  __name(evaluateShadow, "evaluateShadow");
  onDestroy(() => {
    store.onDestroy();
  });
  function input_input_handler() {
    $searchStore = this.value;
    searchStore.set($searchStore);
  }
  __name(input_input_handler, "input_input_handler");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      itemListElement = $$value;
      $$invalidate(2, itemListElement);
    });
  }
  __name(div_binding, "div_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    store.update();
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    store.splitAll();
  }, "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    store.takeAll();
  }, "click_handler_2");
  const click_handler_32 = /* @__PURE__ */ __name(() => {
    store.closeContainer();
    application.close();
  }, "click_handler_3");
  const click_handler_4 = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler_4");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("actor" in $$props2)
      $$invalidate(20, actor = $$props2.actor);
    if ("recipient" in $$props2)
      $$invalidate(21, recipient = $$props2.recipient);
    if ("store" in $$props2)
      $$invalidate(1, store = $$props2.store);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 12582912) {
      $$invalidate(6, isPileEmpty = $numItems === 0 && $numCurrencies === 0);
    }
    if ($$self.$$.dirty[0] & 8388608) {
      $$invalidate(5, hasItems = $numItems > 0);
    }
    if ($$self.$$.dirty[0] & 12582912) {
      $$invalidate(4, showSearchBar = $numItems + $numCurrencies >= 3);
    }
  };
  return [
    elementRoot,
    store,
    itemListElement,
    scrolled,
    showSearchBar,
    hasItems,
    isPileEmpty,
    $deleted,
    $searchStore,
    $pileData,
    application,
    searchStore,
    editQuantities,
    pileData,
    deleted,
    numItems,
    numCurrencies,
    num_players,
    dropData,
    evaluateShadow,
    actor,
    recipient,
    $numCurrencies,
    $numItems,
    input_input_handler,
    div_binding,
    click_handler,
    click_handler_1,
    click_handler_22,
    click_handler_32,
    click_handler_4,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$y, "instance$y");
class Item_pile_inventory_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$y,
      create_fragment$y,
      safe_not_equal,
      {
        elementRoot: 0,
        actor: 20,
        recipient: 21,
        store: 1
      },
      null,
      [-1, -1]
    );
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get actor() {
    return this.$$.ctx[20];
  }
  set actor(actor) {
    this.$$set({ actor });
    flush();
  }
  get recipient() {
    return this.$$.ctx[21];
  }
  set recipient(recipient) {
    this.$$set({ recipient });
    flush();
  }
  get store() {
    return this.$$.ctx[1];
  }
  set store(store) {
    this.$$set({ store });
    flush();
  }
}
__name(Item_pile_inventory_shell, "Item_pile_inventory_shell");
const FilePicker_svelte_svelte_type_style_lang = "";
function create_if_block_1$i(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[0]))
        attr(img, "src", img_src_value);
      attr(div, "class", "item-piles-img-container svelte-ofs97j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_1$i, "create_if_block_1$i");
function create_if_block$q(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", ctx[1]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        attr(input, "placeholder", ctx2[1]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$q, "create_if_block$q");
function create_fragment$x(ctx) {
  let div;
  let t0;
  let t1;
  let button;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_1$i(ctx);
  let if_block1 = ctx[3] && create_if_block$q(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      button = element("button");
      button.innerHTML = `<i class="fas fa-file-import"></i>`;
      attr(button, "type", "button");
      attr(button, "class", "svelte-ofs97j");
      attr(div, "class", "svelte-ofs97j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$i(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$q(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$x, "create_fragment$x");
function instance$x($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { type } = $$props;
  let { placeholder = "" } = $$props;
  let { showImage = false } = $$props;
  let { showInput = true } = $$props;
  let filePicker = false;
  function handleClick() {
    if (!filePicker) {
      filePicker = new FilePicker({
        type,
        current: value,
        callback: (path) => {
          $$invalidate(0, value = path);
          filePicker = false;
        }
      });
    }
    filePicker.render(true, { focus: true });
  }
  __name(handleClick, "handleClick");
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  __name(input_input_handler, "input_input_handler");
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(5, type = $$props2.type);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("showImage" in $$props2)
      $$invalidate(2, showImage = $$props2.showImage);
    if ("showInput" in $$props2)
      $$invalidate(3, showInput = $$props2.showInput);
  };
  return [
    value,
    placeholder,
    showImage,
    showInput,
    handleClick,
    type,
    input_input_handler
  ];
}
__name(instance$x, "instance$x");
class FilePicker_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$x, safe_not_equal, {
      value: 0,
      type: 5,
      placeholder: 1,
      showImage: 2,
      showInput: 3
    });
  }
}
__name(FilePicker_1, "FilePicker_1");
const priceModifiersEditor_svelte_svelte_type_style_lang = "";
function get_each_context$h(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[15] = list;
  child_ctx[16] = i;
  return child_ctx;
}
__name(get_each_context$h, "get_each_context$h");
function create_if_block$p(ctx) {
  let table;
  let tr;
  let th0;
  let t1;
  let th1;
  let t3;
  let th2;
  let t5;
  let th3;
  let t7;
  let th4;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[0];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[16], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$h(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th0.textContent = `${localize("ITEM-PILES.Applications.PriceModifiersEditor.Override")}`;
      t1 = space();
      th1 = element("th");
      th1.textContent = `${localize("ITEM-PILES.Applications.PriceModifiersEditor.Actor")}`;
      t3 = space();
      th2 = element("th");
      th2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.BuyPriceModifier")}`;
      t5 = space();
      th3 = element("th");
      th3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.SellPriceModifier")}`;
      t7 = space();
      th4 = element("th");
      t8 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(th0, "width", "5%");
      set_style(th1, "width", "25%");
      set_style(th2, "width", "35%");
      set_style(th3, "width", "35%");
      set_style(th4, "width", "5%");
      attr(tr, "class", "svelte-xx5053");
      attr(table, "class", "svelte-xx5053");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, tr);
      append(tr, th0);
      append(tr, t1);
      append(tr, th1);
      append(tr, t3);
      append(tr, th2);
      append(tr, t5);
      append(tr, th3);
      append(tr, t7);
      append(tr, th4);
      append(table, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 33) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, outro_and_destroy_block, create_each_block$h, null, get_each_context$h);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$p, "create_if_block$p");
function create_each_block$h(key_1, ctx) {
  let tr;
  let td0;
  let div0;
  let input;
  let t0;
  let td1;
  let a;
  let t1_value = ctx[14].actor.name + "";
  let t1;
  let t2;
  let td2;
  let div1;
  let sliderinput0;
  let updating_value;
  let t3;
  let td3;
  let div2;
  let sliderinput1;
  let updating_value_1;
  let t4;
  let td4;
  let button;
  let t5;
  let current;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[8].call(input, ctx[15], ctx[16]);
  }
  __name(input_change_handler, "input_change_handler");
  function sliderinput0_value_binding(value) {
    ctx[9](value, ctx[14]);
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  let sliderinput0_props = {};
  if (ctx[14].buyPriceModifier !== void 0) {
    sliderinput0_props.value = ctx[14].buyPriceModifier;
  }
  sliderinput0 = new SliderInput({ props: sliderinput0_props });
  binding_callbacks.push(() => bind$1(sliderinput0, "value", sliderinput0_value_binding));
  function sliderinput1_value_binding(value) {
    ctx[10](value, ctx[14]);
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  let sliderinput1_props = {};
  if (ctx[14].sellPriceModifier !== void 0) {
    sliderinput1_props.value = ctx[14].sellPriceModifier;
  }
  sliderinput1 = new SliderInput({ props: sliderinput1_props });
  binding_callbacks.push(() => bind$1(sliderinput1, "value", sliderinput1_value_binding));
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      input = element("input");
      t0 = space();
      td1 = element("td");
      a = element("a");
      t1 = text(t1_value);
      t2 = space();
      td2 = element("td");
      div1 = element("div");
      create_component(sliderinput0.$$.fragment);
      t3 = space();
      td3 = element("td");
      div2 = element("div");
      create_component(sliderinput1.$$.fragment);
      t4 = space();
      td4 = element("td");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      t5 = space();
      attr(input, "type", "checkbox");
      attr(div0, "class", "form-group");
      attr(a, "class", "item-piles-actor-name-clickable svelte-xx5053");
      attr(div1, "class", "item-piles-flexrow");
      set_style(div1, "margin", "0 0.25rem");
      attr(div2, "class", "item-piles-flexrow");
      set_style(div2, "margin", "0 0.25rem");
      attr(button, "type", "button");
      attr(button, "class", "svelte-xx5053");
      attr(td4, "class", "small svelte-xx5053");
      attr(tr, "class", "svelte-xx5053");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, input);
      input.checked = ctx[14].override;
      append(tr, t0);
      append(tr, td1);
      append(td1, a);
      append(a, t1);
      append(tr, t2);
      append(tr, td2);
      append(td2, div1);
      mount_component(sliderinput0, div1, null);
      append(tr, t3);
      append(tr, td3);
      append(td3, div2);
      mount_component(sliderinput1, div2, null);
      append(tr, t4);
      append(tr, td4);
      append(td4, button);
      append(tr, t5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(a, "click", function() {
            if (is_function(ctx[14].actor.sheet.render(true)))
              ctx[14].actor.sheet.render(true).apply(this, arguments);
          }),
          listen(button, "click", function() {
            if (is_function(ctx[5](ctx[16])))
              ctx[5](ctx[16]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1) {
        input.checked = ctx[14].override;
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx[14].actor.name + ""))
        set_data(t1, t1_value);
      const sliderinput0_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        sliderinput0_changes.value = ctx[14].buyPriceModifier;
        add_flush_callback(() => updating_value = false);
      }
      sliderinput0.$set(sliderinput0_changes);
      const sliderinput1_changes = {};
      if (!updating_value_1 && dirty & 1) {
        updating_value_1 = true;
        sliderinput1_changes.value = ctx[14].sellPriceModifier;
        add_flush_callback(() => updating_value_1 = false);
      }
      sliderinput1.$set(sliderinput1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sliderinput0.$$.fragment, local);
      transition_in(sliderinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sliderinput0.$$.fragment, local);
      transition_out(sliderinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(sliderinput0);
      destroy_component(sliderinput1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$h, "create_each_block$h");
function create_default_slot$f(ctx) {
  let form_1;
  let p0;
  let t1;
  let div;
  let t2;
  let p1;
  let t4;
  let footer;
  let button0;
  let i0;
  let t5;
  let t6_value = localize("ITEM-PILES.Applications.PriceModifiersEditor.Submit") + "";
  let t6;
  let t7;
  let button1;
  let i1;
  let t8;
  let t9_value = localize("Cancel") + "";
  let t9;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0].length && create_if_block$p(ctx);
  return {
    c() {
      form_1 = element("form");
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.PriceModifiersEditor.Explanation")}`;
      t1 = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.PriceModifiersEditor.DragDrop")}`;
      t4 = space();
      footer = element("footer");
      button0 = element("button");
      i0 = element("i");
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      button1 = element("button");
      i1 = element("i");
      t8 = space();
      t9 = text(t9_value);
      attr(p1, "class", "item-piles-text-center");
      attr(div, "class", "svelte-xx5053");
      toggle_class(div, "border-highlight", !ctx[0].length);
      attr(i0, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i1, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p0);
      append(form_1, t1);
      append(form_1, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t2);
      append(div, p1);
      append(form_1, t4);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i0);
      append(button0, t5);
      append(button0, t6);
      append(footer, t7);
      append(footer, button1);
      append(button1, i1);
      append(button1, t8);
      append(button1, t9);
      ctx[12](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "dragstart", preventDefault),
          listen(div, "drop", ctx[7]),
          listen(div, "dragover", preventDefault),
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[11], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[6]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[0].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1) {
        toggle_class(div, "border-highlight", !ctx2[0].length);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$f, "create_default_slot$f");
function create_fragment$w(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[13](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$f] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 131081) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$w, "create_fragment$w");
function preventDefault(event) {
  event.preventDefault();
}
__name(preventDefault, "preventDefault");
function instance$w($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let form;
  let { priceModifiers } = $$props;
  let { elementRoot } = $$props;
  function remove(index) {
    priceModifiers.splice(index, 1);
    $$invalidate(0, priceModifiers);
  }
  __name(remove, "remove");
  async function updateSettings() {
    priceModifiers.forEach((data) => {
      data.actorUuid = getUuid(data.actor);
    });
    application.options.resolve?.(priceModifiers);
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  async function dropData(event) {
    event.preventDefault();
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
    } catch (err) {
      return false;
    }
    if (data.type !== "Actor")
      return;
    const actor = await fromUuid(data.uuid);
    if (!actor)
      return;
    if (priceModifiers.find((data2) => data2.actor === actor))
      return;
    priceModifiers.push({
      override: false,
      actor,
      buyPriceModifier: 1,
      sellPriceModifier: 0.5
    });
    $$invalidate(0, priceModifiers);
  }
  __name(dropData, "dropData");
  function input_change_handler(each_value, index) {
    each_value[index].override = this.checked;
    $$invalidate(0, priceModifiers);
  }
  __name(input_change_handler, "input_change_handler");
  function sliderinput0_value_binding(value, priceData) {
    if ($$self.$$.not_equal(priceData.buyPriceModifier, value)) {
      priceData.buyPriceModifier = value;
      $$invalidate(0, priceModifiers);
    }
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  function sliderinput1_value_binding(value, priceData) {
    if ($$self.$$.not_equal(priceData.sellPriceModifier, value)) {
      priceData.sellPriceModifier = value;
      $$invalidate(0, priceModifiers);
    }
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("priceModifiers" in $$props2)
      $$invalidate(0, priceModifiers = $$props2.priceModifiers);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
  };
  return [
    priceModifiers,
    elementRoot,
    requestSubmit,
    form,
    application,
    remove,
    updateSettings,
    dropData,
    input_change_handler,
    sliderinput0_value_binding,
    sliderinput1_value_binding,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$w, "instance$w");
class Price_modifiers_editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$w, safe_not_equal, {
      priceModifiers: 0,
      elementRoot: 1,
      requestSubmit: 2
    });
  }
  get priceModifiers() {
    return this.$$.ctx[0];
  }
  set priceModifiers(priceModifiers) {
    this.$$set({ priceModifiers });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Price_modifiers_editor, "Price_modifiers_editor");
class PriceModifiersEditor extends SvelteApplication {
  constructor(priceModifiers, options) {
    priceModifiers = priceModifiers.map((data) => {
      data.actor = fromUuidSync(data.actorUuid);
      if (!data.actor)
        return false;
      return data;
    }).filter(Boolean);
    super({
      svelte: {
        class: Price_modifiers_editor,
        target: document.body,
        props: {
          priceModifiers
        }
      },
      close: () => this.options.resolve?.(false),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Applications.PriceModifiersEditor.Title"),
      width: 600,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static async show(data = false, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(data, options).render(true, { focus: true });
    });
  }
}
__name(PriceModifiersEditor, "PriceModifiersEditor");
const CurrencyList_svelte_svelte_type_style_lang = "";
function get_each_context$g(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[17] = list;
  child_ctx[18] = i;
  return child_ctx;
}
__name(get_each_context$g, "get_each_context$g");
function create_if_block_2$g(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Drop to add";
      attr(div, "class", "drop-to-add svelte-k6k9jv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_2$g, "create_if_block_2$g");
function create_if_block_1$h(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "Drop an item or click the plus button to get started!";
      attr(div0, "class", "full-span svelte-k6k9jv");
      toggle_class(div0, "invisible", ctx[1]);
      attr(div1, "class", "item-piles-sortable-list-columns  svelte-k6k9jv");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        toggle_class(div0, "invisible", ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
__name(create_if_block_1$h, "create_if_block_1$h");
function create_else_block$9(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[13](ctx[18]);
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fas fa-eye"></i> View item`;
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$9, "create_else_block$9");
function create_if_block$o(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[12].call(input, ctx[17], ctx[18]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "data.attributes.hp.value");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[16].data.path);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && input.value !== ctx[16].data.path) {
        set_input_value(input, ctx[16].data.path);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$o, "create_if_block$o");
function create_each_block$g(key_1, ctx) {
  let div7;
  let div0;
  let input0;
  let input0_checked_value;
  let t0;
  let div1;
  let input1;
  let t1;
  let div2;
  let input2;
  let t2;
  let div3;
  let input3;
  let t3;
  let div4;
  let filepicker;
  let updating_value;
  let t4;
  let div5;
  let t5;
  let div6;
  let button;
  let t6;
  let current;
  let mounted;
  let dispose;
  function change_handler() {
    return ctx[7](ctx[18]);
  }
  __name(change_handler, "change_handler");
  function input1_input_handler() {
    ctx[8].call(input1, ctx[17], ctx[18]);
  }
  __name(input1_input_handler, "input1_input_handler");
  function input2_input_handler() {
    ctx[9].call(input2, ctx[17], ctx[18]);
  }
  __name(input2_input_handler, "input2_input_handler");
  function input3_input_handler() {
    ctx[10].call(input3, ctx[17], ctx[18]);
  }
  __name(input3_input_handler, "input3_input_handler");
  function filepicker_value_binding(value) {
    ctx[11](value, ctx[16]);
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  let filepicker_props = {
    type: "imagevideo",
    showImage: true,
    showInput: false
  };
  if (ctx[16].img !== void 0) {
    filepicker_props.value = ctx[16].img;
  }
  filepicker = new FilePicker_1({ props: filepicker_props });
  binding_callbacks.push(() => bind$1(filepicker, "value", filepicker_value_binding));
  function select_block_type(ctx2, dirty) {
    if (ctx2[16].type === "attribute")
      return create_if_block$o;
    return create_else_block$9;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  function click_handler_22() {
    return ctx[14](ctx[18]);
  }
  __name(click_handler_22, "click_handler_2");
  return {
    key: key_1,
    first: null,
    c() {
      div7 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      div1 = element("div");
      input1 = element("input");
      t1 = space();
      div2 = element("div");
      input2 = element("input");
      t2 = space();
      div3 = element("div");
      input3 = element("input");
      t3 = space();
      div4 = element("div");
      create_component(filepicker.$$.fragment);
      t4 = space();
      div5 = element("div");
      if_block.c();
      t5 = space();
      div6 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      t6 = space();
      attr(input0, "type", "checkbox");
      input0.checked = input0_checked_value = ctx[16].primary;
      attr(input1, "type", "text");
      attr(input2, "type", "number");
      attr(input2, "step", "0.000000001");
      attr(input3, "type", "text");
      attr(button, "type", "button");
      attr(button, "class", "delete-button");
      attr(div7, "class", "item-piles-sortable-list-columns svelte-k6k9jv");
      this.first = div7;
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div0, input0);
      append(div7, t0);
      append(div7, div1);
      append(div1, input1);
      set_input_value(input1, ctx[16].name);
      append(div7, t1);
      append(div7, div2);
      append(div2, input2);
      set_input_value(input2, ctx[16].exchangeRate);
      append(div7, t2);
      append(div7, div3);
      append(div3, input3);
      set_input_value(input3, ctx[16].abbreviation);
      append(div7, t3);
      append(div7, div4);
      mount_component(filepicker, div4, null);
      append(div7, t4);
      append(div7, div5);
      if_block.m(div5, null);
      append(div7, t5);
      append(div7, div6);
      append(div6, button);
      append(div7, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", change_handler),
          listen(input1, "input", input1_input_handler),
          listen(input2, "input", input2_input_handler),
          listen(input3, "input", input3_input_handler),
          listen(button, "click", click_handler_22)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & 4 && input0_checked_value !== (input0_checked_value = ctx[16].primary)) {
        input0.checked = input0_checked_value;
      }
      if (dirty & 4 && input1.value !== ctx[16].name) {
        set_input_value(input1, ctx[16].name);
      }
      if (dirty & 4 && to_number(input2.value) !== ctx[16].exchangeRate) {
        set_input_value(input2, ctx[16].exchangeRate);
      }
      if (dirty & 4 && input3.value !== ctx[16].abbreviation) {
        set_input_value(input3, ctx[16].abbreviation);
      }
      const filepicker_changes = {};
      if (!updating_value && dirty & 4) {
        updating_value = true;
        filepicker_changes.value = ctx[16].img;
        add_flush_callback(() => updating_value = false);
      }
      filepicker.$set(filepicker_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div5, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      destroy_component(filepicker);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$g, "create_each_block$g");
function create_default_slot$e(ctx) {
  let div7;
  let div0;
  let t1;
  let div1;
  let t3;
  let div2;
  let t5;
  let div3;
  let t7;
  let div4;
  let t9;
  let div5;
  let t11;
  let div6;
  let a;
  let t12;
  let div8;
  let t13;
  let t14;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_2$g();
  let if_block1 = !ctx[2].length && create_if_block_1$h(ctx);
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[16].id, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$g(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
  }
  return {
    c() {
      div7 = element("div");
      div0 = element("div");
      div0.textContent = "Primary";
      t1 = space();
      div1 = element("div");
      div1.textContent = "Name";
      t3 = space();
      div2 = element("div");
      div2.textContent = "Exchange";
      t5 = space();
      div3 = element("div");
      div3.textContent = "Short";
      t7 = space();
      div4 = element("div");
      div4.textContent = "Icon";
      t9 = space();
      div5 = element("div");
      div5.textContent = "Data";
      t11 = space();
      div6 = element("div");
      a = element("a");
      a.innerHTML = `<i class="fas fa-plus"></i>`;
      t12 = space();
      div8 = element("div");
      if (if_block0)
        if_block0.c();
      t13 = space();
      if (if_block1)
        if_block1.c();
      t14 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(div0, "justify-content", "flex-start");
      attr(div7, "class", "item-piles-sortable-list-columns header svelte-k6k9jv");
      attr(div8, "class", "table-container svelte-k6k9jv");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div7, t1);
      append(div7, div1);
      append(div7, t3);
      append(div7, div2);
      append(div7, t5);
      append(div7, div3);
      append(div7, t7);
      append(div7, div4);
      append(div7, t9);
      append(div7, div5);
      append(div7, t11);
      append(div7, div6);
      append(div6, a);
      insert(target, t12, anchor);
      insert(target, div8, anchor);
      if (if_block0)
        if_block0.m(div8, null);
      append(div8, t13);
      if (if_block1)
        if_block1.m(div8, null);
      append(div8, t14);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div8, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_2$g();
          if_block0.c();
          if_block0.m(div8, t13);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[2].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$h(ctx2);
          if_block1.c();
          if_block1.m(div8, t14);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 5) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div8, outro_and_destroy_block, create_each_block$g, null, get_each_context$g);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      if (detaching)
        detach(t12);
      if (detaching)
        detach(div8);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_default_slot$e, "create_default_slot$e");
function create_fragment$v(ctx) {
  let dropzone;
  let updating_isHovering;
  let current;
  function dropzone_isHovering_binding(value) {
    ctx[15](value);
  }
  __name(dropzone_isHovering_binding, "dropzone_isHovering_binding");
  let dropzone_props = {
    callback: ctx[4],
    $$slots: { default: [create_default_slot$e] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    dropzone_props.isHovering = ctx[1];
  }
  dropzone = new DropZone({ props: dropzone_props });
  binding_callbacks.push(() => bind$1(dropzone, "isHovering", dropzone_isHovering_binding));
  return {
    c() {
      create_component(dropzone.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dropzone, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dropzone_changes = {};
      if (dirty & 524295) {
        dropzone_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_isHovering && dirty & 2) {
        updating_isHovering = true;
        dropzone_changes.isHovering = ctx2[1];
        add_flush_callback(() => updating_isHovering = false);
      }
      dropzone.$set(dropzone_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropzone.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropzone.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropzone, detaching);
    }
  };
}
__name(create_fragment$v, "create_fragment$v");
function instance$v($$self, $$props, $$invalidate) {
  let currencies;
  let $currenciesStore;
  let { store } = $$props;
  const currenciesStore = store.currencies;
  component_subscribe($$self, currenciesStore, (value) => $$invalidate(5, $currenciesStore = value));
  let isHovering = false;
  async function dropData(data) {
    if (!data.type) {
      throw custom_error("Something went wrong when dropping this item!");
    }
    if (data.type !== "Item") {
      throw custom_error("You must drop an item, not " + data.type.toLowerCase() + "!");
    }
    store.addItem(data);
  }
  __name(dropData, "dropData");
  const click_handler = /* @__PURE__ */ __name(() => store.addAttribute(), "click_handler");
  const change_handler = /* @__PURE__ */ __name((index) => store.setPrimary(index), "change_handler");
  function input1_input_handler(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(2, currencies), $$invalidate(5, $currenciesStore);
  }
  __name(input1_input_handler, "input1_input_handler");
  function input2_input_handler(each_value, index) {
    each_value[index].exchangeRate = to_number(this.value);
    $$invalidate(2, currencies), $$invalidate(5, $currenciesStore);
  }
  __name(input2_input_handler, "input2_input_handler");
  function input3_input_handler(each_value, index) {
    each_value[index].abbreviation = this.value;
    $$invalidate(2, currencies), $$invalidate(5, $currenciesStore);
  }
  __name(input3_input_handler, "input3_input_handler");
  function filepicker_value_binding(value, item) {
    if ($$self.$$.not_equal(item.img, value)) {
      item.img = value;
      $$invalidate(2, currencies), $$invalidate(5, $currenciesStore);
    }
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  function input_input_handler(each_value, index) {
    each_value[index].data.path = this.value;
    $$invalidate(2, currencies), $$invalidate(5, $currenciesStore);
  }
  __name(input_input_handler, "input_input_handler");
  const click_handler_1 = /* @__PURE__ */ __name((index) => store.editItem(index), "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name((index) => store.removeEntry(index), "click_handler_2");
  function dropzone_isHovering_binding(value) {
    isHovering = value;
    $$invalidate(1, isHovering);
  }
  __name(dropzone_isHovering_binding, "dropzone_isHovering_binding");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $$invalidate(2, currencies = $currenciesStore);
    }
  };
  return [
    store,
    isHovering,
    currencies,
    currenciesStore,
    dropData,
    $currenciesStore,
    click_handler,
    change_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    filepicker_value_binding,
    input_input_handler,
    click_handler_1,
    click_handler_22,
    dropzone_isHovering_binding
  ];
}
__name(instance$v, "instance$v");
class CurrencyList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$v, safe_not_equal, { store: 0 });
  }
}
__name(CurrencyList, "CurrencyList");
class CurrencyStore {
  constructor(data) {
    this.currencies = writable(data.map((entry, index) => {
      return {
        ...entry,
        index,
        id: entry.data?.path ?? entry.data?._id ?? randomID()
      };
    }));
  }
  setPrimary(index) {
    const currencies = get_store_value(this.currencies);
    currencies.forEach((entry, entryIndex) => {
      entry.primary = entryIndex === index;
    });
    this.currencies.set(currencies);
  }
  sortCurrencies() {
    const currencies = get_store_value(this.currencies);
    currencies.sort((a, b) => {
      return b.exchangeRate - a.exchangeRate;
    });
    this.currencies.set(currencies);
  }
  addAttribute() {
    const currencies = get_store_value(this.currencies);
    this.currencies.set([...currencies, {
      type: "attribute",
      name: "New Attribute",
      img: "",
      abbreviation: "{#}N",
      data: {
        path: ""
      },
      primary: !currencies.length,
      exchangeRate: 1
    }]);
    this.sortCurrencies();
  }
  async addItem(data) {
    let uuid = false;
    if (data.pack) {
      uuid = "Compendium" + data.pack + "." + data.id;
    }
    let item = await Item.implementation.fromDropData(data);
    let itemData = item.toObject();
    if (!itemData) {
      console.error(data);
      throw custom_error("Something went wrong when dropping this item!");
    }
    let currencies = get_store_value(this.currencies);
    const itemCurrencies = currencies.map((entry) => entry.data?.item ?? {});
    const foundItem = findSimilarItem(itemCurrencies, itemData);
    if (foundItem) {
      const index = itemCurrencies.indexOf(foundItem);
      currencies[index].data = {
        uuid,
        item: itemData
      };
      custom_notify(`Updated item data for ${localize(currencies[index].name)} (item name ${itemData.name})`);
    } else {
      currencies = [...currencies, {
        id: randomID(),
        type: "item",
        name: itemData.name,
        img: itemData.img,
        abbreviation: "{#} " + itemData.name,
        data: {
          uuid,
          item: itemData
        },
        primary: !currencies.length,
        exchangeRate: 1
      }];
    }
    this.currencies.set(currencies);
    this.sortCurrencies();
  }
  async editItem(index) {
    const currencies = get_store_value(this.currencies);
    const data = currencies[index].data;
    let item;
    if (data.uuid) {
      item = await fromUuid(data.uuid);
    } else {
      let itemData = data.item;
      if (itemData._id)
        delete itemData._id;
      if (itemData.permission)
        delete itemData._id;
      const items = Array.from(game.items);
      item = findSimilarItem(items, itemData);
      if (!item) {
        setProperty(itemData, CONSTANTS.FLAGS.TEMPORARY_ITEM, true);
        item = await Item.implementation.create(itemData);
        custom_notify(`An item has been created for ${item.name} - drag and drop it into the list to update the stored item data`);
      }
    }
    item.sheet.render(true);
  }
  removeEntry(index) {
    const currencies = get_store_value(this.currencies);
    currencies.splice(index, 1);
    this.currencies.set(currencies);
  }
  export() {
    return get_store_value(this.currencies);
  }
}
__name(CurrencyStore, "CurrencyStore");
const currenciesEditorShell_svelte_svelte_type_style_lang = "";
function create_default_slot$d(ctx) {
  let form_1;
  let p0;
  let t1;
  let p1;
  let t3;
  let p2;
  let t5;
  let currencylist;
  let t6;
  let footer;
  let button0;
  let i0;
  let t7;
  let t8_value = localize("ITEM-PILES.Applications.CurrenciesEditor.Submit") + "";
  let t8;
  let t9;
  let button1;
  let i1;
  let t10;
  let t11_value = localize("Cancel") + "";
  let t11;
  let current;
  let mounted;
  let dispose;
  currencylist = new CurrencyList({ props: { store: ctx[4] } });
  return {
    c() {
      form_1 = element("form");
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.CurrenciesEditor.Explanation")}`;
      t1 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.CurrenciesEditor.ExplanationSmallAttributes")}`;
      t3 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.CurrenciesEditor.ExplanationSmallItems")}`;
      t5 = space();
      create_component(currencylist.$$.fragment);
      t6 = space();
      footer = element("footer");
      button0 = element("button");
      i0 = element("i");
      t7 = space();
      t8 = text(t8_value);
      t9 = space();
      button1 = element("button");
      i1 = element("i");
      t10 = space();
      t11 = text(t11_value);
      attr(p1, "class", "small svelte-19gcezu");
      attr(p2, "class", "small item-piles-bottom-divider svelte-19gcezu");
      attr(i0, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i1, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(footer, "class", "svelte-19gcezu");
      attr(form_1, "autocomplete", "off");
      attr(form_1, "class", "svelte-19gcezu");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p0);
      append(form_1, t1);
      append(form_1, p1);
      append(form_1, t3);
      append(form_1, p2);
      append(form_1, t5);
      mount_component(currencylist, form_1, null);
      append(form_1, t6);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i0);
      append(button0, t7);
      append(button0, t8);
      append(footer, t9);
      append(footer, button1);
      append(button1, i1);
      append(button1, t10);
      append(button1, t11);
      ctx[8](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[1], { once: true }),
          listen(button1, "click", ctx[7], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[5]))
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(currencylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(currencylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(currencylist);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$d, "create_default_slot$d");
function create_fragment$u(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[9](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$d] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 1028) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$u, "create_fragment$u");
function instance$u($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { data } = $$props;
  let { elementRoot } = $$props;
  const store = new CurrencyStore(data || getSetting(SETTINGS.CURRENCIES));
  let form;
  async function updateSettings() {
    application.options.resolve(store.export());
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(2, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(6, data = $$props2.data);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [
    elementRoot,
    requestSubmit,
    form,
    application,
    store,
    updateSettings,
    data,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$u, "instance$u");
class Currencies_editor_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$u, safe_not_equal, {
      data: 6,
      elementRoot: 0,
      requestSubmit: 1
    });
  }
  get data() {
    return this.$$.ctx[6];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[1];
  }
}
__name(Currencies_editor_shell, "Currencies_editor_shell");
class CurrenciesEditor extends SvelteApplication {
  constructor(data = false, options = {}) {
    super({
      svelte: {
        class: Currencies_editor_shell,
        target: document.body,
        props: {
          data
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Applications.CurrenciesEditor.Title"),
      width: 630,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static async show(data = false, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(data, options).render(true, { focus: true });
    });
  }
}
__name(CurrenciesEditor, "CurrenciesEditor");
const itemFiltersEditor_svelte_svelte_type_style_lang = "";
function get_each_context$f(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i].path;
  child_ctx[14] = list[i].filters;
  child_ctx[15] = list;
  child_ctx[16] = i;
  return child_ctx;
}
__name(get_each_context$f, "get_each_context$f");
function create_each_block$f(key_1, ctx) {
  let tr;
  let td0;
  let input0;
  let t0;
  let td1;
  let input1;
  let t1;
  let td2;
  let button;
  let t2;
  let mounted;
  let dispose;
  function input0_input_handler() {
    ctx[8].call(input0, ctx[15], ctx[16]);
  }
  __name(input0_input_handler, "input0_input_handler");
  function input1_input_handler() {
    ctx[9].call(input1, ctx[15], ctx[16]);
  }
  __name(input1_input_handler, "input1_input_handler");
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      input0 = element("input");
      t0 = space();
      td1 = element("td");
      input1 = element("input");
      t1 = space();
      td2 = element("td");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      t2 = space();
      attr(input0, "type", "text");
      input0.required = true;
      attr(input0, "placeholder", "type");
      attr(input1, "type", "text");
      input1.required = true;
      attr(input1, "placeholder", "class, spell, feat");
      attr(button, "type", "button");
      attr(button, "class", "svelte-19toc95");
      attr(td2, "class", "custom-small svelte-19toc95");
      attr(tr, "class", "svelte-19toc95");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, input0);
      set_input_value(input0, ctx[13]);
      append(tr, t0);
      append(tr, td1);
      append(td1, input1);
      set_input_value(input1, ctx[14]);
      append(tr, t1);
      append(tr, td2);
      append(td2, button);
      append(tr, t2);
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler),
          listen(input1, "input", input1_input_handler),
          listen(button, "click", function() {
            if (is_function(ctx[6](ctx[16])))
              ctx[6](ctx[16]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && input0.value !== ctx[13]) {
        set_input_value(input0, ctx[13]);
      }
      if (dirty & 1 && input1.value !== ctx[14]) {
        set_input_value(input1, ctx[14]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$f, "create_each_block$f");
function create_default_slot$c(ctx) {
  let form_1;
  let p;
  let t1;
  let table;
  let tr;
  let th0;
  let t3;
  let th1;
  let t5;
  let th2;
  let a;
  let t6;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t7;
  let footer;
  let button0;
  let i1;
  let t8;
  let t9_value = localize("ITEM-PILES.Applications.FilterEditor.Submit") + "";
  let t9;
  let t10;
  let button1;
  let i2;
  let t11;
  let t12_value = localize("Cancel") + "";
  let t12;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[16], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$f(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
  }
  return {
    c() {
      form_1 = element("form");
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Applications.FilterEditor.Explanation")}`;
      t1 = space();
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th0.textContent = `${localize("ITEM-PILES.Applications.FilterEditor.Path")}`;
      t3 = space();
      th1 = element("th");
      th1.textContent = `${localize("ITEM-PILES.Applications.FilterEditor.Filters")}`;
      t5 = space();
      th2 = element("th");
      a = element("a");
      a.innerHTML = `<i class="fas fa-plus"></i>`;
      t6 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t7 = space();
      footer = element("footer");
      button0 = element("button");
      i1 = element("i");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      button1 = element("button");
      i2 = element("i");
      t11 = space();
      t12 = text(t12_value);
      attr(a, "class", "item-piles-clickable svelte-19toc95");
      attr(th2, "class", "custom-small svelte-19toc95");
      attr(tr, "class", "svelte-19toc95");
      attr(table, "class", "svelte-19toc95");
      attr(i1, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i2, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p);
      append(form_1, t1);
      append(form_1, table);
      append(table, tr);
      append(tr, th0);
      append(tr, t3);
      append(tr, th1);
      append(tr, t5);
      append(tr, th2);
      append(th2, a);
      append(table, t6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      append(form_1, t7);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i1);
      append(button0, t8);
      append(button0, t9);
      append(footer, t10);
      append(footer, button1);
      append(button1, i2);
      append(button1, t11);
      append(button1, t12);
      ctx[11](form_1);
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[5]),
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[10], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[7]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 65) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, destroy_block, create_each_block$f, null, get_each_context$f);
      }
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$c, "create_default_slot$c");
function create_fragment$t(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[12](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$c] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 131081) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$t, "create_fragment$t");
function instance$t($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { itemFilters } = $$props;
  let { elementRoot } = $$props;
  let form;
  if (!itemFilters) {
    itemFilters = getSetting(SETTINGS.ITEM_FILTERS);
  }
  function add() {
    $$invalidate(0, itemFilters = [...itemFilters, { path: "", filters: "" }]);
    $$invalidate(0, itemFilters);
  }
  __name(add, "add");
  function remove(index) {
    itemFilters.splice(index, 1);
    $$invalidate(0, itemFilters);
  }
  __name(remove, "remove");
  async function updateSettings() {
    application.options.resolve(itemFilters);
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function input0_input_handler(each_value, index) {
    each_value[index].path = this.value;
    $$invalidate(0, itemFilters);
  }
  __name(input0_input_handler, "input0_input_handler");
  function input1_input_handler(each_value, index) {
    each_value[index].filters = this.value;
    $$invalidate(0, itemFilters);
  }
  __name(input1_input_handler, "input1_input_handler");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("itemFilters" in $$props2)
      $$invalidate(0, itemFilters = $$props2.itemFilters);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
  };
  return [
    itemFilters,
    elementRoot,
    requestSubmit,
    form,
    application,
    add,
    remove,
    updateSettings,
    input0_input_handler,
    input1_input_handler,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$t, "instance$t");
class Item_filters_editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$t, safe_not_equal, {
      itemFilters: 0,
      elementRoot: 1,
      requestSubmit: 2
    });
  }
  get itemFilters() {
    return this.$$.ctx[0];
  }
  set itemFilters(itemFilters) {
    this.$$set({ itemFilters });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Item_filters_editor, "Item_filters_editor");
class ItemFiltersEditor extends SvelteApplication {
  constructor(itemFilters, options) {
    super({
      title: "ITEM-PILES.Applications.FilterEditor.Title",
      svelte: {
        class: Item_filters_editor,
        target: document.body,
        props: {
          itemFilters
        }
      },
      close: () => this.options.resolve(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Applications.FilterEditor.Title"),
      width: 400,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static async show(itemFilters, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(itemFilters, options).render(true, { focus: true });
    });
  }
}
__name(ItemFiltersEditor, "ItemFiltersEditor");
const Tabs_svelte_svelte_type_style_lang = "";
function get_each_context$e(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
__name(get_each_context$e, "get_each_context$e");
function create_if_block_2$f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      set_style(div, "border-right", "1px solid rgba(0,0,0,0.5)");
      set_style(div, "margin", "0 10px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_2$f, "create_if_block_2$f");
function create_if_block_1$g(ctx) {
  let i;
  let i_class_value;
  return {
    c() {
      i = element("i");
      attr(i, "class", i_class_value = "icon " + ctx[6].icon + " svelte-ujhhv1");
    },
    m(target, anchor) {
      insert(target, i, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && i_class_value !== (i_class_value = "icon " + ctx2[6].icon + " svelte-ujhhv1")) {
        attr(i, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(i);
    }
  };
}
__name(create_if_block_1$g, "create_if_block_1$g");
function create_if_block$n(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-exclamation"></i>`;
      attr(div, "class", "blob");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block$n, "create_if_block$n");
function create_each_block$e(key_1, ctx) {
  let first;
  let t0;
  let div;
  let t1;
  let t2_value = localize(ctx[6].label) + "";
  let t2;
  let t3;
  let t4;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && ctx[8] > 0 && create_if_block_2$f();
  let if_block1 = ctx[6].icon && create_if_block_1$g(ctx);
  let if_block2 = ctx[6].highlight && create_if_block$n();
  function click_handler() {
    return ctx[5](ctx[6]);
  }
  __name(click_handler, "click_handler");
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      attr(div, "class", "item item-piles-flexrow item-piles-clickable-link svelte-ujhhv1");
      attr(div, "data-tab", "rest");
      toggle_class(div, "underscore", ctx[2]);
      toggle_class(div, "active", ctx[0] === ctx[6].value);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t4);
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[3] && ctx[8] > 0) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_2$f();
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[6].icon) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_1$g(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 2 && t2_value !== (t2_value = localize(ctx[6].label) + ""))
        set_data(t2, t2_value);
      if (ctx[6].highlight) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block$n();
          if_block2.c();
          if_block2.m(div, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & 4) {
        toggle_class(div, "underscore", ctx[2]);
      }
      if (dirty & 3) {
        toggle_class(div, "active", ctx[0] === ctx[6].value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block$e, "create_each_block$e");
function create_fragment$s(ctx) {
  let nav;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let nav_style_value;
  let each_value = ctx[1].filter(func$2);
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[6].value, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$e(key, child_ctx));
  }
  return {
    c() {
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(nav, "class", "tabs svelte-ujhhv1");
      attr(nav, "data-group", "primary");
      attr(nav, "style", nav_style_value = ctx[4].style);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(nav, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 15) {
        each_value = ctx2[1].filter(func$2);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, nav, destroy_block, create_each_block$e, null, get_each_context$e);
      }
      if (dirty & 16 && nav_style_value !== (nav_style_value = ctx2[4].style)) {
        attr(nav, "style", nav_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_fragment$s, "create_fragment$s");
const func$2 = /* @__PURE__ */ __name((tab) => !tab.hidden, "func$2");
function instance$s($$self, $$props, $$invalidate) {
  let { activeTab } = $$props;
  let { tabs } = $$props;
  let { underscore = false } = $$props;
  let { separateElements = false } = $$props;
  const click_handler = /* @__PURE__ */ __name((tab) => {
    $$invalidate(0, activeTab = tab.value);
  }, "click_handler");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("activeTab" in $$new_props)
      $$invalidate(0, activeTab = $$new_props.activeTab);
    if ("tabs" in $$new_props)
      $$invalidate(1, tabs = $$new_props.tabs);
    if ("underscore" in $$new_props)
      $$invalidate(2, underscore = $$new_props.underscore);
    if ("separateElements" in $$new_props)
      $$invalidate(3, separateElements = $$new_props.separateElements);
  };
  $$props = exclude_internal_props($$props);
  return [activeTab, tabs, underscore, separateElements, $$props, click_handler];
}
__name(instance$s, "instance$s");
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$s, safe_not_equal, {
      activeTab: 0,
      tabs: 1,
      underscore: 2,
      separateElements: 3
    });
  }
}
__name(Tabs, "Tabs");
class API {
  static get ACTOR_CLASS_TYPE() {
    return getSetting(SETTINGS.ACTOR_CLASS_TYPE);
  }
  static get CURRENCIES() {
    return getSetting(SETTINGS.CURRENCIES);
  }
  static get CURRENCY_DECIMAL_DIGITS() {
    return getSetting(SETTINGS.CURRENCY_DECIMAL_DIGITS);
  }
  static get ITEM_PRICE_ATTRIBUTE() {
    return getSetting(SETTINGS.ITEM_PRICE_ATTRIBUTE);
  }
  static get ITEM_QUANTITY_ATTRIBUTE() {
    return getSetting(SETTINGS.ITEM_QUANTITY_ATTRIBUTE);
  }
  static get ITEM_FILTERS() {
    return getSetting(SETTINGS.ITEM_FILTERS);
  }
  static get ITEM_SIMILARITIES() {
    return getSetting(SETTINGS.ITEM_SIMILARITIES);
  }
  static async setActorClassType(inClassType) {
    if (typeof inClassType !== "string") {
      throw custom_error("setActorTypeClass | inClassType must be of type string");
    }
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.ACTOR_CLASS_TYPE, inClassType);
      resolve();
    });
  }
  static async setCurrencies(inCurrencies) {
    if (!Array.isArray(inCurrencies)) {
      throw custom_error("setCurrencies | inCurrencies must be an array");
    }
    inCurrencies.forEach((currency) => {
      if (typeof currency !== "object") {
        throw custom_error("setCurrencies | each entry in inCurrencies must be of type object");
      }
      if (typeof currency.primary !== "boolean") {
        throw custom_error("setCurrencies | currency.primary must be of type boolean");
      }
      if (typeof currency.name !== "string") {
        throw custom_error("setCurrencies | currency.name must be of type string");
      }
      if (typeof currency.abbreviation !== "string") {
        throw custom_error("setCurrencies | currency.abbreviation must be of type string");
      }
      if (typeof currency.exchangeRate !== "number") {
        throw custom_error("setCurrencies | currency.exchangeRate must be of type number");
      }
      if (typeof currency.data !== "object") {
        throw custom_error("setCurrencies | currency.data must be of type object");
      }
      if (typeof currency.data.path !== "string" && typeof currency.data.uuid !== "string" && typeof currency.data.item !== "object") {
        throw custom_error('setCurrencies | currency.data must contain either "path" (string), "uuid" (string), or "item" (object)');
      }
      if (currency.img && typeof currency.img !== "string") {
        throw custom_error("setCurrencies | currency.img must be of type string");
      }
    });
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.CURRENCIES, inCurrencies);
      resolve();
    });
  }
  static setCurrencyDecimalDigits(inDecimalDigits) {
    if (typeof inDecimalDigits !== "number") {
      throw custom_error("setCurrencyDecimalDigits | inDecimalDigits must be of type string");
    }
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.CURRENCY_DECIMAL_DIGITS, inDecimalDigits);
      resolve();
    });
  }
  static async setItemQuantityAttribute(inAttribute) {
    if (typeof inAttribute !== "string") {
      throw custom_error("setItemQuantityAttribute | inAttribute must be of type string");
    }
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.ITEM_QUANTITY_ATTRIBUTE, inAttribute);
      resolve();
    });
  }
  static async setItemPriceAttribute(inAttribute) {
    if (typeof inAttribute !== "string") {
      throw custom_error("setItemPriceAttribute | inAttribute must be of type string");
    }
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.ITEM_PRICE_ATTRIBUTE, inAttribute);
      resolve();
    });
  }
  static async setItemFilters(inFilters) {
    if (!Array.isArray(inFilters)) {
      throw custom_error("setItemFilters | inFilters must be of type array");
    }
    inFilters.forEach((filter) => {
      if (typeof filter?.path !== "string") {
        throw custom_error('setItemFilters | each entry in inFilters must have a "path" property with a value that is of type string');
      }
      if (typeof filter?.filters !== "string") {
        throw custom_error('setItemFilters | each entry in inFilters must have a "filters" property with a value that is of type string');
      }
    });
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.ITEM_FILTERS, inFilters);
      resolve();
    });
  }
  static async setItemSimilarities(inPaths) {
    if (!Array.isArray(inPaths)) {
      throw custom_error("setItemSimilarities | inPaths must be of type array");
    }
    inPaths.forEach((path) => {
      if (typeof path !== "string") {
        throw custom_error("setItemSimilarities | each entry in inPaths must be of type string");
      }
    });
    return new Promise(async (resolve) => {
      await setSetting(SETTINGS.PRECONFIGURED_SYSTEM, true);
      await setSetting(SETTINGS.ITEM_SIMILARITIES, inPaths);
      resolve();
    });
  }
  static async getPrimaryCurrency(actor = false) {
    if (actor && actor instanceof Actor) {
      return getActorPrimaryCurrency(actor);
    }
    return this.CURRENCIES.find((currency) => currency.primary);
  }
  static async createItemPile({
    position = false,
    sceneId = game.user.viewedScene,
    tokenOverrides = {},
    actorOverrides = {},
    itemPileFlags = {},
    items = false,
    createActor = false,
    actor = false
  } = {}) {
    if (position) {
      if (typeof position !== "object") {
        throw custom_error(`createItemPile | position must be of type object`);
      } else if (!isRealNumber(position.x) || !isRealNumber(position.y)) {
        throw custom_error(`createItemPile | position.x and position.y must be of type numbers`);
      }
    }
    if (actor && !createActor) {
      if (typeof actor !== "string") {
        throw custom_error(`createItemPile | actor must be of type string`);
      }
      let pileActor = await fromUuid(actor);
      if (!pileActor) {
        pileActor = game.actors.getName(actor);
      }
      if (!pileActor) {
        pileActor = game.actors.get(actor);
      }
      if (!pileActor) {
        throw custom_error(`createItemPile | Could not find actor with the identifier of "${actor}"`);
      }
      actor = pileActor.uuid;
    }
    if (typeof sceneId !== "string") {
      throw custom_error(`createItemPile | sceneId must be of type string`);
    }
    if (typeof tokenOverrides !== "object") {
      throw custom_error(`createItemPile | tokenOverrides must be of type object`);
    }
    if (typeof actorOverrides !== "object") {
      throw custom_error(`createItemPile | tokenOverrides must be of type object`);
    }
    if (typeof itemPileFlags !== "object") {
      throw custom_error(`createItemPile | tokenOverrides must be of type object`);
    }
    if (items) {
      if (!Array.isArray(items))
        items = [items];
      items = items.map((item) => {
        return item instanceof Item ? item.toObject() : item;
      });
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.CREATE_PILE, {
      sceneId,
      position,
      actor,
      createActor,
      items,
      tokenOverrides,
      actorOverrides,
      itemPileFlags
    });
  }
  static turnTokensIntoItemPiles(targets, { pileSettings = {}, tokenSettings = {} } = {}) {
    if (!Array.isArray(targets))
      targets = [targets];
    const targetUuids = targets.map((target) => {
      if (!(target instanceof Token || target instanceof TokenDocument)) {
        throw custom_error(`turnTokensIntoItemPiles | Target must be of type Token or TokenDocument`);
      }
      const targetUuid = getUuid(target);
      if (!targetUuid)
        throw custom_error(`turnTokensIntoItemPiles | Could not determine the UUID, please provide a valid target`);
      return targetUuid;
    });
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TURN_INTO_PILE, targetUuids, pileSettings, tokenSettings);
  }
  static revertTokensFromItemPiles(targets, { tokenSettings = {} } = {}) {
    if (!Array.isArray(targets))
      targets = [targets];
    const targetUuids = targets.map((target) => {
      if (!(target instanceof Token || target instanceof TokenDocument)) {
        throw custom_error(`revertTokensFromItemPiles | Target must be of type Token or TokenDocument`);
      }
      const targetUuid = getUuid(target);
      if (!targetUuid)
        throw custom_error(`revertTokensFromItemPiles | Could not determine the UUID, please provide a valid target`);
      return targetUuid;
    });
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.REVERT_FROM_PILE, targetUuids, tokenSettings);
  }
  static openItemPile(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    const wasLocked = pileData.locked;
    const wasClosed = pileData.closed;
    pileData.closed = false;
    pileData.locked = false;
    if (wasLocked) {
      const hookResult2 = hooks.call(HOOKS.PILE.PRE_UNLOCK, targetActor, pileData, interactingTokenDocument);
      if (hookResult2 === false)
        return false;
    }
    const hookResult = hooks.call(HOOKS.PILE.PRE_OPEN, targetActor, pileData, interactingTokenDocument);
    if (hookResult === false)
      return false;
    if (wasClosed && pileData.openSound) {
      let sound = pileData.openSound;
      if (pileData.openSound.includes("*")) {
        sound = random_array_element(pileData.openSounds);
      }
      AudioHelper.play({ src: sound }, true);
    }
    return this.updateItemPile(targetActor, pileData, { interactingToken: interactingTokenDocument });
  }
  static closeItemPile(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    const wasOpen = !pileData.closed;
    pileData.closed = true;
    const hookResult = hooks.call(HOOKS.PILE.PRE_CLOSE, targetActor, pileData, interactingTokenDocument);
    if (hookResult === false)
      return false;
    if (wasOpen && pileData.closeSound) {
      let sound = pileData.closeSound;
      if (pileData.closeSound.includes("*")) {
        sound = random_array_element(pileData.closeSounds);
      }
      AudioHelper.play({ src: sound }, true);
    }
    return this.updateItemPile(targetActor, pileData, { interactingToken: interactingTokenDocument });
  }
  static async toggleItemPileClosed(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    if (pileData.closed) {
      await this.openItemPile(targetActor, interactingTokenDocument);
    } else {
      await this.closeItemPile(targetActor, interactingTokenDocument);
    }
    return !pileData.closed;
  }
  static lockItemPile(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    const wasClosed = pileData.closed;
    pileData.closed = true;
    pileData.locked = true;
    if (!wasClosed) {
      const hookResult2 = hooks.call(HOOKS.PILE.PRE_CLOSE, targetActor, pileData, interactingTokenDocument);
      if (hookResult2 === false)
        return false;
    }
    const hookResult = hooks.call(HOOKS.PILE.PRE_LOCK, targetActor, pileData, interactingTokenDocument);
    if (hookResult === false)
      return false;
    if (!wasClosed && pileData.closeSound) {
      let sound = pileData.closeSound;
      if (pileData.closeSound.includes("*")) {
        sound = random_array_element(pileData.closeSounds);
      }
      AudioHelper.play({ src: sound }, true);
    }
    return this.updateItemPile(targetActor, pileData, { interactingToken: interactingTokenDocument });
  }
  static unlockItemPile(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    pileData.locked = false;
    hooks.call(HOOKS.PILE.PRE_UNLOCK, targetActor, pileData, interactingTokenDocument);
    return this.updateItemPile(targetActor, pileData, { interactingToken: interactingTokenDocument });
  }
  static toggleItemPileLocked(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer)
      return false;
    if (pileData.locked) {
      return this.unlockItemPile(targetActor, interactingTokenDocument);
    }
    return this.lockItemPile(targetActor, interactingTokenDocument);
  }
  static rattleItemPile(target, interactingToken = false) {
    const targetActor = getActor(target);
    const interactingTokenDocument = interactingToken ? getActor(interactingToken) : false;
    const pileData = getActorFlagData(targetActor);
    if (!pileData?.enabled || !pileData?.isContainer || !pileData?.locked)
      return false;
    hooks.call(HOOKS.PILE.PRE_RATTLE, targetActor, pileData, interactingTokenDocument);
    if (pileData.lockedSound) {
      let sound = pileData.lockedSound;
      if (pileData.lockedSound.includes("*")) {
        sound = random_array_element(pileData.lockedSounds);
      }
      AudioHelper.play({ src: sound }, true);
    }
    return ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.CALL_HOOK, HOOKS.PILE.RATTLE, getUuid(targetActor), pileData, getUuid(interactingTokenDocument));
  }
  static isItemPileLocked(target) {
    return isItemPileLocked(target);
  }
  static isItemPileClosed(target) {
    return isItemPileClosed(target);
  }
  static isItemPileContainer(target) {
    return isItemPileContainer(target);
  }
  static updateItemPile(target, newData, { interactingToken = false, tokenSettings = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`updateItemPile | Could not determine the UUID, please provide a valid target`);
    const interactingTokenUuid = interactingToken ? getUuid(interactingToken) : false;
    if (interactingToken && !interactingTokenUuid)
      throw custom_error(`updateItemPile | Could not determine the UUID, please provide a valid target`);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.UPDATE_PILE, targetUuid, newData, {
      interactingTokenUuid,
      tokenSettings
    });
  }
  static deleteItemPile(target) {
    if (!isValidItemPile(target)) {
      throw custom_error(`deleteItemPile | This is not an item pile, please provide a valid target`);
    }
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`deleteItemPile | Could not determine the UUID, please provide a valid target`);
    if (!targetUuid.includes("Token")) {
      throw custom_error(`deleteItemPile | Please provide a Token or TokenDocument`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DELETE_PILE, targetUuid);
  }
  static async splitItemPileContents(target, { targets = false, instigator = false } = {}) {
    if (!isValidItemPile(target))
      return false;
    const itemPileUuid = getUuid(target);
    if (!itemPileUuid)
      throw custom_error(`SplitItemPileContents | Could not determine the UUID, please provide a valid item pile`);
    const itemPileActor = getActor(target);
    if (targets) {
      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      targets.forEach((actor) => {
        if (!(actor instanceof TokenDocument || actor instanceof Actor)) {
          throw custom_error("SplitItemPileContents | Each of the entries in targets must be of type TokenDocument or Actor");
        }
      });
      targets = targets.map((target2) => target2?.character ?? target2?.actor ?? target2);
    }
    if (instigator && !(instigator instanceof TokenDocument || instigator instanceof Actor)) {
      throw custom_error("SplitItemPileContents | instigator must be of type TokenDocument or Actor");
    }
    const actorUuids = (targets || getPlayersForItemPile(itemPileActor).map((u) => u.character)).map((actor) => getUuid(actor));
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.SPLIT_PILE, itemPileUuid, actorUuids, game.user.id, instigator);
  }
  static addItems(target, items, {
    mergeSimilarItems = true,
    removeExistingActorItems = false,
    interactionId = false
  } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`addItems | Could not determine the UUID, please provide a valid target`);
    const itemsToAdd = [];
    items.forEach((itemData) => {
      let item = itemData;
      if (itemData instanceof Item) {
        item = itemData.toObject();
      } else if (itemData.item instanceof Item) {
        item = itemData.item.toObject();
      } else if (itemData.item) {
        item = itemData.item;
      }
      if (itemData?.quantity !== void 0) {
        setItemQuantity(item, itemData.quantity, true);
      }
      const existingItems = mergeSimilarItems ? findSimilarItem(itemsToAdd, item) : false;
      if (existingItems && canItemStack(item)) {
        setItemQuantity(existingItems, getItemQuantity(existingItems) + getItemQuantity(item));
      } else {
        itemsToAdd.push(item);
      }
    });
    if (interactionId && typeof interactionId !== "string")
      throw custom_error(`addItems | interactionId must be of type string`);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.ADD_ITEMS, targetUuid, itemsToAdd, game.user.id, {
      removeExistingActorItems,
      interactionId
    });
  }
  static removeItems(target, items, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`removeItems | Could not determine the UUID, please provide a valid target`);
    const targetActorItems = getActorItems(target, { getItemCurrencies: true });
    items = items.map((itemData) => {
      let item;
      if (typeof itemData === "string" || itemData._id) {
        const itemId = typeof itemData === "string" ? itemData : itemData._id;
        item = targetActorItems.find((actorItem) => actorItem.id === itemId);
        if (!item) {
          throw custom_error(`removeItems | Could not find item with id "${itemId}" on target "${targetUuid}"`);
        }
        item = item.toObject();
      } else {
        if (itemData.item instanceof Item) {
          item = itemData.item.toObject();
        } else if (itemData instanceof Item) {
          item = itemData.toObject();
        } else {
          item = itemData.item;
        }
        let foundActorItem = targetActorItems.find((actorItem) => actorItem.id === item._id);
        if (!foundActorItem) {
          throw custom_error(`removeItems | Could not find item with id "${item._id}" on target "${targetUuid}"`);
        }
      }
      return {
        _id: item._id,
        quantity: itemData?.quantity ?? getItemQuantity(item)
      };
    });
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`removeItems | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.REMOVE_ITEMS, targetUuid, items, game.user.id, { interactionId });
  }
  static transferItems(source, target, items, { interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferItems | Could not determine the UUID, please provide a valid source`);
    const sourceActorItems = getActorItems(source, { getItemCurrencies: true });
    items = items.map((itemData) => {
      let item;
      if (typeof itemData === "string" || itemData._id) {
        const itemId = typeof itemData === "string" ? itemData : itemData._id;
        item = sourceActorItems.find((actorItem) => actorItem.id === itemId);
        if (!item) {
          throw custom_error(`transferItems | Could not find item with id "${itemId}" on target "${sourceUuid}"`);
        }
        item = item.toObject();
      } else if (itemData instanceof Item) {
        item = itemData.toObject();
      } else if (itemData.item instanceof Item) {
        item = itemData.item.toObject();
      } else {
        item = itemData.item;
      }
      let foundActorItem = sourceActorItems.find((actorItem) => actorItem.id === item._id);
      if (!foundActorItem) {
        throw custom_error(`transferItems | Could not find item with id "${item._id}" on target "${sourceUuid}"`);
      }
      return {
        _id: item._id,
        quantity: Math.max(itemData?.quantity ?? 0 ?? getItemQuantity(itemData))
      };
    });
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferItems | Could not determine the UUID, please provide a valid target`);
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`transferItems | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_ITEMS, sourceUuid, targetUuid, items, game.user.id, { interactionId });
  }
  static transferAllItems(source, target, { itemFilters = false, interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferAllItems | Could not determine the UUID, please provide a valid source`);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferAllItems | Could not determine the UUID, please provide a valid target`);
    if (itemFilters) {
      if (!Array.isArray(itemFilters))
        throw custom_error(`transferAllItems | itemFilters must be of type array`);
      itemFilters.forEach((entry) => {
        if (typeof entry?.path !== "string")
          throw custom_error(`transferAllItems | each entry in the itemFilters must have a "path" property that is of type string`);
        if (typeof entry?.filter !== "string")
          throw custom_error(`transferAllItems | each entry in the itemFilters must have a "filter" property that is of type string`);
      });
    }
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`transferAllItems | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_ALL_ITEMS, sourceUuid, targetUuid, game.user.id, {
      itemFilters,
      interactionId
    });
  }
  static setAttributes(target, attributes2, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`setAttributes | Could not determine the UUID, please provide a valid target`);
    const targetActor = getActor(target);
    Object.entries(attributes2).forEach((entry) => {
      const [attribute, quantity] = entry;
      if (!hasProperty(targetActor, attribute)) {
        throw custom_error(`setAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
      }
      if (!isRealNumber(quantity)) {
        throw custom_error(`setAttributes | Attribute "${attribute}" must be of type number`);
      }
    });
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`setAttributes | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.SET_ATTRIBUTES, targetUuid, attributes2, game.user.id, { interactionId });
  }
  static addAttributes(target, attributes2, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`addAttributes | Could not determine the UUID, please provide a valid target`);
    const targetActor = getActor(target);
    Object.entries(attributes2).forEach((entry) => {
      const [attribute, quantity] = entry;
      if (!hasProperty(targetActor, attribute)) {
        throw custom_error(`addAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
      }
      if (!isRealNumber(quantity) && quantity > 0) {
        throw custom_error(`addAttributes | Attribute "${attribute}" must be of type number and greater than 0`);
      }
    });
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`addAttributes | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.ADD_ATTRIBUTES, targetUuid, attributes2, game.user.id, { interactionId });
  }
  static removeAttributes(target, attributes2, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`removeAttributes | Could not determine the UUID, please provide a valid target`);
    const targetActor = getActor(target);
    let attributesToSend = {};
    if (Array.isArray(attributes2)) {
      attributes2.forEach((attribute) => {
        if (typeof attribute !== "string") {
          throw custom_error(`removeAttributes | Each attribute in the array must be of type string`);
        }
        if (!hasProperty(targetActor, attribute)) {
          throw custom_error(`removeAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
        }
        attributesToSend[attribute] = Number(getProperty(targetActor, attribute));
      });
    } else {
      Object.entries(attributes2).forEach((entry) => {
        const [attribute, quantity] = entry;
        if (!hasProperty(targetActor, attribute)) {
          throw custom_error(`removeAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
        }
        if (!isRealNumber(quantity) && quantity > 0) {
          throw custom_error(`removeAttributes | Attribute "${attribute}" must be of type number and greater than 0`);
        }
      });
      attributesToSend = attributes2;
    }
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`removeAttributes | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.REMOVE_ATTRIBUTES, targetUuid, attributesToSend, game.user.id, { interactionId });
  }
  static transferAttributes(source, target, attributes2, { interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferAttributes | Could not determine the UUID, please provide a valid source`);
    const sourceActor = getActor(source);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferAttributes | Could not determine the UUID, please provide a valid target`);
    const targetActor = getActor(target);
    if (Array.isArray(attributes2)) {
      attributes2.forEach((attribute) => {
        if (typeof attribute !== "string") {
          throw custom_error(`transferAttributes | Each attribute in the array must be of type string`);
        }
        if (!hasProperty(sourceActor, attribute)) {
          throw custom_error(`transferAttributes | Could not find attribute ${attribute} on source's actor with UUID "${targetUuid}"`);
        }
        if (!hasProperty(targetActor, attribute)) {
          throw custom_error(`transferAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
        }
      });
    } else {
      Object.entries(attributes2).forEach((entry) => {
        const [attribute, quantity] = entry;
        if (!hasProperty(sourceActor, attribute)) {
          throw custom_error(`transferAttributes | Could not find attribute ${attribute} on source's actor with UUID "${targetUuid}"`);
        }
        if (!hasProperty(targetActor, attribute)) {
          throw custom_error(`transferAttributes | Could not find attribute ${attribute} on target's actor with UUID "${targetUuid}"`);
        }
        if (!isRealNumber(quantity) && quantity > 0) {
          throw custom_error(`transferAttributes | Attribute "${attribute}" must be of type number and greater than 0`);
        }
      });
    }
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`transferAttributes | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_ATTRIBUTES, sourceUuid, targetUuid, attributes2, game.user.id, { interactionId });
  }
  static transferAllAttributes(source, target, { interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferAllAttributes | Could not determine the UUID, please provide a valid source`);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferAllAttributes | Could not determine the UUID, please provide a valid target`);
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`transferAllAttributes | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_ALL_ATTRIBUTES, sourceUuid, targetUuid, game.user.id, { interactionId });
  }
  static transferEverything(source, target, { itemFilters = false, interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferEverything | Could not determine the UUID, please provide a valid source`);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferEverything | Could not determine the UUID, please provide a valid target`);
    if (itemFilters) {
      if (!Array.isArray(itemFilters))
        throw custom_error(`transferEverything | itemFilters must be of type array`);
      itemFilters.forEach((entry) => {
        if (typeof entry?.path !== "string")
          throw custom_error(`transferEverything | each entry in the itemFilters must have a "path" property that is of type string`);
        if (typeof entry?.filter !== "string")
          throw custom_error(`transferEverything | each entry in the itemFilters must have a "filter" property that is of type string`);
      });
    }
    if (interactionId) {
      if (typeof interactionId !== "string")
        throw custom_error(`transferEverything | interactionId must be of type string`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_EVERYTHING, sourceUuid, targetUuid, game.user.id, {
      itemFilters,
      interactionId
    });
  }
  static getCurrenciesFromString(currencies) {
    if (typeof currencies !== "string") {
      throw custom_error(`getCurrenciesFromString | currencies must be of type string`);
    }
    return getPriceFromString(currencies).currencies;
  }
  static addCurrencies(target, currencies, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`addCurrency | Could not determine the UUID, please provide a valid target`);
    if (typeof currencies !== "string") {
      throw custom_error(`addCurrency | currencies must be of type string`);
    }
    const currenciesToAdd = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    if (!currenciesToAdd.length) {
      throw custom_error(`addCurrency | Could not determine currencies to add with string "${currencies}"`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.ADD_CURRENCIES, targetUuid, currencies, game.user.id, { interactionId });
  }
  static removeCurrencies(target, currencies, { interactionId = false } = {}) {
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`removeCurrencies | Could not determine the UUID, please provide a valid target`);
    if (typeof currencies !== "string") {
      throw custom_error(`removeCurrencies | currencies must be of type string`);
    }
    const currenciesToRemove = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    if (!currenciesToRemove.length) {
      throw custom_error(`removeCurrencies | Could not determine currencies to remove with string "${currencies}"`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.REMOVE_CURRENCIES, targetUuid, currencies, game.user.id, { interactionId });
  }
  static transferCurrencies(source, target, currencies, { interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferCurrencies | Could not determine the UUID, please provide a valid source`);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferCurrencies | Could not determine the UUID, please provide a valid target`);
    if (typeof currencies !== "string") {
      throw custom_error(`transferCurrencies | currencies must be of type string`);
    }
    const currenciesToTransfer = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    if (!currenciesToTransfer.length) {
      throw custom_error(`transferCurrencies | Could not determine currencies to transfer with string "${currencies}"`);
    }
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_CURRENCIES, sourceUuid, targetUuid, currencies, game.user.id, { interactionId });
  }
  static transferAllCurrencies(source, target, { interactionId = false } = {}) {
    const sourceUuid = getUuid(source);
    if (!sourceUuid)
      throw custom_error(`transferCurrencies | Could not determine the UUID, please provide a valid source`);
    const targetUuid = getUuid(target);
    if (!targetUuid)
      throw custom_error(`transferCurrencies | Could not determine the UUID, please provide a valid target`);
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRANSFER_ALL_CURRENCIES, sourceUuid, targetUuid, game.user.id, { interactionId });
  }
  static async rollItemTable(table, {
    timesToRoll = "1",
    resetTable = true,
    displayChat = false,
    rollData = {},
    targetActor = false,
    removeExistingActorItems = false
  } = {}) {
    let rollTable = table;
    if (typeof table === "string") {
      let potentialTable = await fromUuid(table);
      if (!potentialTable) {
        potentialTable = game.tables.get(table);
      }
      if (!potentialTable) {
        potentialTable = game.tables.getName(table);
      }
      if (!potentialTable) {
        throw custom_error(`rollItemTable | could not find table with string "${table}"`);
      }
      if (resetTable && table.startsWith("Compendium")) {
        resetTable = false;
      }
      rollTable = potentialTable;
    }
    if (!(rollTable instanceof RollTable)) {
      throw custom_error(`rollItemTable | table must be of type RollTable`);
    }
    table = rollTable.uuid;
    if (!(typeof timesToRoll === "string" || typeof timesToRoll === "number")) {
      throw custom_error(`rollItemTable | timesToRoll must be of type string or number`);
    }
    if (typeof rollData !== "object") {
      throw custom_error(`rollItemTable | rollData must be of type object`);
    }
    if (typeof removeExistingActorItems !== "boolean") {
      throw custom_error(`rollItemTable | removeExistingActorItems of type boolean`);
    }
    if (targetActor) {
      targetActor = getActor(targetActor);
      if (!(targetActor instanceof Actor)) {
        throw custom_error(`rollItemTable | could not find the actor of the target actor`);
      }
    }
    const items = await ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.ROLL_ITEM_TABLE, {
      table,
      timesToRoll,
      resetTable,
      displayChat,
      rollData,
      targetActor: getUuid(targetActor),
      removeExistingActorItems,
      userId: game.user.id
    });
    if (items) {
      for (const entry of items) {
        entry.item = targetActor ? targetActor.items.get(entry.item._id) : await Item.implementation.create(entry.item, { temporary: true });
      }
    }
    return items;
  }
  static getActorItems(target) {
    return getActorItems(target);
  }
  static getActorCurrencies(target, { getAll = false } = {}) {
    return getActorCurrencies(target, { getAll });
  }
  static updateTokenHud() {
    return ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.RERENDER_TOKEN_HUD);
  }
  static requestTrade(user) {
    return TradeAPI._requestTrade(user);
  }
  static spectateTrade(tradeId) {
    return TradeAPI._spectateTrade(tradeId);
  }
  static renderItemPileInterface(target, {
    userIds = null,
    inspectingTarget = null,
    useDefaultCharacter = false
  } = {}) {
    const targetDocument = getDocument(target);
    const targetUuid = getUuid(targetDocument);
    if (!targetUuid)
      throw custom_error(`renderItemPileInterface | Could not determine the UUID, please provide a valid target item pile`);
    if (!isValidItemPile(targetDocument)) {
      throw custom_error("renderItemPileInterface | This target is not a valid item pile");
    }
    if (!inspectingTarget && !useDefaultCharacter) {
      useDefaultCharacter = true;
    }
    if (inspectingTarget && useDefaultCharacter) {
      throw custom_error("renderItemPileInterface | You cannot force users to use both their default character and a specific character to inspect the pile");
    }
    const inspectingTargetUuid = inspectingTarget ? getUuid(inspectingTarget) : false;
    if (inspectingTarget && !inspectingTargetUuid)
      throw custom_error(`renderItemPileInterface | Could not determine the UUID, please provide a valid inspecting target`);
    if (!Array.isArray(userIds)) {
      if (userIds === null) {
        userIds = [game.user.id];
      } else {
        userIds = [userIds];
      }
    } else {
      userIds = userIds.map((user) => {
        return user instanceof User ? user.id : user;
      });
    }
    if (!game.user.isGM) {
      if (userIds.length > 1 || !userIds.includes(game.user.id)) {
        throw custom_error(`renderItemPileInterface | You are not a GM, so you cannot force others to render an item pile's interface`);
      }
      userIds = [game.user.id];
    }
    if (userIds.length === 1 && userIds[0] === game.user.id) {
      return PrivateAPI._renderItemPileInterface(targetUuid, {
        inspectingTargetUuid,
        useDefaultCharacter,
        remote: true
      });
    }
    for (const userId of userIds) {
      const user = game.users.get(userId);
      if (!user)
        throw custom_error(`renderItemPileInterface | No user with ID "${userId}" exists`);
      if (user.isGM)
        continue;
      if (useDefaultCharacter) {
        if (!user.character) {
          custom_warning(`renderItemPileInterface | User "${user.name}" has no default character`, true);
          return;
        }
      }
    }
    return ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.RENDER_INTERFACE, userIds, targetUuid, {
      inspectingTargetUuid,
      useDefaultCharacter,
      remote: true
    });
  }
  static getPricesForItem(item, { seller = false, buyer = false, quantity = 1 } = {}) {
    if (!(item instanceof Item)) {
      throw custom_error("getPricesForItem | The given item must be of type Item");
    }
    if (seller) {
      seller = getActor(seller);
      if (!seller) {
        throw custom_error("getPricesForItem | Could not determine actor for the seller");
      }
    } else {
      if (!item.parent) {
        throw custom_error("getPricesForItem | If no seller was given, the item must belong to an actor");
      }
      seller = getActor(item.parent);
    }
    if (buyer) {
      buyer = getActor(buyer);
      if (!buyer) {
        throw custom_error(`getPricesForItem | Could not determine the actor for the buyer`);
      }
    }
    return getItemPrices(item, { seller, buyer, quantity });
  }
  static tradeItems(seller, buyer, items, { interactionId = false } = {}) {
    const sellerActor = getActor(seller);
    const sellerUuid = getUuid(sellerActor);
    if (!sellerUuid) {
      throw custom_error(`tradeItems | Could not determine the UUID of the seller, please provide a valid actor or token`, true);
    }
    const buyerActor = getActor(buyer);
    const buyerUuid = getUuid(buyer);
    if (!buyerUuid) {
      throw custom_error(`tradeItems | Could not determine the UUID of the buyer, please provide a valid actor or token`, true);
    }
    const itemsToSell = items.map((data) => {
      data = foundry.utils.mergeObject({
        item: "",
        quantity: 1,
        paymentIndex: 0
      }, data);
      if (!data.item) {
        throw custom_error(`tradeItems | You must provide an item!`, true);
      }
      let actorItem;
      if (typeof data.item === "string") {
        actorItem = sellerActor.items.get(data.item) || sellerActor.items.getName(data.item);
        if (!actorItem) {
          throw custom_error(`tradeItems | Could not find item on seller with identifier "${data.item}"`);
        }
      } else {
        actorItem = sellerActor.items.get(data.item instanceof Item ? data.item.id : data.item._id) || sellerActor.items.getName(data.item.name);
        if (!actorItem) {
          throw custom_error(`tradeItems | Could not find provided item on seller`);
        }
      }
      const itemPrices = getItemPrices(actorItem, {
        seller: sellerActor,
        buyer: buyerActor,
        quantity: data.quantity
      });
      if (itemPrices.length) {
        if (data.paymentIndex >= itemPrices.length || data.paymentIndex < 0) {
          throw custom_error(`tradeItems | That payment index does not exist on ${actorItem.name}`, true);
        }
        const selectedPrice = itemPrices[data.paymentIndex];
        if (data.quantity > selectedPrice.maxQuantity) {
          throw custom_error(`tradeItems | The buyer actor cannot afford ${data.quantity} of ${actorItem.name} (max ${selectedPrice.maxQuantity})`, true);
        }
      }
      return {
        id: actorItem.id,
        quantity: data.quantity,
        paymentIndex: data.paymentIndex
      };
    });
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.TRADE_ITEMS, sellerUuid, buyerUuid, itemsToSell, game.user.id, { interactionId });
  }
}
__name(API, "API");
const itemTypePriceModifiersEditor_svelte_svelte_type_style_lang = "";
function get_each_context$d(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  child_ctx[19] = list;
  child_ctx[20] = i;
  return child_ctx;
}
__name(get_each_context$d, "get_each_context$d");
function get_each_context_1$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i][0];
  child_ctx[22] = list[i][1];
  return child_ctx;
}
__name(get_each_context_1$6, "get_each_context_1$6");
function create_else_block$8(ctx) {
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value_1 = ctx[6];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[21], "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$6(key, child_ctx));
  }
  function select_change_handler() {
    ctx[12].call(select, ctx[19], ctx[20]);
  }
  __name(select_change_handler, "select_change_handler");
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (ctx[18].type === void 0)
        add_render_callback(select_change_handler);
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[18].type);
      if (!mounted) {
        dispose = listen(select, "change", select_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 81) {
        each_value_1 = ctx[6];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, select, destroy_block, create_each_block_1$6, null, get_each_context_1$6);
      }
      if (dirty & 65) {
        select_option(select, ctx[18].type);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$8, "create_else_block$8");
function create_if_block$m(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[11].call(input, ctx[19], ctx[20]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Custom Category");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[18].category);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 65 && input.value !== ctx[18].category) {
        set_input_value(input, ctx[18].category);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$m, "create_if_block$m");
function create_each_block_1$6(key_1, ctx) {
  let option;
  let t0_value = localize(ctx[22]) + "";
  let t0;
  let t1;
  let option_disabled_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = ctx[21];
      option.value = option.__value;
      option.disabled = option_disabled_value = ctx[21] !== ctx[18].type && !ctx[4].includes(ctx[21]);
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 81 && option_disabled_value !== (option_disabled_value = ctx[21] !== ctx[18].type && !ctx[4].includes(ctx[21]))) {
        option.disabled = option_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block_1$6, "create_each_block_1$6");
function create_each_block$d(key_1, ctx) {
  let tr;
  let td0;
  let div0;
  let input;
  let t0;
  let td1;
  let div1;
  let t1;
  let td2;
  let div2;
  let sliderinput0;
  let updating_value;
  let t2;
  let td3;
  let div3;
  let sliderinput1;
  let updating_value_1;
  let t3;
  let td4;
  let button;
  let t4;
  let current;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[10].call(input, ctx[19], ctx[20]);
  }
  __name(input_change_handler, "input_change_handler");
  function select_block_type(ctx2, dirty) {
    if (ctx2[18].type === "custom")
      return create_if_block$m;
    return create_else_block$8;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  function sliderinput0_value_binding(value) {
    ctx[13](value, ctx[18]);
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  let sliderinput0_props = { style: "flex:4;" };
  if (ctx[18].buyPriceModifier !== void 0) {
    sliderinput0_props.value = ctx[18].buyPriceModifier;
  }
  sliderinput0 = new SliderInput({ props: sliderinput0_props });
  binding_callbacks.push(() => bind$1(sliderinput0, "value", sliderinput0_value_binding));
  function sliderinput1_value_binding(value) {
    ctx[14](value, ctx[18]);
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  let sliderinput1_props = { style: "flex:4;" };
  if (ctx[18].sellPriceModifier !== void 0) {
    sliderinput1_props.value = ctx[18].sellPriceModifier;
  }
  sliderinput1 = new SliderInput({ props: sliderinput1_props });
  binding_callbacks.push(() => bind$1(sliderinput1, "value", sliderinput1_value_binding));
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      input = element("input");
      t0 = space();
      td1 = element("td");
      div1 = element("div");
      if_block.c();
      t1 = space();
      td2 = element("td");
      div2 = element("div");
      create_component(sliderinput0.$$.fragment);
      t2 = space();
      td3 = element("td");
      div3 = element("div");
      create_component(sliderinput1.$$.fragment);
      t3 = space();
      td4 = element("td");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      t4 = space();
      attr(input, "type", "checkbox");
      attr(div0, "class", "form-group");
      attr(div1, "class", "form-group");
      attr(div2, "class", "item-piles-flexrow");
      set_style(div2, "margin", "0 0.25rem");
      attr(div3, "class", "item-piles-flexrow");
      set_style(div3, "margin", "0 0.25rem");
      attr(button, "type", "button");
      attr(button, "class", "svelte-a1mqx5");
      attr(td4, "class", "small");
      attr(tr, "class", "svelte-a1mqx5");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, input);
      input.checked = ctx[18].override;
      append(tr, t0);
      append(tr, td1);
      append(td1, div1);
      if_block.m(div1, null);
      append(tr, t1);
      append(tr, td2);
      append(td2, div2);
      mount_component(sliderinput0, div2, null);
      append(tr, t2);
      append(tr, td3);
      append(td3, div3);
      mount_component(sliderinput1, div3, null);
      append(tr, t3);
      append(tr, td4);
      append(td4, button);
      append(tr, t4);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(button, "click", function() {
            if (is_function(ctx[8](ctx[20])))
              ctx[8](ctx[20]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 65) {
        input.checked = ctx[18].override;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
      const sliderinput0_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        sliderinput0_changes.value = ctx[18].buyPriceModifier;
        add_flush_callback(() => updating_value = false);
      }
      sliderinput0.$set(sliderinput0_changes);
      const sliderinput1_changes = {};
      if (!updating_value_1 && dirty & 1) {
        updating_value_1 = true;
        sliderinput1_changes.value = ctx[18].sellPriceModifier;
        add_flush_callback(() => updating_value_1 = false);
      }
      sliderinput1.$set(sliderinput1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sliderinput0.$$.fragment, local);
      transition_in(sliderinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sliderinput0.$$.fragment, local);
      transition_out(sliderinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
      destroy_component(sliderinput0);
      destroy_component(sliderinput1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$d, "create_each_block$d");
function create_default_slot$b(ctx) {
  let form_1;
  let p;
  let t1;
  let div;
  let table;
  let tr;
  let th0;
  let t3;
  let th1;
  let t5;
  let th2;
  let t7;
  let th3;
  let t9;
  let th4;
  let span;
  let t10;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t11;
  let footer;
  let button0;
  let i1;
  let t12;
  let t13_value = localize("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.Submit") + "";
  let t13;
  let t14;
  let button1;
  let i2;
  let t15;
  let t16_value = localize("Cancel") + "";
  let t16;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[20], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$d(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
  }
  return {
    c() {
      form_1 = element("form");
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.Explanation")}`;
      t1 = space();
      div = element("div");
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th0.textContent = `${localize("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.Override")}`;
      t3 = space();
      th1 = element("th");
      th1.textContent = `${localize("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.ItemType")}`;
      t5 = space();
      th2 = element("th");
      th2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.BuyPriceModifier")}`;
      t7 = space();
      th3 = element("th");
      th3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.SellPriceModifier")}`;
      t9 = space();
      th4 = element("th");
      span = element("span");
      span.innerHTML = `<i class="fas fa-plus"></i>`;
      t10 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t11 = space();
      footer = element("footer");
      button0 = element("button");
      i1 = element("i");
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      button1 = element("button");
      i2 = element("i");
      t15 = space();
      t16 = text(t16_value);
      set_style(th0, "width", "5%");
      set_style(th1, "width", "20%");
      set_style(th2, "width", "35%");
      set_style(th3, "width", "35%");
      toggle_class(span, "item-piles-clickable-link", ctx[4].length);
      set_style(th4, "width", "5%");
      attr(tr, "class", "svelte-a1mqx5");
      attr(table, "class", "svelte-a1mqx5");
      attr(i1, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i2, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p);
      append(form_1, t1);
      append(form_1, div);
      append(div, table);
      append(table, tr);
      append(tr, th0);
      append(tr, t3);
      append(tr, th1);
      append(tr, t5);
      append(tr, th2);
      append(tr, t7);
      append(tr, th3);
      append(tr, t9);
      append(tr, th4);
      append(th4, span);
      append(table, t10);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      append(form_1, t11);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i1);
      append(button0, t12);
      append(button0, t13);
      append(footer, t14);
      append(footer, button1);
      append(button1, i2);
      append(button1, t15);
      append(button1, t16);
      ctx[16](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "click", ctx[7]),
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[15], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[9]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16) {
        toggle_class(span, "item-piles-clickable-link", ctx2[4].length);
      }
      if (dirty & 337) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, outro_and_destroy_block, create_each_block$d, null, get_each_context$d);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$b, "create_default_slot$b");
function create_fragment$r(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[17](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$b] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 33554457) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$r, "create_fragment$r");
function instance$r($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { itemTypePriceModifiers = [] } = $$props;
  let form;
  let unusedTypes;
  let systemTypes = Object.entries(CONFIG.Item.typeLabels);
  systemTypes.push(["custom", "Custom"]);
  function add() {
    if (!unusedTypes.length)
      return;
    itemTypePriceModifiers.push({
      type: unusedTypes[0],
      category: "",
      override: false,
      buyPriceModifier: 1,
      sellPriceModifier: 0.5
    });
    $$invalidate(0, itemTypePriceModifiers);
  }
  __name(add, "add");
  function remove(index) {
    itemTypePriceModifiers.splice(index, 1);
    $$invalidate(0, itemTypePriceModifiers);
  }
  __name(remove, "remove");
  async function updateSettings() {
    application.options.resolve?.(itemTypePriceModifiers);
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function input_change_handler(each_value, index) {
    each_value[index].override = this.checked;
    $$invalidate(0, itemTypePriceModifiers);
    $$invalidate(6, systemTypes);
  }
  __name(input_change_handler, "input_change_handler");
  function input_input_handler(each_value, index) {
    each_value[index].category = this.value;
    $$invalidate(0, itemTypePriceModifiers);
    $$invalidate(6, systemTypes);
  }
  __name(input_input_handler, "input_input_handler");
  function select_change_handler(each_value, index) {
    each_value[index].type = select_value(this);
    $$invalidate(0, itemTypePriceModifiers);
    $$invalidate(6, systemTypes);
  }
  __name(select_change_handler, "select_change_handler");
  function sliderinput0_value_binding(value, priceData) {
    if ($$self.$$.not_equal(priceData.buyPriceModifier, value)) {
      priceData.buyPriceModifier = value;
      $$invalidate(0, itemTypePriceModifiers);
    }
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  function sliderinput1_value_binding(value, priceData) {
    if ($$self.$$.not_equal(priceData.sellPriceModifier, value)) {
      priceData.sellPriceModifier = value;
      $$invalidate(0, itemTypePriceModifiers);
    }
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("itemTypePriceModifiers" in $$props2)
      $$invalidate(0, itemTypePriceModifiers = $$props2.itemTypePriceModifiers);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(4, unusedTypes = systemTypes.filter(([type]) => type === "custom" || !itemTypePriceModifiers.some((priceData) => priceData.type === type)).map(([type]) => type));
      }
    }
  };
  return [
    itemTypePriceModifiers,
    elementRoot,
    requestSubmit,
    form,
    unusedTypes,
    application,
    systemTypes,
    add,
    remove,
    updateSettings,
    input_change_handler,
    input_input_handler,
    select_change_handler,
    sliderinput0_value_binding,
    sliderinput1_value_binding,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$r, "instance$r");
class Item_type_price_modifiers_editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$r, safe_not_equal, {
      elementRoot: 1,
      itemTypePriceModifiers: 0,
      requestSubmit: 2
    });
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get itemTypePriceModifiers() {
    return this.$$.ctx[0];
  }
  set itemTypePriceModifiers(itemTypePriceModifiers) {
    this.$$set({ itemTypePriceModifiers });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Item_type_price_modifiers_editor, "Item_type_price_modifiers_editor");
class ItemTypePriceModifiersEditor extends SvelteApplication {
  constructor(itemTypePriceModifiers, options) {
    super({
      svelte: {
        class: Item_type_price_modifiers_editor,
        target: document.body,
        props: {
          itemTypePriceModifiers
        }
      },
      close: () => this.options.resolve?.(false),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.Title"),
      width: 600,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static async show(itemTypePriceModifiers, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(itemTypePriceModifiers, options).render(true, { focus: true });
    });
  }
}
__name(ItemTypePriceModifiersEditor, "ItemTypePriceModifiersEditor");
class StyleManager {
  #docKey;
  #selector;
  #styleElement;
  #cssRule;
  constructor({ selector = ":root", docKey, document: document2 = globalThis.document } = {}) {
    if (typeof selector !== "string") {
      throw new TypeError(`StyleManager error: 'selector' is not a string.`);
    }
    if (typeof docKey !== "string") {
      throw new TypeError(`StyleManager error: 'docKey' is not a string.`);
    }
    this.#selector = selector;
    this.#docKey = docKey;
    if (document2[this.#docKey] === void 0) {
      this.#styleElement = document2.createElement("style");
      document2.head.append(this.#styleElement);
      this.#styleElement.sheet.insertRule(`${selector} {}`, 0);
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      document2[docKey] = this.#styleElement;
    } else {
      this.#styleElement = document2[docKey];
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
    }
  }
  clone(document2 = globalThis.document) {
    const newStyleManager = new StyleManager({ selector: this.#selector, docKey: this.#docKey, document: document2 });
    newStyleManager.#cssRule.style.cssText = this.#cssRule.style.cssText;
    return newStyleManager;
  }
  set(rules, overwrite = false) {
    if (overwrite) {
      for (const [key, value] of Object.entries(rules)) {
        this.#cssRule.style.setProperty(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(rules)) {
        if (this.#cssRule.style.getPropertyValue(key) === "") {
          this.#cssRule.style.setProperty(key, value);
        }
      }
    }
  }
  remove(keys2) {
    if (Array.isArray(keys2)) {
      for (const key of keys2) {
        if (typeof key === "string") {
          this.#cssRule.style.removeProperty(key);
        }
      }
    } else if (typeof keys2 === "string") {
      this.#cssRule.style.removeProperty(keys2);
    }
  }
}
__name(StyleManager, "StyleManager");
const s_STYLE_KEY = "#__tjs-root-styles";
const cssVariables = new StyleManager({ docKey: s_STYLE_KEY });
class FoundryStyles {
  static #sheet = void 0;
  static #sheetMap = /* @__PURE__ */ new Map();
  static #initialized = false;
  static #initialize() {
    this.#initialized = true;
    const styleSheets = Array.from(document.styleSheets).filter((sheet2) => sheet2.href !== null);
    let sheet;
    const foundryStyleSheet = foundry.utils.getRoute("/css/style.css");
    for (const styleSheet of styleSheets) {
      let url;
      try {
        url = new URL(styleSheet.href);
      } catch (err) {
        continue;
      }
      if (typeof url.pathname === "string" && url.pathname === foundryStyleSheet) {
        this.#sheet = sheet = styleSheet;
        break;
      }
    }
    if (!sheet) {
      return;
    }
    for (const rule of sheet.cssRules) {
      if (!(rule instanceof CSSStyleRule)) {
        continue;
      }
      const obj = {};
      for (const entry of rule.style.cssText.split(";")) {
        const parts = entry.split(":");
        if (parts.length < 2) {
          continue;
        }
        obj[parts[0].trim()] = parts[1].trim();
      }
      this.#sheetMap.set(rule.selectorText, obj);
    }
  }
  static getProperties(selector) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      return this.#sheetMap.get(selector);
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        return this.#sheetMap.get(key);
      }
    }
    return void 0;
  }
  static getProperty(selector, property) {
    if (!this.#initialized) {
      this.#initialize();
    }
    if (this.#sheetMap.has(selector)) {
      const data = this.#sheetMap.get(selector);
      return typeof data === "object" && property in data ? data[property] : void 0;
    }
    for (const key of this.#sheetMap.keys()) {
      if (key.includes(selector)) {
        const data = this.#sheetMap.get(key);
        if (typeof data === "object" && property in data) {
          return data[property];
        }
      }
    }
    return void 0;
  }
}
__name(FoundryStyles, "FoundryStyles");
const TJSIconButton_svelte_svelte_type_style_lang = "";
const TJSToggleIconButton_svelte_svelte_type_style_lang = "";
Hooks.once("init", () => {
  !foundry.utils.isNewerVersion(10, game.version ?? game?.data?.version);
});
const TJSContentEdit_svelte_svelte_type_style_lang = "";
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
__name(findDiffStart, "findDiffStart");
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
__name(findDiffEnd, "findDiffEnd");
class Fragment {
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  nodesBetween(from, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  textBetween(from, to, blockSeparator, leafText) {
    let text2 = "", separated = true;
    this.nodesBetween(from, to, (node, pos) => {
      if (node.isText) {
        text2 += node.text.slice(Math.max(from, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node.isLeaf) {
        if (leafText) {
          text2 += typeof leafText === "function" ? leafText(node) : leafText;
        } else if (node.type.spec.leafText) {
          text2 += node.type.spec.leafText(node);
        }
        separated = !blockSeparator;
      } else if (!separated && node.isBlock) {
        text2 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text2;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content[content.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  cut(from, to = this.size) {
    if (from == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size);
  }
  cutByIndex(from, to) {
    if (from == to)
      return Fragment.empty;
    if (from == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from, to));
  }
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy[index] = node;
    return new Fragment(copy, size);
  }
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  maybeChild(index) {
    return this.content[index] || null;
  }
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  findIndex(pos, round = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round > 0)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size);
  }
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
__name(Fragment, "Fragment");
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}
__name(retIndex, "retIndex");
class ReplaceError extends Error {
}
__name(ReplaceError, "ReplaceError");
class Slice {
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  removeBetween(from, to) {
    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
__name(Slice, "Slice");
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
  let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
__name(removeRange, "removeRange");
function insertInto(content, dist, insert2, parent) {
  let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert2))
      return null;
    return content.cut(0, dist).append(insert2).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset - 1, insert2);
  return inner && content.replaceChild(index, child.copy(inner));
}
__name(insertInto, "insertInto");
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index, offset) {
  return index + offset * factor16;
}
__name(makeRecover, "makeRecover");
function recoverIndex(value) {
  return value & lower16;
}
__name(recoverIndex, "recoverIndex");
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
__name(recoverOffset, "recoverOffset");
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
__name(MapResult, "MapResult");
class StepMap {
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
__name(StepMap, "StepMap");
StepMap.empty = new StepMap([]);
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  getMap() {
    return StepMap.empty;
  }
  merge(other) {
    return null;
  }
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
__name(Step, "Step");
class StepResult {
  constructor(doc, failed) {
    this.doc = doc;
    this.failed = failed;
  }
  static ok(doc) {
    return new StepResult(doc, null);
  }
  static fail(message) {
    return new StepResult(null, message);
  }
  static fromReplace(doc, from, to, slice) {
    try {
      return StepResult.ok(doc.replace(from, to, slice));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
__name(StepResult, "StepResult");
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
__name(mapFragment, "mapFragment");
class AddMarkStep extends Step {
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc) {
    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new AddMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
__name(AddMarkStep, "AddMarkStep");
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc) {
    let oldSlice = doc.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
__name(RemoveMarkStep, "RemoveMarkStep");
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc) {
    let node = doc.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc) {
    let node = doc.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
__name(AddNodeMarkStep, "AddNodeMarkStep");
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc) {
    let node = doc.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc) {
    let node = doc.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
__name(RemoveNodeMarkStep, "RemoveNodeMarkStep");
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  constructor(from, to, slice, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = structure;
  }
  apply(doc) {
    if (this.structure && contentBetween(doc, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
__name(ReplaceStep, "ReplaceStep");
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  constructor(from, to, gapFrom, gapTo, slice, insert2, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert2;
    this.structure = structure;
  }
  apply(doc) {
    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
__name(ReplaceAroundStep, "ReplaceAroundStep");
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc, from, to) {
  let $from = doc.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next2 = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next2 || next2.isLeaf)
        return true;
      next2 = next2.firstChild;
      dist--;
    }
  }
  return false;
}
__name(contentBetween, "contentBetween");
class AttrStep extends Step {
  constructor(pos, attr2, value) {
    super();
    this.pos = pos;
    this.attr = attr2;
    this.value = value;
  }
  apply(doc) {
    let node = doc.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc) {
    return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
__name(AttrStep, "AttrStep");
Step.jsonID("attr", AttrStep);
let TransformError = /* @__PURE__ */ __name(class extends Error {
}, "TransformError");
TransformError = /* @__PURE__ */ __name(function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
}, "TransformError");
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  static atStart(doc) {
    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
  }
  static atEnd(doc) {
    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
  }
  static fromJSON(doc, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc, json);
  }
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
__name(Selection, "Selection");
Selection.prototype.visible = true;
class SelectionRange {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
__name(SelectionRange, "SelectionRange");
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
__name(checkTextSelection, "checkTextSelection");
class TextSelection extends Selection {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc, mapping) {
    let $head = doc.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
  }
  static create(doc, anchor, head = anchor) {
    let $anchor = doc.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
__name(TextSelection, "TextSelection");
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc) {
    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
  }
}
__name(TextBookmark, "TextBookmark");
class NodeSelection extends Selection {
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  static fromJSON(doc, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc.resolve(json.anchor));
  }
  static create(doc, from) {
    return new NodeSelection(doc.resolve(from));
  }
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
__name(NodeSelection, "NodeSelection");
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc) {
    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
__name(NodeBookmark, "NodeBookmark");
class AllSelection extends Selection {
  constructor(doc) {
    super(doc.resolve(0), doc.resolve(doc.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc) {
    return new AllSelection(doc);
  }
  map(doc) {
    return new AllSelection(doc);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
__name(AllSelection, "AllSelection");
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc) {
    return new AllSelection(doc);
  }
};
function findSelectionIn(doc, node, pos, index, dir, text2 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
      if (inner)
        return inner;
    } else if (!text2 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
__name(findSelectionIn, "findSelectionIn");
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
__name(selectionToInsertionEnd, "selectionToInsertionEnd");
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
__name(bind, "bind");
class FieldDesc {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
}
__name(FieldDesc, "FieldDesc");
[
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance2) {
      return config.selection || Selection.atStart(instance2.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
__name(bindProps, "bindProps");
class Plugin {
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  getState(state) {
    return state[this.key];
  }
}
__name(Plugin, "Plugin");
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
__name(createKey, "createKey");
class PluginKey {
  constructor(name = "key") {
    this.key = createKey(name);
  }
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  getState(state) {
    return state[this.key];
  }
}
__name(PluginKey, "PluginKey");
class TJSEditorOptions {
  #extra;
  #options;
  constructor(options, extra) {
    this.#options = options;
    this.#extra = extra;
  }
  static build(options, extra) {
    const instance2 = new this(options, extra);
    return new Plugin({
      key: new PluginKey("tjsEditorOptions"),
      view: (view) => instance2.#initialize(view)
    });
  }
  #handleInitialSelection(view, tr, doc) {
    const initialSelection = this.#options.initialSelection;
    const type = initialSelection === "all" || initialSelection === "end" || initialSelection === "start" ? initialSelection : this.#extra.initialSelectionDefault;
    const minPos = TextSelection.atStart(doc).from;
    const maxPos = TextSelection.atEnd(doc).to;
    let transaction;
    switch (type) {
      case "all": {
        const resolvedFrom = this.#minMax(0, minPos, maxPos);
        const resolvedEnd = this.#minMax(doc.content.size, minPos, maxPos);
        transaction = tr.setSelection(TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
      case "end": {
        const resolvedFrom = this.#minMax(doc.content.size, minPos, maxPos);
        const resolvedEnd = this.#minMax(doc.content.size, minPos, maxPos);
        transaction = tr.setSelection(TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
      case "start": {
        const resolvedFrom = this.#minMax(0, minPos, maxPos);
        const resolvedEnd = this.#minMax(0, minPos, maxPos);
        transaction = tr.setSelection(TextSelection.create(doc, resolvedFrom, resolvedEnd));
        break;
      }
    }
    if (transaction) {
      let newState = view.state.apply(transaction);
      view.updateState(newState);
    }
  }
  #initialize(view) {
    const tr = view.state.tr;
    const doc = tr.doc;
    this.#handleInitialSelection(view, tr, doc);
    return {};
  }
  #minMax(value = 0, min = 0, max = 0) {
    return Math.min(Math.max(value, min), max);
  }
}
__name(TJSEditorOptions, "TJSEditorOptions");
const ProseMirrorKeyMaps = globalThis.ProseMirror ? ProseMirror.ProseMirrorKeyMaps : class {
};
class TJSKeyMaps extends ProseMirrorKeyMaps {
  #onQuit;
  constructor(schema, options) {
    super(schema, options);
    if (typeof options.onQuit === "function") {
      this.#onQuit = options.onQuit;
    }
  }
  buildMapping() {
    const mapping = super.buildMapping();
    if (this.#onQuit) {
      if (mapping["Escape"]) {
        mapping["Mod-p"] = mapping["Escape"];
      }
      mapping["Escape"] = () => this.#onQuit();
    }
    return mapping;
  }
}
__name(TJSKeyMaps, "TJSKeyMaps");
class TJSPasteUUID {
  static #s_UUID_REGEX = /(\.).*([a-zA-Z0-9]{16})/;
  static build() {
    const instance2 = new this();
    return new Plugin({
      key: new PluginKey("tjsPasteRawUUID"),
      props: {
        transformPastedText: (text2) => instance2.#transformUUID(text2)
      }
    });
  }
  #transformUUID(text2) {
    if (typeof text2 === "string") {
      if (TJSPasteUUID.#s_UUID_REGEX.test(text2)) {
        const uuidDoc = globalThis.fromUuidSync(text2);
        if (uuidDoc) {
          text2 = `@UUID[${text2}]{${typeof uuidDoc.name === "string" ? uuidDoc.name : "Unknown"}}`;
        }
      }
    }
    return text2;
  }
}
__name(TJSPasteUUID, "TJSPasteUUID");
const TJSProseMirror_svelte_svelte_type_style_lang = "";
function create_if_block_1$f(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fas fa-edit"></i>`;
      attr(a, "class", "editor-edit svelte-1y8sl7k");
      attr(a, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$f, "create_if_block_1$f");
function create_else_block$7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "editor-enriched svelte-1y8sl7k");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = ctx[0];
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        div.innerHTML = ctx2[0];
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_else_block$7, "create_else_block$7");
function create_if_block$l(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "editor-content svelte-1y8sl7k");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[15](div);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[15](null);
    }
  };
}
__name(create_if_block$l, "create_if_block$l");
function create_fragment$q(ctx) {
  let div;
  let t;
  let div_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_1$f(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block$l;
    return create_else_block$7;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      attr(div, "class", div_class_value = "editor prosemirror tjs-editor " + (Array.isArray(ctx[1].classes) ? ctx[1].classes.join(" ") : "") + " svelte-1y8sl7k");
      attr(div, "role", "presentation");
      toggle_class(div, "click-to-edit", ctx[2]);
      toggle_class(div, "editor-active", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if_block1.m(div, null);
      ctx[16](div);
      if (!mounted) {
        dispose = [
          action_destroyer(applyStyles_action = applyStyles.call(null, div, ctx[1].styles)),
          listen(div, "click", ctx[9]),
          listen(div, "keydown", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$f(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
      if (dirty & 2 && div_class_value !== (div_class_value = "editor prosemirror tjs-editor " + (Array.isArray(ctx2[1].classes) ? ctx2[1].classes.join(" ") : "") + " svelte-1y8sl7k")) {
        attr(div, "class", div_class_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & 2)
        applyStyles_action.update.call(null, ctx2[1].styles);
      if (dirty & 6) {
        toggle_class(div, "click-to-edit", ctx2[2]);
      }
      if (dirty & 10) {
        toggle_class(div, "editor-active", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$q, "create_fragment$q");
function instance$q($$self, $$props, $$invalidate) {
  let $doc;
  let { content = "" } = $$props;
  let { enrichedContent = "" } = $$props;
  let { options = {} } = $$props;
  const dispatch2 = createEventDispatcher();
  const doc = new TJSDocument();
  component_subscribe($$self, doc, (value) => $$invalidate(13, $doc = value));
  let clickToEdit;
  let editable = true;
  let editorContentEl;
  let editor;
  let editorActive = false;
  let editorButton;
  let editorEl;
  async function onContentChanged(content2, enrichContent) {
    if (typeof content2 === "string") {
      if (enrichContent) {
        $$invalidate(0, enrichedContent = await TextEditor.enrichHTML(content2, { async: true, secrets: true }));
      } else {
        $$invalidate(0, enrichedContent = content2);
      }
    } else {
      $$invalidate(0, enrichedContent = "");
    }
    dispatch2("editor:enrichedContent", { enrichedContent });
  }
  __name(onContentChanged, "onContentChanged");
  onDestroy(() => {
    if (editorActive) {
      saveEditor({
        remove: typeof options.button === "boolean" ? options.button : true
      });
    } else {
      destroyEditor();
    }
  });
  onMount(() => {
    if (editable && !editorButton && !clickToEdit) {
      initEditor();
    }
  });
  function destroyEditor(fireCancel = true) {
    if (editor) {
      editor.destroy();
      editor = void 0;
      setTimeout(
        () => {
          $$invalidate(3, editorActive = false);
        },
        0
      );
      if (fireCancel) {
        dispatch2("editor:cancel");
      }
    }
  }
  __name(destroyEditor, "destroyEditor");
  async function initEditor() {
    const remove = typeof options.button === "boolean" ? options.button : true;
    const editorOptions = {
      ...options,
      plugins: {
        ...ProseMirror.defaultPlugins,
        menu: ProseMirror.ProseMirrorMenu.build(ProseMirror.defaultSchema, {
          destroyOnSave: remove,
          onSave: () => saveEditor({ remove })
        }),
        keyMaps: TJSKeyMaps.build(ProseMirror.defaultSchema, {
          onSave: () => saveEditor({ remove }),
          onQuit: () => destroyEditor()
        }),
        tjsPasteRawUUID: TJSPasteUUID.build(),
        ...typeof options.plugins === "object" ? options.plugins : {},
        tjsEditorOptions: TJSEditorOptions.build(options, { initialSelectionDefault: "start" })
      }
    };
    $$invalidate(3, editorActive = true);
    await tick();
    editor = await ProseMirrorEditor.create(editorContentEl, content, editorOptions);
    const containerEl = editorEl.querySelector(".editor-container");
    if (containerEl) {
      containerEl.style = "margin: var(--tjs-editor-container-margin, 0)";
    }
    editor.view.focus();
    dispatch2("editor:start");
  }
  __name(initEditor, "initEditor");
  function onClick(event) {
    if (!editorActive && clickToEdit) {
      initEditor();
    }
  }
  __name(onClick, "onClick");
  function onKeydown(event) {
    if (editorActive && (event.key === "Escape" || event.key === "s" && (event.ctrlKey || event.metaKey))) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onKeydown, "onKeydown");
  function saveEditor({ remove = true } = {}) {
    if (editor) {
      if (editor.isDirty()) {
        let data = ProseMirror.dom.serializeString(editor.view.state.doc);
        if (options?.DOMPurify && typeof options?.DOMPurify?.sanitizeWithVideo === "function") {
          data = options.DOMPurify.sanitizeWithVideo(data);
        }
        if ($doc && options.fieldName) {
          $doc.update({ [options.fieldName]: data });
        } else {
          $$invalidate(11, content = data);
        }
        dispatch2("editor:save", { content: data });
      }
      if (remove) {
        destroyEditor(false);
      }
    }
  }
  __name(saveEditor, "saveEditor");
  const click_handler = /* @__PURE__ */ __name(() => initEditor(), "click_handler");
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorContentEl = $$value;
      $$invalidate(4, editorContentEl);
    });
  }
  __name(div_binding, "div_binding");
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorEl = $$value;
      $$invalidate(6, editorEl);
    });
  }
  __name(div_binding_1, "div_binding_1");
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(11, content = $$props2.content);
    if ("enrichedContent" in $$props2)
      $$invalidate(0, enrichedContent = $$props2.enrichedContent);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4098) {
      {
        $$invalidate(12, editable = typeof options.editable === "boolean" ? options.editable : true);
        if (!editable) {
          destroyEditor();
        }
      }
    }
    if ($$self.$$.dirty & 4106) {
      $$invalidate(2, clickToEdit = !editorActive && editable && (typeof options.clickToEdit === "boolean" ? options.clickToEdit : false));
    }
    if ($$self.$$.dirty & 4110) {
      $$invalidate(5, editorButton = !editorActive && editable && (typeof options.button === "boolean" ? options.button : true) && !clickToEdit);
    }
    if ($$self.$$.dirty & 8194) {
      if (options.document !== void 0) {
        if (!(options.document instanceof foundry.abstract.Document)) {
          throw new TypeError(`TJSProseMirror error: 'options.document' is not a Foundry document.`);
        }
        if (typeof options.fieldName !== "string") {
          throw new TypeError(`TJSProseMirror error: 'options.document' is defined, but 'options.fieldName' is not a string.`);
        }
        if (options.document !== $doc) {
          $$invalidate(0, enrichedContent = "");
          $$invalidate(11, content = "");
          destroyEditor();
        }
        doc.set(options.document);
      } else {
        if ($doc) {
          $$invalidate(0, enrichedContent = "");
          $$invalidate(11, content = "");
          destroyEditor();
        }
        doc.set(void 0);
      }
    }
    if ($$self.$$.dirty & 10242) {
      {
        $$invalidate(11, content = $doc !== void 0 ? foundry.utils.getProperty($doc, options.fieldName) : typeof content === "string" ? content : "");
        onContentChanged(content, typeof options.enrichContent === "boolean" ? options.enrichContent : true);
      }
    }
  };
  return [
    enrichedContent,
    options,
    clickToEdit,
    editorActive,
    editorContentEl,
    editorButton,
    editorEl,
    doc,
    initEditor,
    onClick,
    onKeydown,
    content,
    editable,
    $doc,
    click_handler,
    div_binding,
    div_binding_1
  ];
}
__name(instance$q, "instance$q");
class TJSProseMirror extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$q, safe_not_equal, {
      content: 11,
      enrichedContent: 0,
      options: 1
    });
  }
}
__name(TJSProseMirror, "TJSProseMirror");
const TJSTinyMCE_svelte_svelte_type_style_lang = "";
const TJSSvgFolder_svelte_svelte_type_style_lang = "";
const TJSIconFolder_svelte_svelte_type_style_lang = "";
const TJSInputText_svelte_svelte_type_style_lang = "";
const TJSSelect_svelte_svelte_type_style_lang = "";
const TJSToggleLabel_svelte_svelte_type_style_lang = "";
const get_right_slot_changes$1 = /* @__PURE__ */ __name((dirty) => ({}), "get_right_slot_changes$1");
const get_right_slot_context$1 = /* @__PURE__ */ __name((ctx) => ({}), "get_right_slot_context$1");
const get_left_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_left_slot_changes");
const get_left_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_left_slot_context");
const get_outer_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_outer_slot_changes");
const get_outer_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_outer_slot_context");
function create_if_block_2$e(ctx) {
  let a;
  let t_value = localize(ctx[0]) + "";
  let t;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = localize(ctx2[0]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
__name(create_if_block_2$e, "create_if_block_2$e");
function create_if_block_1$e(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    return {};
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
__name(create_if_block_1$e, "create_if_block_1$e");
function create_if_block$k(ctx) {
  let current;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
__name(create_if_block$k, "create_if_block$k");
function create_fragment$p(ctx) {
  let div;
  let t0;
  let span;
  let t1;
  let current_block_type_index;
  let if_block0;
  let t2;
  let t3;
  let div_title_value;
  let applyStyles_action;
  let current;
  let mounted;
  let dispose;
  const outer_slot_template = ctx[17].outer;
  const outer_slot = create_slot(outer_slot_template, ctx, ctx[16], get_outer_slot_context);
  const left_slot_template = ctx[17].left;
  const left_slot = create_slot(left_slot_template, ctx, ctx[16], get_left_slot_context);
  const if_block_creators = [create_if_block_1$e, create_if_block_2$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (typeof ctx2[0] === "string")
      return 1;
    return -1;
  }
  __name(select_block_type, "select_block_type");
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const right_slot_template = ctx[17].right;
  const right_slot = create_slot(right_slot_template, ctx, ctx[16], get_right_slot_context$1);
  let if_block1 = ctx[5] && create_if_block$k(ctx);
  return {
    c() {
      div = element("div");
      if (outer_slot)
        outer_slot.c();
      t0 = space();
      span = element("span");
      if (left_slot)
        left_slot.c();
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (right_slot)
        right_slot.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "role", "presentation");
      attr(span, "class", "svelte-r464f2");
      toggle_class(span, "selected", ctx[5]);
      attr(div, "title", div_title_value = localize(ctx[6]));
      attr(div, "role", "presentation");
      attr(div, "class", "svelte-r464f2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (outer_slot) {
        outer_slot.m(div, null);
      }
      append(div, t0);
      append(div, span);
      if (left_slot) {
        left_slot.m(span, null);
      }
      append(span, t1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append(span, t2);
      if (right_slot) {
        right_slot.m(span, null);
      }
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "click", ctx[7]),
          action_destroyer(ctx[4].call(null, span)),
          listen(div, "click", ctx[8]),
          listen(div, "close", ctx[9]),
          action_destroyer(applyStyles_action = applyStyles.call(null, div, ctx[3]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (outer_slot) {
        if (outer_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            outer_slot,
            outer_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(outer_slot_template, ctx2[16], dirty, get_outer_slot_changes),
            get_outer_slot_context
          );
        }
      }
      if (left_slot) {
        if (left_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            left_slot,
            left_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(left_slot_template, ctx2[16], dirty, get_left_slot_changes),
            get_left_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(span, t2);
        } else {
          if_block0 = null;
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(right_slot_template, ctx2[16], dirty, get_right_slot_changes$1),
            get_right_slot_context$1
          );
        }
      }
      if (!current || dirty & 32) {
        toggle_class(span, "selected", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 64 && div_title_value !== (div_title_value = localize(ctx2[6]))) {
        attr(div, "title", div_title_value);
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & 8)
        applyStyles_action.update.call(null, ctx2[3]);
    },
    i(local) {
      if (current)
        return;
      transition_in(outer_slot, local);
      transition_in(left_slot, local);
      transition_in(if_block0);
      transition_in(right_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(outer_slot, local);
      transition_out(left_slot, local);
      transition_out(if_block0);
      transition_out(right_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (outer_slot)
        outer_slot.d(detaching);
      if (left_slot)
        left_slot.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (right_slot)
        right_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$p, "create_fragment$p");
function instance$p($$self, $$props, $$invalidate) {
  let titleCurrent;
  let $store, $$unsubscribe_store = noop, $$subscribe_store = /* @__PURE__ */ __name(() => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(15, $store = $$value)), store), "$$subscribe_store");
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { comp = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { titleSelected = void 0 } = $$props;
  let { store = void 0 } = $$props;
  $$subscribe_store();
  let { styles: styles2 = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  let { onClickPropagate = void 0 } = $$props;
  let { onClosePropagate = void 0 } = $$props;
  let selected = false;
  function onClick(event) {
    $$invalidate(5, selected = !selected);
    if (store) {
      store.set(selected);
    }
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onClick, "onClick");
  function onClickDiv(event) {
    if (!onClickPropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onClickDiv, "onClickDiv");
  function onClose(event) {
    $$invalidate(5, selected = false);
    if (store) {
      store.set(false);
    }
    if (!onClosePropagate) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  __name(onClose, "onClose");
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(14, label = $$props2.label);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("comp" in $$props2)
      $$invalidate(1, comp = $$props2.comp);
    if ("title" in $$props2)
      $$invalidate(10, title = $$props2.title);
    if ("titleSelected" in $$props2)
      $$invalidate(11, titleSelected = $$props2.titleSelected);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
    if ("styles" in $$props2)
      $$invalidate(3, styles2 = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(4, efx = $$props2.efx);
    if ("onClickPropagate" in $$props2)
      $$invalidate(12, onClickPropagate = $$props2.onClickPropagate);
    if ("onClosePropagate" in $$props2)
      $$invalidate(13, onClosePropagate = $$props2.onClosePropagate);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16385) {
      $$invalidate(0, text2 = isObject(label) && typeof label.text === "string" ? label.text : typeof text2 === "string" ? text2 : void 0);
    }
    if ($$self.$$.dirty & 16386) {
      $$invalidate(1, comp = isObject(label) && isSvelteComponent(label.comp) ? label.comp : isSvelteComponent(comp) ? comp : void 0);
    }
    if ($$self.$$.dirty & 17408) {
      $$invalidate(10, title = isObject(label) && typeof label.title === "string" ? label.title : typeof title === "string" ? title : "");
    }
    if ($$self.$$.dirty & 18432) {
      $$invalidate(11, titleSelected = isObject(label) && typeof label.titleSelected === "string" ? label.titleSelected : typeof titleSelected === "string" ? titleSelected : "");
    }
    if ($$self.$$.dirty & 16388) {
      $$subscribe_store($$invalidate(2, store = isObject(label) && isWritableStore(label.store) ? label.store : isWritableStore(store) ? store : void 0));
    }
    if ($$self.$$.dirty & 16392) {
      $$invalidate(3, styles2 = isObject(label) && typeof label.styles === "object" ? label.styles : typeof styles2 === "object" ? styles2 : void 0);
    }
    if ($$self.$$.dirty & 16400) {
      $$invalidate(4, efx = isObject(label) && typeof label.efx === "function" ? label.efx : typeof efx === "function" ? efx : () => {
      });
    }
    if ($$self.$$.dirty & 24576) {
      $$invalidate(13, onClosePropagate = isObject(label) && typeof label.onClosePropagate === "boolean" ? label.onClosePropagate : typeof onClosePropagate === "boolean" ? onClosePropagate : false);
    }
    if ($$self.$$.dirty & 20480) {
      $$invalidate(12, onClickPropagate = isObject(label) && typeof label.onClickPropagate === "boolean" ? label.onClickPropagate : typeof onClickPropagate === "boolean" ? onClickPropagate : false);
    }
    if ($$self.$$.dirty & 32772) {
      if (store) {
        $$invalidate(5, selected = $store);
      }
    }
    if ($$self.$$.dirty & 3104) {
      $$invalidate(6, titleCurrent = selected && titleSelected !== "" ? titleSelected : title);
    }
  };
  return [
    text2,
    comp,
    store,
    styles2,
    efx,
    selected,
    titleCurrent,
    onClick,
    onClickDiv,
    onClose,
    title,
    titleSelected,
    onClickPropagate,
    onClosePropagate,
    label,
    $store,
    $$scope,
    slots
  ];
}
__name(instance$p, "instance$p");
class TJSToggleLabel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$p, safe_not_equal, {
      label: 14,
      text: 0,
      comp: 1,
      title: 10,
      titleSelected: 11,
      store: 2,
      styles: 3,
      efx: 4,
      onClickPropagate: 12,
      onClosePropagate: 13
    });
  }
}
__name(TJSToggleLabel, "TJSToggleLabel");
const ResizeHitBox_svelte_svelte_type_style_lang = "";
const SelectedBorder_svelte_svelte_type_style_lang = "";
const PositionControl_svelte_svelte_type_style_lang = "";
const TJSPositionControlLayer_svelte_svelte_type_style_lang = "";
const TJSMenu_svelte_svelte_type_style_lang = "";
const get_after_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_after_slot_changes");
const get_after_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_after_slot_context");
function get_each_context$c(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
__name(get_each_context$c, "get_each_context$c");
const get_before_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_before_slot_changes");
const get_before_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_before_slot_context");
function create_if_block_3$d(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
      attr(hr, "class", "svelte-14ioya");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(hr);
    }
  };
}
__name(create_if_block_3$d, "create_if_block_3$d");
function create_if_block_2$d(ctx) {
  let div;
  let img;
  let img_src_value;
  let img_alt_value;
  let t_value = localize(ctx[19].label) + "";
  let t;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[15](ctx[19]);
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      div = element("div");
      img = element("img");
      t = text(t_value);
      if (!src_url_equal(img.src, img_src_value = ctx[19].image))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = ctx[19].alt);
      attr(img, "class", "svelte-14ioya");
      attr(div, "class", "tjs-menu-item svelte-14ioya");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", stop_propagation(prevent_default(click_handler_1)));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx[19].image)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 2 && img_alt_value !== (img_alt_value = ctx[19].alt)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & 2 && t_value !== (t_value = localize(ctx[19].label) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_2$d, "create_if_block_2$d");
function create_if_block_1$d(ctx) {
  let div;
  let i;
  let i_class_value;
  let t_value = localize(ctx[19].label) + "";
  let t;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[14](ctx[19]);
  }
  __name(click_handler, "click_handler");
  return {
    c() {
      div = element("div");
      i = element("i");
      t = text(t_value);
      attr(i, "class", i_class_value = null_to_empty(ctx[19].icon) + " svelte-14ioya");
      attr(div, "class", "tjs-menu-item svelte-14ioya");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", stop_propagation(prevent_default(click_handler)));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && i_class_value !== (i_class_value = null_to_empty(ctx[19].icon) + " svelte-14ioya")) {
        attr(i, "class", i_class_value);
      }
      if (dirty & 2 && t_value !== (t_value = localize(ctx[19].label) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$d, "create_if_block_1$d");
function create_if_block$j(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[19].class;
  function switch_props(ctx2) {
    return {};
  }
  __name(switch_props, "switch_props");
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "tjs-menu-item svelte-14ioya");
      attr(div, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", stop_propagation(prevent_default(ctx[4])));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[19].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$j, "create_if_block$j");
function create_each_block$c(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$j, create_if_block_1$d, create_if_block_2$d, create_if_block_3$d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[19]["#type"] === "class")
      return 0;
    if (ctx2[19]["#type"] === "icon")
      return 1;
    if (ctx2[19]["#type"] === "image")
      return 2;
    if (ctx2[19]["#type"] === "separator-hr")
      return 3;
    return -1;
  }
  __name(select_block_type, "select_block_type");
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_each_block$c, "create_each_block$c");
function create_fragment$o(ctx) {
  let t0;
  let nav;
  let section;
  let div;
  let t1;
  let t2;
  let t3;
  let nav_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const before_slot_template = ctx[13].before;
  const before_slot = create_slot(before_slot_template, ctx, ctx[12], get_before_slot_context);
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
  }
  const out = /* @__PURE__ */ __name((i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  }), "out");
  const after_slot_template = ctx[13].after;
  const after_slot = create_slot(after_slot_template, ctx, ctx[12], get_after_slot_context);
  return {
    c() {
      t0 = space();
      nav = element("nav");
      section = element("section");
      div = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (before_slot)
        before_slot.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (after_slot)
        after_slot.c();
      attr(div, "role", "presentation");
      attr(section, "class", "tjs-menu-items svelte-14ioya");
      attr(nav, "class", "tjs-menu svelte-14ioya");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, nav, anchor);
      append(nav, section);
      append(section, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(section, t1);
      if (before_slot) {
        before_slot.m(section, null);
      }
      append(section, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(section, null);
      }
      append(section, t3);
      if (after_slot) {
        after_slot.m(section, null);
      }
      ctx[16](nav);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "blur", ctx[6]),
          listen(document.body, "pointerdown", ctx[5]),
          listen(document.body, "wheel", ctx[5]),
          listen(div, "click", stop_propagation(prevent_default(ctx[4]))),
          action_destroyer(ctx[0].call(null, nav)),
          listen(nav, "click", stop_propagation(prevent_default(click_handler_2))),
          listen(nav, "keydown", stop_propagation(prevent_default(keydown_handler))),
          listen(nav, "wheel", stop_propagation(prevent_default(wheel_handler)))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      if (before_slot) {
        if (before_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            before_slot,
            before_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(before_slot_template, ctx2[12], dirty, get_before_slot_changes),
            get_before_slot_context
          );
        }
      }
      if (dirty & 18) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$c(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(section, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (after_slot) {
        if (after_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            after_slot,
            after_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(after_slot_template, ctx2[12], dirty, get_after_slot_changes),
            get_after_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(before_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(after_slot, local);
      add_render_callback(() => {
        if (!nav_transition)
          nav_transition = create_bidirectional_transition(nav, ctx[3], {}, true);
        nav_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(before_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(after_slot, local);
      if (!nav_transition)
        nav_transition = create_bidirectional_transition(nav, ctx[3], {}, false);
      nav_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(nav);
      if (default_slot)
        default_slot.d(detaching);
      if (before_slot)
        before_slot.d(detaching);
      destroy_each(each_blocks, detaching);
      if (after_slot)
        after_slot.d(detaching);
      ctx[16](null);
      if (detaching && nav_transition)
        nav_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$o, "create_fragment$o");
const click_handler_2 = /* @__PURE__ */ __name(() => null, "click_handler_2");
const keydown_handler = /* @__PURE__ */ __name(() => null, "keydown_handler");
const wheel_handler = /* @__PURE__ */ __name(() => null, "wheel_handler");
function instance$o($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const s_DEFAULT_OFFSET = { x: 0, y: 0 };
  let { menu = void 0 } = $$props;
  let { items = void 0 } = $$props;
  let { offset = void 0 } = $$props;
  let { styles: styles2 = void 0 } = $$props;
  let { efx = void 0 } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let allItems;
  let menuEl;
  let closed = false;
  function animate(node) {
    const result = getStackingContext(node.parentElement);
    if (!(result?.node instanceof HTMLElement)) {
      console.warn(`'TJSMenu.animate warning: Could not locate parent stacking context element.`);
      return;
    }
    const stackingContextRect = result?.node.getBoundingClientRect();
    const stackingContextRight = stackingContextRect.x + stackingContextRect.width;
    const nodeRect = node.getBoundingClientRect();
    const parentRect = node.parentElement.getBoundingClientRect();
    const adjustedOffset = { ...s_DEFAULT_OFFSET, ...offset };
    node.style.top = `${adjustedOffset.y + parentRect.height}px`;
    if (parentRect.x + nodeRect.width < stackingContextRight) {
      node.style.left = `${adjustedOffset.x}px`;
      node.style.removeProperty("right");
    } else {
      node.style.right = `${adjustedOffset.x}px`;
      node.style.removeProperty("left");
    }
    return slideFade(node, transitionOptions);
  }
  __name(animate, "animate");
  function onClick(item) {
    const callback = item?.onClick ?? item?.onclick;
    if (typeof callback === "function") {
      callback(item);
    }
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent("close", { bubbles: true }));
    }
  }
  __name(onClick, "onClick");
  async function onClose(event) {
    if (event.target === menuEl || menuEl.contains(event.target)) {
      return;
    }
    if (event.target === menuEl.parentElement || menuEl.parentElement.contains(event.target)) {
      return;
    }
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent("close", { bubbles: true }));
    }
  }
  __name(onClose, "onClose");
  function onWindowBlur() {
    if (!closed) {
      closed = true;
      menuEl.dispatchEvent(new CustomEvent("close", { bubbles: true }));
    }
  }
  __name(onWindowBlur, "onWindowBlur");
  const click_handler = /* @__PURE__ */ __name((item) => onClick(item), "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name((item) => onClick(item), "click_handler_1");
  function nav_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuEl = $$value;
      $$invalidate(2, menuEl);
    });
  }
  __name(nav_binding, "nav_binding");
  $$self.$$set = ($$props2) => {
    if ("menu" in $$props2)
      $$invalidate(10, menu = $$props2.menu);
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("offset" in $$props2)
      $$invalidate(7, offset = $$props2.offset);
    if ("styles" in $$props2)
      $$invalidate(8, styles2 = $$props2.styles);
    if ("efx" in $$props2)
      $$invalidate(0, efx = $$props2.efx);
    if ("transitionOptions" in $$props2)
      $$invalidate(9, transitionOptions = $$props2.transitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3072) {
      {
        const tempList = isObject(menu) && isIterable(menu.items) ? menu.items : isIterable(items) ? items : [];
        const tempItems = [];
        let cntr = -1;
        for (const item of tempList) {
          cntr++;
          if (!isObject(item)) {
            throw new TypeError(`TJSMenu error: 'item[${cntr}]' is not an object.`);
          }
          if (typeof item.condition === "function" && !item.condition()) {
            continue;
          }
          if (typeof item.condition === "boolean" && !item.condition) {
            continue;
          }
          let type;
          if (isSvelteComponent(item.class)) {
            type = "class";
          } else if (typeof item.icon === "string") {
            type = "icon";
          } else if (typeof item.image === "string") {
            type = "image";
          } else if (typeof item.separator === "string") {
            if (item.separator !== "hr") {
              throw new Error(`TJSMenu error: 'item[${cntr}]' has unknown separator type; only 'hr' is currently supported.`);
            }
            type = "separator-hr";
          }
          if (type === void 0) {
            throw new TypeError(`TJSMenu error: Unknown type for 'item[${cntr}]'.`);
          }
          tempItems.push({ ...item, "#type": type });
        }
        $$invalidate(1, allItems = tempItems);
      }
    }
    if ($$self.$$.dirty & 1152) {
      $$invalidate(7, offset = isObject(menu) && isObject(menu.offset) ? menu.offset : isObject(offset) ? offset : s_DEFAULT_OFFSET);
    }
    if ($$self.$$.dirty & 1280) {
      $$invalidate(8, styles2 = isObject(menu) && isObject(menu.styles) ? menu.styles : isObject(styles2) ? styles2 : void 0);
    }
    if ($$self.$$.dirty & 1025) {
      $$invalidate(0, efx = isObject(menu) && typeof menu.efx === "function" ? menu.efx : typeof efx === "function" ? efx : () => {
      });
    }
    if ($$self.$$.dirty & 1536) {
      $$invalidate(9, transitionOptions = isObject(menu) && isObject(menu.transitionOptions) ? menu.transitionOptions : isObject(transitionOptions) ? transitionOptions : { duration: 200, easing: quintOut });
    }
  };
  return [
    efx,
    allItems,
    menuEl,
    animate,
    onClick,
    onClose,
    onWindowBlur,
    offset,
    styles2,
    transitionOptions,
    menu,
    items,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    nav_binding
  ];
}
__name(instance$o, "instance$o");
class TJSMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$o, safe_not_equal, {
      menu: 10,
      items: 11,
      offset: 7,
      styles: 8,
      efx: 0,
      transitionOptions: 9
    });
  }
}
__name(TJSMenu, "TJSMenu");
const TJSContextMenu_svelte_svelte_type_style_lang = "";
const SettingEntry_svelte_svelte_type_style_lang = "";
const TJSSettingsEdit_svelte_svelte_type_style_lang = "";
cssVariables.set({
  "--tjs-action-ripple-background": "rgba(0, 0, 0, 0.35)"
});
cssVariables.set({
  "--tjs-icon-button-background": "none",
  "--tjs-icon-button-background-hover": "rgba(0, 0, 0, 0.10)",
  "--tjs-icon-button-background-selected": "rgba(0, 0, 0, 0.20)",
  "--tjs-icon-button-border-radius": "50%",
  "--tjs-icon-button-clip-path": "none",
  "--tjs-icon-button-diameter": "2em",
  "--tjs-icon-button-transition": "background 200ms linear, clip-path 200ms linear"
});
{
  const props = FoundryStyles.getProperties('input[type="text"], input[type="number"]');
  if (typeof props === "object") {
    cssVariables.set({
      "--tjs-input-background": "background" in props ? props.background : "rgba(0, 0, 0, 0.05)",
      "--tjs-input-border": "border" in props ? props.border : "1px solid var(--color-border-light-tertiary)",
      "--tjs-input-border-radius": "border-radius" in props ? props["border-radius"] : "3px",
      "--tjs-input-height": "height" in props ? props.height : "var(--form-field-height)",
      "--tjs-input-min-width": "min-width" in props ? props["min-width"] : "20px",
      "--tjs-input-padding": "padding" in props ? props["padding"] : "1px 3px",
      "--tjs-input-width": "width" in props ? props.width : "calc(100% - 2px)"
    });
  }
}
{
  const props = FoundryStyles.getProperties("option, optgroup");
  if (typeof props === "object") {
    cssVariables.set({
      "--tjs-select-option-background": "background" in props ? props.background : "var(--color-bg-option)"
    });
  }
}
cssVariables.set({
  "--tjs-label-transition": "background 200ms linear"
});
cssVariables.set({
  "--tjs-menu-border": "1px solid var(--color-border-dark, #000)",
  "--tjs-menu-box-shadow": "0 0 2px var(--color-shadow-dark, #000)",
  "--tjs-menu-color": "var(--color-text-light-primary, #EEE)",
  "--tjs-menu-item-hover-text-shadow-color": "var(--color-text-hyperlink, red)"
});
Hooks.on("PopOut:loading", (app, popout) => {
  if (app instanceof SvelteApplication) {
    popout.document.addEventListener("DOMContentLoaded", () => cssVariables.clone(popout.document));
  }
});
function create_default_slot$a(ctx) {
  let form_1;
  let tjsprosemirror;
  let updating_content;
  let t0;
  let footer;
  let button0;
  let i0;
  let t1;
  let t2_value = localize("Submit") + "";
  let t2;
  let button0_disabled_value;
  let t3;
  let button1;
  let i1;
  let t4;
  let t5_value = localize("Cancel") + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  function tjsprosemirror_content_binding(value) {
    ctx[7](value);
  }
  __name(tjsprosemirror_content_binding, "tjsprosemirror_content_binding");
  let tjsprosemirror_props = {};
  if (ctx[0] !== void 0) {
    tjsprosemirror_props.content = ctx[0];
  }
  tjsprosemirror = new TJSProseMirror({ props: tjsprosemirror_props });
  binding_callbacks.push(() => bind$1(tjsprosemirror, "content", tjsprosemirror_content_binding));
  return {
    c() {
      form_1 = element("form");
      create_component(tjsprosemirror.$$.fragment);
      t0 = space();
      footer = element("footer");
      button0 = element("button");
      i0 = element("i");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      button1 = element("button");
      i1 = element("i");
      t4 = space();
      t5 = text(t5_value);
      attr(i0, "class", "fas fa-download");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = ctx[4] === ctx[0];
      attr(i1, "class", "fas fa-times");
      attr(button1, "type", "button");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      set_style(footer, "margin-top", "1rem");
      set_style(footer, "flex", "0");
      attr(form_1, "class", "item-piles-flexcol");
      set_style(form_1, "padding", "0.5rem");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      mount_component(tjsprosemirror, form_1, null);
      append(form_1, t0);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i0);
      append(button0, t1);
      append(button0, t2);
      append(footer, t3);
      append(footer, button1);
      append(button1, i1);
      append(button1, t4);
      append(button1, t5);
      ctx[9](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[5], { once: true }),
          listen(button1, "click", ctx[8]),
          listen(form_1, "submit", prevent_default(ctx[6]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tjsprosemirror_changes = {};
      if (!updating_content && dirty & 1) {
        updating_content = true;
        tjsprosemirror_changes.content = ctx2[0];
        add_flush_callback(() => updating_content = false);
      }
      tjsprosemirror.$set(tjsprosemirror_changes);
      if (!current || dirty & 1 && button0_disabled_value !== (button0_disabled_value = ctx2[4] === ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsprosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsprosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(tjsprosemirror);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$a, "create_default_slot$a");
function create_fragment$n(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[10](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$a] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 2053) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$n, "create_fragment$n");
function instance$n($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { text: text2 } = $$props;
  let { elementRoot } = $$props;
  const originalText = text2;
  let form;
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function submit() {
    application.options.resolve(text2);
    application.close();
  }
  __name(submit, "submit");
  function tjsprosemirror_content_binding(value) {
    text2 = value;
    $$invalidate(0, text2);
  }
  __name(tjsprosemirror_content_binding, "tjsprosemirror_content_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(2, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
  };
  return [
    text2,
    elementRoot,
    form,
    application,
    originalText,
    requestSubmit,
    submit,
    tjsprosemirror_content_binding,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$n, "instance$n");
class Text_editor_dialog_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$n, safe_not_equal, { text: 0, elementRoot: 1 });
  }
  get text() {
    return this.$$.ctx[0];
  }
  set text(text2) {
    this.$$set({ text: text2 });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
__name(Text_editor_dialog_shell, "Text_editor_dialog_shell");
class TextEditorDialog extends SvelteApplication {
  constructor(text2, options) {
    super({
      title: game.i18n.localize("ITEM-PILES.Dialogs.TextEditor.Title"),
      id: "item-piles-text-editor",
      svelte: {
        class: Text_editor_dialog_shell,
        target: document.body,
        props: {
          text: text2
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 550,
      height: 450,
      classes: ["item-piles-app"],
      resizable: true
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-text-editor-${id}`);
  }
  static async show(text2, options = {}) {
    const apps = options.id ? this.getActiveApps(options.id) : [];
    if (apps.length) {
      for (let app of apps) {
        app.render(false, { focus: true });
      }
      return;
    }
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(text2, options).render(true, { focus: true });
    });
  }
}
__name(TextEditorDialog, "TextEditorDialog");
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
__name(get_each_context$b, "get_each_context$b");
function create_each_block$b(key_1, ctx) {
  let option;
  let t_value = (ctx[10].text ?? "") + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[10].name;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t_value !== (t_value = (ctx[10].text ?? "") + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx[10].name)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block$b, "create_each_block$b");
function create_fragment$m(ctx) {
  let div;
  let input;
  let t0;
  let datalist;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let i;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[10].id, "get_key");
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$b(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      datalist = element("datalist");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      i = element("i");
      attr(input, "type", "text");
      attr(input, "list", ctx[3]);
      set_style(input, "flex", "1");
      set_style(input, "margin-right", "5px");
      attr(input, "placeholder", localize("ITEM-PILES.Applications.ItemPileConfig.Main.MacroPlaceholder"));
      attr(datalist, "id", ctx[3]);
      attr(i, "title", "Open Macro");
      set_style(i, "margin-top", "5px");
      set_style(i, "font-size", "1rem");
      set_style(i, "flex", "0");
      attr(i, "class", "fas fa-edit item-piles-clickable-link");
      attr(div, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      append(div, t0);
      append(div, datalist);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(datalist, null);
      }
      append(div, t1);
      append(div, i);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[6]),
          listen(input, "keyup", ctx[7]),
          listen(input, "change", ctx[8]),
          listen(i, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, datalist, destroy_block, create_each_block$b, null, get_each_context$b);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$m, "create_fragment$m");
function instance$m($$self, $$props, $$invalidate) {
  let $macros;
  let { macro } = $$props;
  let macros = writable([]);
  component_subscribe($$self, macros, (value) => $$invalidate(1, $macros = value));
  const id = randomID() + "-list";
  function filterMacros() {
    let allResults = Array.from(game.macros).map((m) => ({ id: m.id, name: m.name }));
    const compendiums = Array.from(game.packs).filter((pack) => pack.documentName === "Macro").map((pack) => ({
      id: pack.metadata.id,
      name: "Compendium." + pack.metadata.id
    }));
    allResults = allResults.concat(compendiums);
    allResults = allResults.filter((m) => {
      return m.name.toLowerCase().includes(macro.toLowerCase()) || !macro;
    });
    if (macro.startsWith("Compendium.") && allResults.length === 1) {
      allResults = Array.from(game.packs.get(allResults[0].id).index).map((m) => {
        return {
          id: allResults[0].id + "." + m._id,
          name: allResults[0].name + "." + m.name
        };
      });
    }
    macros.set(allResults);
  }
  __name(filterMacros, "filterMacros");
  async function openMacro() {
    if (macro.startsWith("Compendium")) {
      let packArray = macro.split(".");
      let pack = game.packs.get(`${packArray[1]}.${packArray[2]}`);
      if (!pack) {
        custom_notify(`Compendium ${packArray[1]}.${packArray[2]} was not found`);
        return;
      }
      let macroFilter = pack.index.filter((m) => m.name === packArray[3]);
      if (!macroFilter.length) {
        custom_notify(`A macro named ${packArray[3]} was not found in Compendium ${packArray[1]}.${packArray[2]}`);
        return;
      }
      let macroDocument = await pack.getDocument(macroFilter[0]._id);
      macroDocument.sheet.render(true);
    } else {
      if (!macro) {
        return;
      }
      let getTest = game.macros.getName(macro);
      if (!getTest) {
        custom_notify(`Could not find the macro named ${macro}`);
        return;
      }
      game.macros.getName(macro).sheet.render(true);
    }
  }
  __name(openMacro, "openMacro");
  filterMacros();
  function input_input_handler() {
    macro = this.value;
    $$invalidate(0, macro);
  }
  __name(input_input_handler, "input_input_handler");
  const keyup_handler = /* @__PURE__ */ __name(() => {
    filterMacros();
  }, "keyup_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    filterMacros();
  }, "change_handler");
  const click_handler = /* @__PURE__ */ __name(() => openMacro(), "click_handler");
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$invalidate(0, macro = $$props2.macro);
  };
  return [
    macro,
    $macros,
    macros,
    id,
    filterMacros,
    openMacro,
    input_input_handler,
    keyup_handler,
    change_handler,
    click_handler
  ];
}
__name(instance$m, "instance$m");
class MacroSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$m, safe_not_equal, { macro: 0 });
  }
}
__name(MacroSelector, "MacroSelector");
const PriceSelector_svelte_svelte_type_style_lang = "";
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
__name(get_each_context$a, "get_each_context$a");
function get_each_context_1$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
__name(get_each_context_1$5, "get_each_context_1$5");
function create_else_block$6(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      attr(small, "class", "svelte-14dxq78");
      toggle_class(small, "cant-afford", ctx[2]);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      small.innerHTML = ctx[5];
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        small.innerHTML = ctx2[5];
      if (dirty & 4) {
        toggle_class(small, "cant-afford", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
__name(create_else_block$6, "create_else_block$6");
function create_if_block$i(ctx) {
  let tjstogglelabel;
  let current;
  tjstogglelabel = new TJSToggleLabel({
    props: {
      $$slots: {
        left: [create_left_slot],
        default: [create_default_slot$9]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjstogglelabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjstogglelabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjstogglelabel_changes = {};
      if (dirty & 524543) {
        tjstogglelabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjstogglelabel.$set(tjstogglelabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjstogglelabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjstogglelabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjstogglelabel, detaching);
    }
  };
}
__name(create_if_block$i, "create_if_block$i");
function create_each_block_1$5(key_1, ctx) {
  let div2;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div1;
  let t1_value = ctx[16].baseCost + (ctx[13].prices.length === 0 && ctx[16].percent ? "%" : "");
  let t1;
  let t2;
  let t3_value = ctx[16].name + "";
  let t3;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[11](ctx[15]);
  }
  __name(click_handler, "click_handler");
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[16].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      toggle_class(div0, "not-for-sale", !ctx[16].maxQuantity && ctx[0].store.recipient);
      attr(div1, "class", "item-piles-name item-piles-text");
      attr(div2, "class", "price-group-container svelte-14dxq78");
      toggle_class(div2, "cant-afford", !ctx[13].maxQuantity && ctx[0].store.recipient);
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, img);
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
      append(div1, t2);
      append(div1, t3);
      if (!mounted) {
        dispose = listen(div2, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && !src_url_equal(img.src, img_src_value = ctx[16].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 17) {
        toggle_class(div0, "not-for-sale", !ctx[16].maxQuantity && ctx[0].store.recipient);
      }
      if (dirty & 16 && t1_value !== (t1_value = ctx[16].baseCost + (ctx[13].prices.length === 0 && ctx[16].percent ? "%" : "")))
        set_data(t1, t1_value);
      if (dirty & 16 && t3_value !== (t3_value = ctx[16].name + ""))
        set_data(t3, t3_value);
      if (dirty & 17) {
        toggle_class(div2, "cant-afford", !ctx[13].maxQuantity && ctx[0].store.recipient);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block_1$5, "create_each_block_1$5");
function create_each_block$a(key_1, ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_1 = ctx[13].prices.filter(func$1);
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[16].id, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$5(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$5(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "price-group");
      toggle_class(div, "selected", ctx[3] === ctx[15]);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 153) {
        each_value_1 = ctx[13].prices.filter(func$1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1$5, t, get_each_context_1$5);
      }
      if (dirty & 24) {
        toggle_class(div, "selected", ctx[3] === ctx[15]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_each_block$a, "create_each_block$a");
function create_default_slot_1$1(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[4];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[15], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$a(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "price-list");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 153) {
        each_value = ctx2[4];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$a, null, get_each_context$a);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_default_slot_1$1, "create_default_slot_1$1");
function create_default_slot$9(ctx) {
  let tjsmenu;
  let current;
  tjsmenu = new TJSMenu({
    props: {
      offset: { y: 4 },
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tjsmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjsmenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsmenu_changes = {};
      if (dirty & 524441) {
        tjsmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjsmenu.$set(tjsmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsmenu, detaching);
    }
  };
}
__name(create_default_slot$9, "create_default_slot$9");
function create_left_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "slot", "left");
      attr(div, "class", "svelte-14dxq78");
      toggle_class(div, "multiple-prices", ctx[4].length > 1 && !ctx[1]);
      toggle_class(div, "cant-afford", ctx[2]);
      toggle_class(div, "cant-afford-multiple-prices", ctx[6]);
      toggle_class(div, "item-piles-clickable-link", ctx[4].length > 1);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = ctx[5];
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        div.innerHTML = ctx2[5];
      if (dirty & 18) {
        toggle_class(div, "multiple-prices", ctx2[4].length > 1 && !ctx2[1]);
      }
      if (dirty & 4) {
        toggle_class(div, "cant-afford", ctx2[2]);
      }
      if (dirty & 64) {
        toggle_class(div, "cant-afford-multiple-prices", ctx2[6]);
      }
      if (dirty & 16) {
        toggle_class(div, "item-piles-clickable-link", ctx2[4].length > 1);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_left_slot, "create_left_slot");
function create_fragment$l(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$i, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].length > 1)
      return 0;
    return 1;
  }
  __name(select_block_type, "select_block_type");
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "price-container svelte-14dxq78");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
__name(create_fragment$l, "create_fragment$l");
const func$1 = /* @__PURE__ */ __name((price) => price.cost, "func$1");
function instance$l($$self, $$props, $$invalidate) {
  let cantAfford;
  let cantAffordMultiplePrices;
  let $selectedPriceGroup;
  let $prices;
  let $priceSelector;
  let { item } = $$props;
  let { standalone = false } = $$props;
  let labelText = "";
  const prices = item.prices;
  component_subscribe($$self, prices, (value) => $$invalidate(4, $prices = value));
  item.itemFlagData;
  const selectedPriceGroup = item.selectedPriceGroup;
  component_subscribe($$self, selectedPriceGroup, (value) => $$invalidate(3, $selectedPriceGroup = value));
  const priceSelector = standalone ? writable("") : item.store.priceSelector;
  component_subscribe($$self, priceSelector, (value) => $$invalidate(7, $priceSelector = value));
  const click_handler = /* @__PURE__ */ __name((index) => {
    set_store_value(selectedPriceGroup, $selectedPriceGroup = index, $selectedPriceGroup);
    set_store_value(priceSelector, $priceSelector = "", $priceSelector);
  }, "click_handler");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("standalone" in $$props2)
      $$invalidate(1, standalone = $$props2.standalone);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 27) {
      $$invalidate(2, cantAfford = $prices.length > 0 && !$prices[$selectedPriceGroup]?.maxQuantity && item.store.recipient && !standalone);
    }
    if ($$self.$$.dirty & 20) {
      $$invalidate(6, cantAffordMultiplePrices = cantAfford && !$prices.filter((group) => group.maxQuantity).length);
    }
    if ($$self.$$.dirty & 26) {
      $$invalidate(5, labelText = (standalone && $prices.length > 1 ? '<i class="fas fa-edit"></i> ' : "") + ($prices[$selectedPriceGroup]?.free ? localize("ITEM-PILES.Merchant.ItemFree") : $prices[$selectedPriceGroup]?.basePriceString));
    }
  };
  return [
    item,
    standalone,
    cantAfford,
    $selectedPriceGroup,
    $prices,
    labelText,
    cantAffordMultiplePrices,
    $priceSelector,
    prices,
    selectedPriceGroup,
    priceSelector,
    click_handler
  ];
}
__name(instance$l, "instance$l");
class PriceSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$l, safe_not_equal, { item: 0, standalone: 1 });
  }
}
__name(PriceSelector, "PriceSelector");
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  return child_ctx;
}
__name(get_each_context$9, "get_each_context$9");
function get_each_context_1$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[38] = list[i];
  return child_ctx;
}
__name(get_each_context_1$4, "get_each_context_1$4");
function create_if_block_6$2(ctx) {
  let div;
  let small0;
  let t1;
  let small1;
  let t2;
  let t3_value = localize("ITEM-PILES.Applications.TradeMerchantItem.MaxQuantity", {
    quantity: ctx[5]
  }) + "";
  let t3;
  let t4;
  let t5;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      small0 = element("small");
      small0.textContent = `${localize("ITEM-PILES.Applications.TradeMerchantItem.Quantity")}`;
      t1 = space();
      small1 = element("small");
      t2 = text("(");
      t3 = text(t3_value);
      t4 = text(")");
      t5 = space();
      input = element("input");
      set_style(small1, "font-style", "italic");
      set_style(div, "display", "flex");
      set_style(div, "flex-direction", "column");
      set_style(div, "align-items", "flex-end");
      set_style(div, "margin-right", "0.5rem");
      set_style(input, "max-width", "40px");
      set_style(input, "max-height", "24px");
      attr(input, "type", "number");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, small0);
      append(div, t1);
      append(div, small1);
      append(small1, t2);
      append(small1, t3);
      append(small1, t4);
      insert(target, t5, anchor);
      insert(target, input, anchor);
      set_input_value(input, ctx[6]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[29]),
          listen(input, "change", ctx[30])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t3_value !== (t3_value = localize("ITEM-PILES.Applications.TradeMerchantItem.MaxQuantity", {
        quantity: ctx2[5]
      }) + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 64 && to_number(input.value) !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_6$2, "create_if_block_6$2");
function create_else_block_1$2(ctx) {
  let small;
  let t_value = localize(`ITEM-PILES.Applications.TradeMerchantItem.${ctx[2].selling ? "They" : "You"}CantAfford`) + "";
  let t;
  return {
    c() {
      small = element("small");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && t_value !== (t_value = localize(`ITEM-PILES.Applications.TradeMerchantItem.${ctx2[2].selling ? "They" : "You"}CantAfford`) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
__name(create_else_block_1$2, "create_else_block_1$2");
function create_if_block_4$7(ctx) {
  let if_block_anchor;
  let if_block = ctx[4] > 1 && ctx[7].primary && create_if_block_5$3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[4] > 1 && ctx2[7].primary) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5$3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_4$7, "create_if_block_4$7");
function create_if_block_5$3(ctx) {
  let small;
  let t_value = ctx[7].basePriceString + "";
  let t;
  return {
    c() {
      small = element("small");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && t_value !== (t_value = ctx2[7].basePriceString + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
__name(create_if_block_5$3, "create_if_block_5$3");
function create_if_block_3$c(ctx) {
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1_value = ctx[38].quantity + "";
  let t1;
  let t2;
  let t3_value = localize(ctx[38].name) + "";
  let t3;
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[38].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      set_style(div0, "margin-right", "0.25rem");
      set_style(div1, "display", "flex");
      set_style(div1, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      append(div1, t0);
      append(div1, span);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(div1, t4);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && !src_url_equal(img.src, img_src_value = ctx2[38].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & 128 && t1_value !== (t1_value = ctx2[38].quantity + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 128 && t3_value !== (t3_value = localize(ctx2[38].name) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
__name(create_if_block_3$c, "create_if_block_3$c");
function create_each_block_1$4(ctx) {
  let if_block_anchor;
  let if_block = ctx[38].quantity && create_if_block_3$c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[38].quantity) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$c(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_each_block_1$4, "create_each_block_1$4");
function create_if_block_1$c(ctx) {
  let span;
  let t2;
  let each_1_anchor;
  let each_value = ctx[7].buyerChange;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  return {
    c() {
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Applications.TradeMerchantItem.Change")}:`;
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(span, "class", "item-piles-small-text item-piles-text-right");
      set_style(span, "margin-right", "0.25rem");
      set_style(span, "margin-top", "0.5rem");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128) {
        each_value = ctx2[7].buyerChange;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t2);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
__name(create_if_block_1$c, "create_if_block_1$c");
function create_if_block_2$c(ctx) {
  let div1;
  let span;
  let t0_value = ctx[35].quantity + "";
  let t0;
  let t1;
  let t2_value = localize(ctx[35].name) + "";
  let t2;
  let t3;
  let div0;
  let img;
  let img_src_value;
  let t4;
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      div0 = element("div");
      img = element("img");
      t4 = space();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[35].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      set_style(div0, "margin-left", "0.25rem");
      set_style(div1, "display", "flex");
      set_style(div1, "align-items", "center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, img);
      append(div1, t4);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && t0_value !== (t0_value = ctx2[35].quantity + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 128 && t2_value !== (t2_value = localize(ctx2[35].name) + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 128 && !src_url_equal(img.src, img_src_value = ctx2[35].img)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
__name(create_if_block_2$c, "create_if_block_2$c");
function create_each_block$9(ctx) {
  let if_block_anchor;
  let if_block = ctx[35].quantity && create_if_block_2$c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[35].quantity) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$c(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_each_block$9, "create_each_block$9");
function create_else_block$5(ctx) {
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Applications.TradeMerchantItem.BuyItem") + "";
  let t1;
  return {
    c() {
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-shopping-cart");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
__name(create_else_block$5, "create_else_block$5");
function create_if_block$h(ctx) {
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Applications.TradeMerchantItem.SellItem") + "";
  let t1;
  return {
    c() {
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-hand-holding-usd");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
__name(create_if_block$h, "create_if_block$h");
function create_default_slot$8(ctx) {
  let div11;
  let div5;
  let div1;
  let div0;
  let img0;
  let img0_src_value;
  let t0;
  let span0;
  let t1_value = localize(ctx[9]) + "";
  let t1;
  let t2;
  let div2;
  let t3;
  let div3;
  let priceselector;
  let t4;
  let div4;
  let t5;
  let div10;
  let strong0;
  let t6_value = localize("ITEM-PILES.Applications.TradeMerchantItem." + (ctx[2].selling ? "YouReceive" : "YouPay")) + "";
  let t6;
  let t7;
  let t8;
  let strong1;
  let t9_value = localize("ITEM-PILES.Applications.TradeMerchantItem." + (ctx[2].selling ? "TheyReceive" : "YouReceive")) + "";
  let t9;
  let t10;
  let t11;
  let div6;
  let t12;
  let div9;
  let div8;
  let span1;
  let t13_value = ctx[4] > 1 ? ctx[4] + " " : "";
  let t13;
  let t14;
  let t15;
  let div7;
  let img1;
  let img1_src_value;
  let t16;
  let t17;
  let footer;
  let button0;
  let button0_disabled_value;
  let t18;
  let button1;
  let i;
  let t19;
  let t20_value = localize("Cancel") + "";
  let t20;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_6$2(ctx);
  priceselector = new PriceSelector({
    props: { item: ctx[1], standalone: true }
  });
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_4$7;
    return create_else_block_1$2;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  let each_value_1 = ctx[7].finalPrices;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  let if_block2 = ctx[7].buyerChange.length && create_if_block_1$c(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].selling)
      return create_if_block$h;
    return create_else_block$5;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block3 = current_block_type_1(ctx);
  return {
    c() {
      div11 = element("div");
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      img0 = element("img");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t3 = space();
      div3 = element("div");
      create_component(priceselector.$$.fragment);
      t4 = space();
      div4 = element("div");
      if_block1.c();
      t5 = space();
      div10 = element("div");
      strong0 = element("strong");
      t6 = text(t6_value);
      t7 = text(":");
      t8 = space();
      strong1 = element("strong");
      t9 = text(t9_value);
      t10 = text(":");
      t11 = space();
      div6 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t12 = space();
      div9 = element("div");
      div8 = element("div");
      span1 = element("span");
      t13 = text(t13_value);
      t14 = text(ctx[9]);
      t15 = space();
      div7 = element("div");
      img1 = element("img");
      t16 = space();
      if (if_block2)
        if_block2.c();
      t17 = space();
      footer = element("footer");
      button0 = element("button");
      if_block3.c();
      t18 = space();
      button1 = element("button");
      i = element("i");
      t19 = space();
      t20 = text(t20_value);
      attr(img0, "class", "item-piles-img");
      if (!src_url_equal(img0.src, img0_src_value = ctx[8]))
        attr(img0, "src", img0_src_value);
      attr(div0, "class", "item-piles-img-container");
      set_style(div0, "margin-right", "0.25rem");
      set_style(div1, "display", "flex");
      set_style(div1, "align-items", "center");
      set_style(div1, "font-size", "1rem");
      set_style(div1, "grid-row", "1");
      set_style(div2, "display", "flex");
      set_style(div2, "justify-content", "flex-end");
      set_style(div2, "align-items", "center");
      set_style(div2, "text-align", "right");
      set_style(div3, "margin-top", "0.25rem");
      set_style(div4, "margin-right", "0.25rem");
      set_style(div4, "text-align", "right");
      set_style(div5, "display", "grid");
      set_style(div5, "grid-template-columns", "1fr 0.75fr");
      set_style(div5, "margin-bottom", "0.5rem");
      attr(strong0, "class", "item-piles-bottom-divider");
      set_style(strong0, "margin-bottom", "0.25rem");
      set_style(strong0, "padding-bottom", "0.25rem");
      attr(strong1, "class", "item-piles-bottom-divider item-piles-text-right");
      set_style(strong1, "margin-bottom", "0.25rem");
      set_style(strong1, "padding-bottom", "0.25rem");
      attr(img1, "class", "item-piles-img");
      if (!src_url_equal(img1.src, img1_src_value = ctx[8]))
        attr(img1, "src", img1_src_value);
      attr(div7, "class", "item-piles-img-container");
      set_style(div7, "margin-left", "0.25rem");
      set_style(div8, "display", "flex");
      set_style(div8, "align-items", "center");
      set_style(div9, "display", "flex");
      set_style(div9, "flex-direction", "column");
      set_style(div9, "align-items", "flex-end");
      set_style(div10, "display", "grid");
      set_style(div10, "grid-template-columns", "auto auto");
      attr(div10, "class", "item-piles-bottom-divider");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = !ctx[5];
      attr(i, "class", "fas fa-times");
      attr(button1, "type", "button");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      set_style(footer, "margin-top", "1rem");
    },
    m(target, anchor) {
      insert(target, div11, anchor);
      append(div11, div5);
      append(div5, div1);
      append(div1, div0);
      append(div0, img0);
      append(div1, t0);
      append(div1, span0);
      append(span0, t1);
      append(div5, t2);
      append(div5, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append(div5, t3);
      append(div5, div3);
      mount_component(priceselector, div3, null);
      append(div5, t4);
      append(div5, div4);
      if_block1.m(div4, null);
      append(div11, t5);
      append(div11, div10);
      append(div10, strong0);
      append(strong0, t6);
      append(strong0, t7);
      append(div10, t8);
      append(div10, strong1);
      append(strong1, t9);
      append(strong1, t10);
      append(div10, t11);
      append(div10, div6);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div6, null);
      }
      append(div10, t12);
      append(div10, div9);
      append(div9, div8);
      append(div8, span1);
      append(span1, t13);
      append(span1, t14);
      append(div8, t15);
      append(div8, div7);
      append(div7, img1);
      append(div9, t16);
      if (if_block2)
        if_block2.m(div9, null);
      append(div11, t17);
      append(div11, footer);
      append(footer, button0);
      if_block3.m(button0, null);
      append(footer, t18);
      append(footer, button1);
      append(button1, i);
      append(button1, t19);
      append(button1, t20);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[31], { once: true }),
          listen(button1, "click", ctx[32], { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 256 && !src_url_equal(img0.src, img0_src_value = ctx2[8])) {
        attr(img0, "src", img0_src_value);
      }
      if ((!current || dirty[0] & 512) && t1_value !== (t1_value = localize(ctx2[9]) + ""))
        set_data(t1, t1_value);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$2(ctx2);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const priceselector_changes = {};
      if (dirty[0] & 2)
        priceselector_changes.item = ctx2[1];
      priceselector.$set(priceselector_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div4, null);
        }
      }
      if ((!current || dirty[0] & 4) && t6_value !== (t6_value = localize("ITEM-PILES.Applications.TradeMerchantItem." + (ctx2[2].selling ? "YouReceive" : "YouPay")) + ""))
        set_data(t6, t6_value);
      if ((!current || dirty[0] & 4) && t9_value !== (t9_value = localize("ITEM-PILES.Applications.TradeMerchantItem." + (ctx2[2].selling ? "TheyReceive" : "YouReceive")) + ""))
        set_data(t9, t9_value);
      if (dirty[0] & 128) {
        each_value_1 = ctx2[7].finalPrices;
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div6, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if ((!current || dirty[0] & 16) && t13_value !== (t13_value = ctx2[4] > 1 ? ctx2[4] + " " : ""))
        set_data(t13, t13_value);
      if (!current || dirty[0] & 512)
        set_data(t14, ctx2[9]);
      if (!current || dirty[0] & 256 && !src_url_equal(img1.src, img1_src_value = ctx2[8])) {
        attr(img1, "src", img1_src_value);
      }
      if (ctx2[7].buyerChange.length) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$c(ctx2);
          if_block2.c();
          if_block2.m(div9, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type_1(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(button0, null);
        }
      }
      if (!current || dirty[0] & 32 && button0_disabled_value !== (button0_disabled_value = !ctx2[5])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(priceselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(priceselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div11);
      if (if_block0)
        if_block0.d();
      destroy_component(priceselector);
      if_block1.d();
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
      if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$8, "create_default_slot$8");
function create_fragment$k(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[33](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$8] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 1022 | dirty[1] & 1024) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$k, "create_fragment$k");
function instance$k($$self, $$props, $$invalidate) {
  let maxMerchantItemQuantity;
  let maxItemQuantity;
  let $selectedPriceGroup;
  let $prices;
  let $itemMaxQuantityStore;
  let $sellerPileData;
  let $buyerPileData;
  let $quantityToBuy;
  let $itemImg;
  let $itemName;
  const { application } = getContext("external");
  let { item } = $$props;
  let { seller } = $$props;
  let { buyer } = $$props;
  let { settings } = $$props;
  let { elementRoot } = $$props;
  let { store = item.store } = $$props;
  const itemName = item.name;
  component_subscribe($$self, itemName, (value) => $$invalidate(9, $itemName = value));
  const itemImg = item.img;
  component_subscribe($$self, itemImg, (value) => $$invalidate(8, $itemImg = value));
  item.itemFlagData;
  const quantityToBuy = item.quantityToBuy;
  component_subscribe($$self, quantityToBuy, (value) => $$invalidate(4, $quantityToBuy = value));
  const itemMaxQuantityStore = item.quantity;
  component_subscribe($$self, itemMaxQuantityStore, (value) => $$invalidate(26, $itemMaxQuantityStore = value));
  const prices = item.prices;
  component_subscribe($$self, prices, (value) => $$invalidate(25, $prices = value));
  const sellerPileData = store.pileData;
  component_subscribe($$self, sellerPileData, (value) => $$invalidate(27, $sellerPileData = value));
  const buyerPileData = store.recipientPileData;
  component_subscribe($$self, buyerPileData, (value) => $$invalidate(28, $buyerPileData = value));
  let maxItemPurchaseQuantity;
  let currentQuantityToBuy;
  const selectedPriceGroup = item.selectedPriceGroup;
  component_subscribe($$self, selectedPriceGroup, (value) => $$invalidate(24, $selectedPriceGroup = value));
  let paymentData = {};
  function submit() {
    game.itempiles.API.tradeItems(
      seller,
      buyer,
      [
        {
          item: item.item,
          paymentIndex: get_store_value(selectedPriceGroup),
          quantity: get_store_value(quantityToBuy)
        }
      ],
      { interactionId: store.interactionId }
    );
    application.options.resolve();
    application.close();
  }
  __name(submit, "submit");
  function input_input_handler() {
    currentQuantityToBuy = to_number(this.value);
    $$invalidate(6, currentQuantityToBuy), $$invalidate(24, $selectedPriceGroup);
  }
  __name(input_input_handler, "input_input_handler");
  const change_handler = /* @__PURE__ */ __name((evt) => {
    set_store_value(quantityToBuy, $quantityToBuy = Math.max(1, Math.min(currentQuantityToBuy, maxItemPurchaseQuantity)), $quantityToBuy);
    $$invalidate(6, currentQuantityToBuy = $quantityToBuy);
  }, "change_handler");
  const click_handler = /* @__PURE__ */ __name(() => {
    submit();
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler_1");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("seller" in $$props2)
      $$invalidate(20, seller = $$props2.seller);
    if ("buyer" in $$props2)
      $$invalidate(21, buyer = $$props2.buyer);
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("store" in $$props2)
      $$invalidate(22, store = $$props2.store);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16777216) {
      {
        $$invalidate(6, currentQuantityToBuy = 1);
        set_store_value(quantityToBuy, $quantityToBuy = 1, $quantityToBuy);
      }
    }
    if ($$self.$$.dirty[0] & 422576146) {
      {
        $$invalidate(7, paymentData = getPricesForItems(
          [
            {
              item: item.item,
              quantity: $quantityToBuy,
              paymentIndex: $selectedPriceGroup
            }
          ],
          {
            seller,
            buyer,
            sellerFlagData: $sellerPileData,
            buyerFlagData: $buyerPileData
          }
        ));
      }
    }
    if ($$self.$$.dirty[0] & 201326592) {
      $$invalidate(23, maxMerchantItemQuantity = $sellerPileData.infiniteQuantity ? Infinity : $itemMaxQuantityStore);
    }
    if ($$self.$$.dirty[0] & 50331648) {
      $$invalidate(3, maxItemQuantity = $prices[$selectedPriceGroup]?.maxQuantity ?? Infinity);
    }
    if ($$self.$$.dirty[0] & 8388616) {
      $$invalidate(5, maxItemPurchaseQuantity = Math.min(maxItemQuantity, maxMerchantItemQuantity));
    }
  };
  return [
    elementRoot,
    item,
    settings,
    maxItemQuantity,
    $quantityToBuy,
    maxItemPurchaseQuantity,
    currentQuantityToBuy,
    paymentData,
    $itemImg,
    $itemName,
    application,
    itemName,
    itemImg,
    quantityToBuy,
    itemMaxQuantityStore,
    prices,
    sellerPileData,
    buyerPileData,
    selectedPriceGroup,
    submit,
    seller,
    buyer,
    store,
    maxMerchantItemQuantity,
    $selectedPriceGroup,
    $prices,
    $itemMaxQuantityStore,
    $sellerPileData,
    $buyerPileData,
    input_input_handler,
    change_handler,
    click_handler,
    click_handler_1,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$k, "instance$k");
class Trade_merchant_item_dialog_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$k,
      create_fragment$k,
      safe_not_equal,
      {
        item: 1,
        seller: 20,
        buyer: 21,
        settings: 2,
        elementRoot: 0,
        store: 22
      },
      null,
      [-1, -1]
    );
  }
  get item() {
    return this.$$.ctx[1];
  }
  set item(item) {
    this.$$set({ item });
    flush();
  }
  get seller() {
    return this.$$.ctx[20];
  }
  set seller(seller) {
    this.$$set({ seller });
    flush();
  }
  get buyer() {
    return this.$$.ctx[21];
  }
  set buyer(buyer) {
    this.$$set({ buyer });
    flush();
  }
  get settings() {
    return this.$$.ctx[2];
  }
  set settings(settings) {
    this.$$set({ settings });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get store() {
    return this.$$.ctx[22];
  }
  set store(store) {
    this.$$set({ store });
    flush();
  }
}
__name(Trade_merchant_item_dialog_shell, "Trade_merchant_item_dialog_shell");
class TradeMerchantItemDialog extends SvelteApplication {
  constructor(item, seller, buyer, settings = {}, options = {}) {
    super({
      id: `item-pile-buy-item-dialog-${item.id}-${seller.id}-${buyer.id}`,
      title: game.i18n.format("ITEM-PILES.Applications.TradeMerchantItem.Title", { item_name: get_store_value(item.name) }),
      svelte: {
        class: Trade_merchant_item_dialog_shell,
        target: document.body,
        props: {
          item,
          seller,
          buyer,
          settings
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 330,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-buy-item-dialog-${id}`);
  }
  static async show(item, seller, buyer, settings = {}, options = {}) {
    const apps = this.getActiveApps(item.id + "-" + seller.id + "-" + buyer.id);
    if (apps.length) {
      for (let app of apps) {
        app.render(false, { focus: true });
      }
      return;
    }
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(item, seller, buyer, settings, options).render(true, { focus: true });
    });
  }
}
__name(TradeMerchantItemDialog, "TradeMerchantItemDialog");
class MerchantStore extends ItemPileStore {
  setupStores() {
    super.setupStores();
    this.services = writable({});
    this.editPrices = writable(false);
    this.typeFilter = writable("all");
    this.priceModifiersPerType = writable({});
    this.priceModifiersForActor = writable({});
    this.priceSelector = writable("");
    this.closed = writable(false);
    this.listenToDateChange = true;
    this.activateHooks();
  }
  get ItemClass() {
    return PileMerchantItem;
  }
  getActorImage() {
    const pileData = get_store_value(this.pileData);
    return pileData?.merchantImage || this.actor.img;
  }
  activateHooks() {
    if (game.modules.get("foundryvtt-simple-calendar")?.active) {
      this.setupSimpleCalendar();
    }
  }
  setupSimpleCalendar() {
    Hooks.on(window.SimpleCalendar.Hooks.DateTimeChange, () => {
      this.updateClosedStatus();
    });
  }
  setupSubscriptions() {
    super.setupSubscriptions();
    this.subscribeTo(this.pileData, (pileData) => {
      this.updatePriceModifiers();
      this.updateClosedStatus();
    });
    if (this.recipientDocument) {
      this.subscribeTo(this.recipientPileData, () => {
        this.updatePriceModifiers();
      });
      this.subscribeTo(this.recipientDocument, () => {
        this.refreshItemPrices();
      });
    }
    const filterDebounce = foundry.utils.debounce(() => {
      this.refreshItems();
    }, 300);
    this.subscribeTo(this.typeFilter, (val) => {
      if (!val)
        return;
      filterDebounce();
    });
  }
  refreshItemPrices() {
    get_store_value(this.allItems).forEach((item) => {
      item.refreshPriceData();
    });
  }
  createItem(item) {
    if (isItemInvalid(this.actor, item))
      return;
    const items = get_store_value(this.allItems);
    const itemClass = new this.ItemClass(this, item);
    itemClass.refreshPriceData();
    items.push(itemClass);
    this.allItems.set(items);
    this.refreshItems();
  }
  deleteItem(item) {
    if (isItemInvalid(this.actor, item))
      return;
    const items = get_store_value(this.allItems);
    const pileItem = items.find((pileItem2) => pileItem2.id === item.id);
    if (!pileItem)
      return;
    pileItem.unsubscribe();
    items.splice(items.indexOf(pileItem), 1);
    this.allItems.set(items);
    this.refreshItems();
  }
  updatePriceModifiers() {
    let pileData = get_store_value(this.pileData);
    this.priceModifiersPerType.set(pileData.itemTypePriceModifiers.reduce((acc, priceData) => {
      acc[priceData.type] = priceData;
      return acc;
    }, {}));
    if (this.recipient && pileData.actorPriceModifiers) {
      const actorSpecificModifiers = pileData.actorPriceModifiers?.find((data) => data.actorUuid === this.recipientUuid);
      if (actorSpecificModifiers) {
        this.priceModifiersForActor.set(actorSpecificModifiers);
      }
    }
  }
  addOverrideTypePrice(type) {
    const pileData = get_store_value(this.pileData);
    pileData.itemTypePriceModifiers.push({
      type,
      override: false,
      buyPriceModifier: 1,
      sellPriceModifier: 1
    });
    this.pileData.set(pileData);
  }
  removeOverrideTypePrice(type) {
    const pileData = get_store_value(this.pileData);
    const priceMods = pileData.itemTypePriceModifiers;
    const typeEntry = priceMods.find((entry) => entry.type === type);
    priceMods.splice(priceMods.indexOf(typeEntry), 1);
    this.pileData.set(pileData);
  }
  async update() {
    const pileData = get_store_value(this.pileData);
    const priceModPerType = get_store_value(this.priceModifiersPerType);
    pileData.itemTypePriceModifiers = Object.values(priceModPerType);
    await updateItemPileData(this.actor, pileData);
    custom_notify(localize("ITEM-PILES.Notifications.UpdateMerchantSuccess"));
  }
  tradeItem(pileItem, selling) {
    if (get_store_value(pileItem.itemFlagData).notForSale && !game.user.isGM)
      return;
    TradeMerchantItemDialog.show(
      pileItem,
      this.actor,
      this.recipient,
      { selling }
    );
  }
  async updateClosedStatus() {
    if (!this.listenToDateChange)
      return;
    const pileData = get_store_value(this.pileData);
    if (pileData.openTimes.status === "auto") {
      if (game.modules.get("foundryvtt-simple-calendar")?.active && pileData.openTimes.enabled) {
        const openTimes = pileData.openTimes.open;
        const closeTimes = pileData.openTimes.close;
        const timestamp = window.SimpleCalendar.api.timestampToDate(window.SimpleCalendar.api.timestamp());
        const openingTime = Number(openTimes.hour.toString() + "." + openTimes.minute.toString());
        const closingTime = Number(closeTimes.hour.toString() + "." + closeTimes.minute.toString());
        const currentTime = Number(timestamp.hour.toString() + "." + timestamp.minute.toString());
        const isClosed = openingTime > closingTime ? !(currentTime >= openingTime || currentTime <= closingTime) : !(currentTime >= openingTime && currentTime <= closingTime);
        this.closed.set(isClosed);
      } else if (isResponsibleGM()) {
        pileData.openTimes.status = "open";
        await updateItemPileData(this.actor, pileData);
      }
    } else if (!pileData.openTimes.status.startsWith("auto")) {
      this.closed.set(pileData.openTimes.status === "closed");
    }
  }
  async setOpenStatus(status) {
    const pileData = get_store_value(this.pileData);
    pileData.openTimes.status = status;
    await updateItemPileData(this.actor, pileData);
  }
}
__name(MerchantStore, "MerchantStore");
class PileMerchantItem extends PileItem {
  setupStores(item) {
    super.setupStores(item);
    this.prices = writable({});
    this.displayQuantity = writable(false);
    this.selectedPriceGroup = writable(-1);
    this.quantityToBuy = writable(1);
    this.infiniteQuantity = writable(false);
    this.isService = false;
  }
  setupSubscriptions() {
    let setup = false;
    super.setupSubscriptions();
    this.subscribeTo(this.store.pileData, () => {
      if (!setup)
        return;
      this.refreshPriceData();
      this.refreshDisplayQuantity();
    });
    if (this.store.recipient) {
      this.subscribeTo(this.store.recipientPileData, () => {
        if (!setup)
          return;
        this.refreshPriceData();
        this.refreshDisplayQuantity();
      });
    }
    this.subscribeTo(this.store.priceModifiersPerType, () => {
      if (!setup)
        return;
      this.refreshPriceData();
    });
    this.subscribeTo(this.quantityToBuy, () => {
      if (!setup)
        return;
      this.refreshPriceData();
    });
    this.subscribeTo(this.itemDocument, () => {
      if (!setup)
        return;
      const { data } = this.itemDocument.updateOptions;
      if (hasProperty(data, game.itempiles.API.ITEM_PRICE_ATTRIBUTE)) {
        this.refreshPriceData();
      }
    });
    this.refreshDisplayQuantity();
    this.subscribeTo(this.store.typeFilter, this.filter.bind(this));
    this.subscribeTo(this.itemFlagData, () => {
      if (!setup)
        return;
      this.refreshPriceData();
    });
    setup = true;
  }
  refreshDisplayQuantity() {
    const pileData = get_store_value(this.store.pileData);
    const itemFlagData = get_store_value(this.itemFlagData);
    const merchantDisplayQuantity = pileData.displayQuantity;
    const itemFlagDataQuantity = itemFlagData.displayQuantity;
    if (itemFlagDataQuantity === "always") {
      return this.displayQuantity.set(true);
    }
    const itemDisplayQuantity = {
      "default": merchantDisplayQuantity === "yes",
      "yes": true,
      "no": false
    }[itemFlagDataQuantity ?? "default"];
    if (merchantDisplayQuantity.startsWith("always")) {
      return this.displayQuantity.set(merchantDisplayQuantity.endsWith("yes"));
    }
    this.displayQuantity.set(itemDisplayQuantity);
    this.infiniteQuantity.set(pileData.infiniteQuantity || itemFlagData.infiniteQuantity);
  }
  refreshPriceData() {
    const quantityToBuy = get_store_value(this.quantityToBuy);
    const itemFlagData = get_store_value(this.itemFlagData);
    const sellerFlagData = get_store_value(this.store.pileData);
    const buyerFlagData = get_store_value(this.store.recipientPileData);
    const priceData = getItemPrices(this.item, {
      seller: this.store.actor,
      buyer: this.store.recipient,
      sellerFlagData,
      buyerFlagData,
      itemFlagData,
      quantity: quantityToBuy
    });
    let selectedPriceGroup = get_store_value(this.selectedPriceGroup);
    if (selectedPriceGroup === -1) {
      selectedPriceGroup = Math.max(0, priceData.findIndex((price) => price.maxQuantity));
      this.selectedPriceGroup.set(selectedPriceGroup);
    }
    this.prices.set(priceData);
  }
  filter() {
    const name = get_store_value(this.name).trim();
    const type = get_store_value(this.category).type;
    const search = get_store_value(this.store.search).trim();
    const typeFilter = get_store_value(this.store.typeFilter);
    const searchFiltered = !name.toLowerCase().includes(search.toLowerCase());
    const typeFiltered = typeFilter !== "all" && typeFilter.toLowerCase() !== type.toLowerCase();
    this.filtered.set(searchFiltered || typeFiltered);
  }
  async updateItemFlagData() {
    const itemFlagData = get_store_value(this.itemFlagData);
    await updateItemData(this.item, { flags: itemFlagData });
  }
  updateQuantity(quantity) {
    const pileFlagData = get_store_value(this.store.pileData);
    const itemFlagData = get_store_value(this.itemFlagData);
    const roll = new Roll(quantity).evaluate({ async: false });
    this.quantity.set(roll.total);
    const baseData = {};
    if (itemFlagData.isService || pileFlagData.keepZeroQuantity || itemFlagData.keepZeroQuantity) {
      baseData[CONSTANTS.FLAGS.ITEM + ".notForSale"] = roll.total <= 0;
    }
    return this.item.update(setItemQuantity(baseData, roll.total));
  }
}
__name(PileMerchantItem, "PileMerchantItem");
const MerchantLeftPane_svelte_svelte_type_style_lang = "";
function create_if_block$g(ctx) {
  let tabs_1;
  let updating_activeTab;
  let t0;
  let section;
  let t1;
  let current;
  function tabs_1_activeTab_binding(value) {
    ctx[12](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    style: "flex: 0 1 auto;",
    tabs: ctx[1]
  };
  if (ctx[3] !== void 0) {
    tabs_1_props.activeTab = ctx[3];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind$1(tabs_1, "activeTab", tabs_1_activeTab_binding));
  let if_block0 = ctx[3] === "description" && create_if_block_2$b(ctx);
  let if_block1 = ctx[3] === "settings" && create_if_block_1$b(ctx);
  return {
    c() {
      create_component(tabs_1.$$.fragment);
      t0 = space();
      section = element("section");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(section, "class", "tab-body item-piles-sections svelte-u5hn5y");
      set_style(section, "overflow-y", "auto");
    },
    m(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert(target, t0, anchor);
      insert(target, section, anchor);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t1);
      if (if_block1)
        if_block1.m(section, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & 2)
        tabs_1_changes.tabs = ctx2[1];
      if (!updating_activeTab && dirty & 8) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = ctx2[3];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
      if (ctx2[3] === "description") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$b(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3] === "settings") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$b(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(section);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_if_block$g, "create_if_block$g");
function create_if_block_2$b(ctx) {
  let div;
  let tjsprosemirror;
  let t;
  let current;
  tjsprosemirror = new TJSProseMirror({
    props: {
      content: ctx[2],
      options: { editable: false },
      style: { "display": "block" }
    }
  });
  let if_block = game.user.isGM && !ctx[2] && create_if_block_3$b(ctx);
  return {
    c() {
      div = element("div");
      create_component(tjsprosemirror.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "tab merchant-description svelte-u5hn5y");
      set_style(div, "padding", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tjsprosemirror, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsprosemirror_changes = {};
      if (dirty & 4)
        tjsprosemirror_changes.content = ctx2[2];
      tjsprosemirror.$set(tjsprosemirror_changes);
      if (game.user.isGM && !ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$b(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsprosemirror.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsprosemirror.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tjsprosemirror);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block_2$b, "create_if_block_2$b");
function create_if_block_3$b(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EditDescription")}`;
      attr(button, "type", "button");
      set_style(button, "flex", "1");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$b, "create_if_block_3$b");
function create_if_block_1$b(ctx) {
  let div6;
  let div5;
  let div0;
  let label0;
  let span0;
  let t1;
  let p0;
  let t3;
  let input0;
  let t4;
  let div1;
  let label1;
  let span1;
  let t6;
  let p1;
  let t8;
  let input1;
  let t9;
  let div2;
  let label2;
  let span2;
  let t11;
  let p2;
  let t13;
  let input2;
  let t14;
  let div3;
  let label3;
  let t16;
  let sliderinput0;
  let updating_value;
  let t17;
  let div4;
  let label4;
  let t19;
  let sliderinput1;
  let updating_value_1;
  let t20;
  let button;
  let current;
  let mounted;
  let dispose;
  function sliderinput0_value_binding(value) {
    ctx[17](value);
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  let sliderinput0_props = {};
  if (ctx[4].buyPriceModifier !== void 0) {
    sliderinput0_props.value = ctx[4].buyPriceModifier;
  }
  sliderinput0 = new SliderInput({ props: sliderinput0_props });
  binding_callbacks.push(() => bind$1(sliderinput0, "value", sliderinput0_value_binding));
  function sliderinput1_value_binding(value) {
    ctx[18](value);
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  let sliderinput1_props = { style: "flex:4;" };
  if (ctx[4].sellPriceModifier !== void 0) {
    sliderinput1_props.value = ctx[4].sellPriceModifier;
  }
  sliderinput1 = new SliderInput({ props: sliderinput1_props });
  binding_callbacks.push(() => bind$1(sliderinput1, "value", sliderinput1_value_binding));
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div0 = element("div");
      label0 = element("label");
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Merchant.EditTypePrices")}`;
      t1 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Merchant.EditTypePricesExplanation")}`;
      t3 = space();
      input0 = element("input");
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      span1 = element("span");
      span1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PurchaseOnly")}`;
      t6 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PurchaseOnlyExplanation")}`;
      t8 = space();
      input1 = element("input");
      t9 = space();
      div2 = element("div");
      label2 = element("label");
      span2 = element("span");
      span2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.HideNewItems")}`;
      t11 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.HideNewItemsExplanation")}`;
      t13 = space();
      input2 = element("input");
      t14 = space();
      div3 = element("div");
      label3 = element("label");
      label3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.BuyPriceModifier")}`;
      t16 = space();
      create_component(sliderinput0.$$.fragment);
      t17 = space();
      div4 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.SellPriceModifier")}`;
      t19 = space();
      create_component(sliderinput1.$$.fragment);
      t20 = space();
      button = element("button");
      button.innerHTML = `<i class="fas fa-download"></i> Update`;
      set_style(label0, "flex", "3");
      attr(input0, "type", "checkbox");
      attr(div0, "class", "form-group svelte-u5hn5y");
      set_style(label1, "flex", "3");
      attr(input1, "type", "checkbox");
      attr(div1, "class", "form-group svelte-u5hn5y");
      set_style(label2, "flex", "3");
      attr(input2, "type", "checkbox");
      attr(div2, "class", "form-group svelte-u5hn5y");
      attr(div3, "class", "form-group slider-group item-piles-flexcol svelte-u5hn5y");
      attr(div4, "class", "form-group slider-group item-piles-flexcol svelte-u5hn5y");
      attr(div5, "class", "setting-container item-piles-config-container svelte-u5hn5y");
      attr(button, "type", "button");
      attr(button, "class", "update-button svelte-u5hn5y");
      attr(div6, "class", "tab merchant-settings svelte-u5hn5y");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div0);
      append(div0, label0);
      append(label0, span0);
      append(label0, t1);
      append(label0, p0);
      append(div0, t3);
      append(div0, input0);
      input0.checked = ctx[6];
      append(div5, t4);
      append(div5, div1);
      append(div1, label1);
      append(label1, span1);
      append(label1, t6);
      append(label1, p1);
      append(div1, t8);
      append(div1, input1);
      input1.checked = ctx[4].purchaseOnly;
      append(div5, t9);
      append(div5, div2);
      append(div2, label2);
      append(label2, span2);
      append(label2, t11);
      append(label2, p2);
      append(div2, t13);
      append(div2, input2);
      input2.checked = ctx[4].hideNewItems;
      append(div5, t14);
      append(div5, div3);
      append(div3, label3);
      append(div3, t16);
      mount_component(sliderinput0, div3, null);
      append(div5, t17);
      append(div5, div4);
      append(div4, label4);
      append(div4, t19);
      mount_component(sliderinput1, div4, null);
      append(div6, t20);
      append(div6, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[14]),
          listen(input1, "change", ctx[15]),
          listen(input2, "change", ctx[16]),
          listen(button, "click", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        input0.checked = ctx2[6];
      }
      if (dirty & 16) {
        input1.checked = ctx2[4].purchaseOnly;
      }
      if (dirty & 16) {
        input2.checked = ctx2[4].hideNewItems;
      }
      const sliderinput0_changes = {};
      if (!updating_value && dirty & 16) {
        updating_value = true;
        sliderinput0_changes.value = ctx2[4].buyPriceModifier;
        add_flush_callback(() => updating_value = false);
      }
      sliderinput0.$set(sliderinput0_changes);
      const sliderinput1_changes = {};
      if (!updating_value_1 && dirty & 16) {
        updating_value_1 = true;
        sliderinput1_changes.value = ctx2[4].sellPriceModifier;
        add_flush_callback(() => updating_value_1 = false);
      }
      sliderinput1.$set(sliderinput1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sliderinput0.$$.fragment, local);
      transition_in(sliderinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sliderinput0.$$.fragment, local);
      transition_out(sliderinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(sliderinput0);
      destroy_component(sliderinput1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$b, "create_if_block_1$b");
function create_fragment$j(ctx) {
  let div2;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t;
  let current;
  let if_block = ctx[3] && create_if_block$g(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = ctx[5]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-u5hn5y");
      attr(div0, "class", "merchant-img svelte-u5hn5y");
      attr(div1, "class", "item-piles-bottom-divider");
      attr(div2, "class", "merchant-left-pane item-piles-flexcol svelte-u5hn5y");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, img);
      append(div2, t);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 32 && !src_url_equal(img.src, img_src_value = ctx2[5])) {
        attr(img, "src", img_src_value);
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_fragment$j, "create_fragment$j");
function instance$j($$self, $$props, $$invalidate) {
  let $pileDataStore;
  let $merchantImg;
  let $editPrices;
  let { store } = $$props;
  let { activeTab } = $$props;
  const merchantImg = store.img;
  component_subscribe($$self, merchantImg, (value) => $$invalidate(5, $merchantImg = value));
  const pileDataStore = store.pileData;
  component_subscribe($$self, pileDataStore, (value) => $$invalidate(4, $pileDataStore = value));
  const editPrices = store.editPrices;
  component_subscribe($$self, editPrices, (value) => $$invalidate(6, $editPrices = value));
  let tabs = [];
  let description;
  let activeSidebarTab = false;
  function showDescriptionEditor() {
    return TextEditorDialog.show(description, {
      id: "item-pile-text-editor-" + store.actor.id
    }).then((result) => {
      store.pileData.update((pileData) => {
        pileData.description = result || "";
        return pileData;
      });
      store.update();
    });
  }
  __name(showDescriptionEditor, "showDescriptionEditor");
  function tabs_1_activeTab_binding(value) {
    activeSidebarTab = value;
    $$invalidate(3, activeSidebarTab), $$invalidate(2, description), $$invalidate(1, tabs), $$invalidate(4, $pileDataStore);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    showDescriptionEditor();
  }, "click_handler");
  function input0_change_handler() {
    $editPrices = this.checked;
    editPrices.set($editPrices);
  }
  __name(input0_change_handler, "input0_change_handler");
  function input1_change_handler() {
    $pileDataStore.purchaseOnly = this.checked;
    pileDataStore.set($pileDataStore);
  }
  __name(input1_change_handler, "input1_change_handler");
  function input2_change_handler() {
    $pileDataStore.hideNewItems = this.checked;
    pileDataStore.set($pileDataStore);
  }
  __name(input2_change_handler, "input2_change_handler");
  function sliderinput0_value_binding(value) {
    if ($$self.$$.not_equal($pileDataStore.buyPriceModifier, value)) {
      $pileDataStore.buyPriceModifier = value;
      pileDataStore.set($pileDataStore);
    }
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  function sliderinput1_value_binding(value) {
    if ($$self.$$.not_equal($pileDataStore.sellPriceModifier, value)) {
      $pileDataStore.sellPriceModifier = value;
      pileDataStore.set($pileDataStore);
    }
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    store.update();
  }, "click_handler_1");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
    if ("activeTab" in $$props2)
      $$invalidate(11, activeTab = $$props2.activeTab);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      {
        $$invalidate(2, description = $pileDataStore.description);
      }
    }
    if ($$self.$$.dirty & 14) {
      {
        $$invalidate(1, tabs = [
          {
            value: "description",
            label: `ITEM-PILES.Merchant.Description`,
            hidden: !game.user.isGM && !description
          },
          {
            value: "settings",
            label: `ITEM-PILES.Merchant.Settings`,
            hidden: !game.user.isGM
          }
        ]);
        $$invalidate(3, activeSidebarTab = activeSidebarTab || tabs.find((tab) => !tab.hidden)?.value);
      }
    }
  };
  return [
    store,
    tabs,
    description,
    activeSidebarTab,
    $pileDataStore,
    $merchantImg,
    $editPrices,
    merchantImg,
    pileDataStore,
    editPrices,
    showDescriptionEditor,
    activeTab,
    tabs_1_activeTab_binding,
    click_handler,
    input0_change_handler,
    input1_change_handler,
    input2_change_handler,
    sliderinput0_value_binding,
    sliderinput1_value_binding,
    click_handler_1
  ];
}
__name(instance$j, "instance$j");
class MerchantLeftPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, { store: 0, activeTab: 11 });
  }
}
__name(MerchantLeftPane, "MerchantLeftPane");
const existingStores = /* @__PURE__ */ new Map();
class ItemPriceStore {
  static make(item) {
    if (existingStores.has(item.id)) {
      return existingStores.get(item.id);
    }
    return new this(item);
  }
  constructor(item) {
    this.item = item;
    this.itemDoc = new TJSDocument(this.item);
    this.price = writable(0);
    const data = getItemFlagData(this.item);
    data.prices.forEach((group) => {
      group.forEach((price) => {
        if (!price.id) {
          price.id = randomID();
        }
      });
    });
    this.data = writable(data);
    this.itemDoc.subscribe((item2, changes) => {
      const { data: data2 } = changes;
      if (hasProperty(data2, CONSTANTS.FLAGS.ITEM)) {
        const newData = getProperty(data2, CONSTANTS.FLAGS.ITEM);
        const oldData = get_store_value(this.data);
        this.data.set(foundry.utils.mergeObject(oldData, newData));
      }
      this.price.set(getItemCost(this.item));
    });
  }
  removeGroup(groupIndex) {
    const data = get_store_value(this.data);
    data.prices.splice(groupIndex, 1);
    this.data.set(data);
  }
  export() {
    return {
      data: {
        [game.itempiles.API.ITEM_PRICE_ATTRIBUTE]: get_store_value(this.price)
      },
      flags: get_store_value(this.data)
    };
  }
}
__name(ItemPriceStore, "ItemPriceStore");
function flip(node, { from, to }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from.left + from.width * ox / to.width - (to.left + ox);
  const dy = from.top + from.height * oy / to.height - (to.top + oy);
  const { delay = 0, duration = /* @__PURE__ */ __name((d) => Math.sqrt(d) * 120, "duration"), easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t, u) => {
      const x = u * dx;
      const y = u * dy;
      const sx = t + u * from.width / to.width;
      const sy = t + u * from.height / to.height;
      return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
    }
  };
}
__name(flip, "flip");
const FINALIZE_EVENT_NAME = "finalize";
const CONSIDER_EVENT_NAME = "consider";
function dispatchFinalizeEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(FINALIZE_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
__name(dispatchFinalizeEvent, "dispatchFinalizeEvent");
function dispatchConsiderEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(CONSIDER_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
__name(dispatchConsiderEvent, "dispatchConsiderEvent");
const DRAGGED_ENTERED_EVENT_NAME = "draggedEntered";
const DRAGGED_LEFT_EVENT_NAME = "draggedLeft";
const DRAGGED_OVER_INDEX_EVENT_NAME = "draggedOverIndex";
const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = "draggedLeftDocument";
const DRAGGED_LEFT_TYPES = {
  LEFT_FOR_ANOTHER: "leftForAnother",
  OUTSIDE_OF_ANY: "outsideOfAny"
};
function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
__name(dispatchDraggedElementEnteredContainer, "dispatchDraggedElementEnteredContainer");
function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl2, theOtherDz) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz }
    })
  );
}
__name(dispatchDraggedElementLeftContainerForAnother, "dispatchDraggedElementLeftContainerForAnother");
function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY }
    })
  );
}
__name(dispatchDraggedElementLeftContainerForNone, "dispatchDraggedElementLeftContainerForNone");
function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
__name(dispatchDraggedElementIsOverIndex, "dispatchDraggedElementIsOverIndex");
function dispatchDraggedLeftDocument(draggedEl2) {
  window.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2 }
    })
  );
}
__name(dispatchDraggedLeftDocument, "dispatchDraggedLeftDocument");
const TRIGGERS = {
  DRAG_STARTED: "dragStarted",
  DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,
  DRAGGED_ENTERED_ANOTHER: "dragEnteredAnother",
  DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,
  DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,
  DRAGGED_LEFT_ALL: "draggedLeftAll",
  DROPPED_INTO_ZONE: "droppedIntoZone",
  DROPPED_INTO_ANOTHER: "droppedIntoAnother",
  DROPPED_OUTSIDE_OF_ANY: "droppedOutsideOfAny",
  DRAG_STOPPED: "dragStopped"
};
const SOURCES = {
  POINTER: "pointer",
  KEYBOARD: "keyboard"
};
const SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
const SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
const SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
const DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
let ITEM_ID_KEY = "id";
let activeDndZoneCount = 0;
function incrementActiveDropZoneCount() {
  activeDndZoneCount++;
}
__name(incrementActiveDropZoneCount, "incrementActiveDropZoneCount");
function decrementActiveDropZoneCount() {
  if (activeDndZoneCount === 0) {
    throw new Error("Bug! trying to decrement when there are no dropzones");
  }
  activeDndZoneCount--;
}
__name(decrementActiveDropZoneCount, "decrementActiveDropZoneCount");
const isOnServer = typeof window === "undefined";
function getBoundingRectNoTransforms(el) {
  let ta;
  const rect = el.getBoundingClientRect();
  const style = getComputedStyle(el);
  const tx = style.transform;
  if (tx) {
    let sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return rect;
    }
    const to = style.transformOrigin;
    const x = rect.x - dx - (1 - sx) * parseFloat(to);
    const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w = sx ? rect.width / sx : el.offsetWidth;
    const h = sy ? rect.height / sy : el.offsetHeight;
    return {
      x,
      y,
      width: w,
      height: h,
      top: y,
      right: x + w,
      bottom: y + h,
      left: x
    };
  } else {
    return rect;
  }
}
__name(getBoundingRectNoTransforms, "getBoundingRectNoTransforms");
function getAbsoluteRectNoTransforms(el) {
  const rect = getBoundingRectNoTransforms(el);
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
__name(getAbsoluteRectNoTransforms, "getAbsoluteRectNoTransforms");
function getAbsoluteRect(el) {
  const rect = el.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
__name(getAbsoluteRect, "getAbsoluteRect");
function findCenter(rect) {
  return {
    x: (rect.left + rect.right) / 2,
    y: (rect.top + rect.bottom) / 2
  };
}
__name(findCenter, "findCenter");
function calcDistance(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
}
__name(calcDistance, "calcDistance");
function isPointInsideRect(point, rect) {
  return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;
}
__name(isPointInsideRect, "isPointInsideRect");
function findCenterOfElement(el) {
  return findCenter(getAbsoluteRect(el));
}
__name(findCenterOfElement, "findCenterOfElement");
function isCenterOfAInsideB(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const rectOfB = getAbsoluteRectNoTransforms(elB);
  return isPointInsideRect(centerOfA, rectOfB);
}
__name(isCenterOfAInsideB, "isCenterOfAInsideB");
function calcDistanceBetweenCenters(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const centerOfB = findCenterOfElement(elB);
  return calcDistance(centerOfA, centerOfB);
}
__name(calcDistanceBetweenCenters, "calcDistanceBetweenCenters");
function isElementOffDocument(el) {
  const rect = getAbsoluteRect(el);
  return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
}
__name(isElementOffDocument, "isElementOffDocument");
function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
  const rect = getAbsoluteRect(el);
  if (!isPointInsideRect(point, rect)) {
    return null;
  }
  return {
    top: point.y - rect.top,
    bottom: rect.bottom - point.y,
    left: point.x - rect.left,
    right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
  };
}
__name(calcInnerDistancesBetweenPointAndSidesOfElement, "calcInnerDistancesBetweenPointAndSidesOfElement");
let dzToShadowIndexToRect;
function resetIndexesCache() {
  dzToShadowIndexToRect = /* @__PURE__ */ new Map();
}
__name(resetIndexesCache, "resetIndexesCache");
resetIndexesCache();
function resetIndexesCacheForDz(dz) {
  dzToShadowIndexToRect.delete(dz);
}
__name(resetIndexesCacheForDz, "resetIndexesCacheForDz");
function cacheShadowRect(dz) {
  const shadowElIndex = Array.from(dz.children).findIndex((child) => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));
  if (shadowElIndex >= 0) {
    if (!dzToShadowIndexToRect.has(dz)) {
      dzToShadowIndexToRect.set(dz, /* @__PURE__ */ new Map());
    }
    dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));
    return shadowElIndex;
  }
  return void 0;
}
__name(cacheShadowRect, "cacheShadowRect");
function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
  if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {
    return null;
  }
  const children2 = collectionBelowEl.children;
  if (children2.length === 0) {
    return { index: 0, isProximityBased: true };
  }
  const shadowElIndex = cacheShadowRect(collectionBelowEl);
  for (let i = 0; i < children2.length; i++) {
    if (isCenterOfAInsideB(floatingAboveEl, children2[i])) {
      const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);
      if (cachedShadowRect) {
        if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {
          return { index: shadowElIndex, isProximityBased: false };
        }
      }
      return { index: i, isProximityBased: false };
    }
  }
  let minDistanceSoFar = Number.MAX_VALUE;
  let indexOfMin = void 0;
  for (let i = 0; i < children2.length; i++) {
    const distance = calcDistanceBetweenCenters(floatingAboveEl, children2[i]);
    if (distance < minDistanceSoFar) {
      minDistanceSoFar = distance;
      indexOfMin = i;
    }
  }
  return { index: indexOfMin, isProximityBased: true };
}
__name(findWouldBeIndex, "findWouldBeIndex");
const SCROLL_ZONE_PX = 25;
function makeScroller() {
  let scrollingInfo;
  function resetScrolling2() {
    scrollingInfo = { directionObj: void 0, stepPx: 0 };
  }
  __name(resetScrolling2, "resetScrolling");
  resetScrolling2();
  function scrollContainer(containerEl) {
    const { directionObj, stepPx } = scrollingInfo;
    if (directionObj) {
      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
      window.requestAnimationFrame(() => scrollContainer(containerEl));
    }
  }
  __name(scrollContainer, "scrollContainer");
  function calcScrollStepPx(distancePx) {
    return SCROLL_ZONE_PX - distancePx;
  }
  __name(calcScrollStepPx, "calcScrollStepPx");
  function scrollIfNeeded2(pointer, elementToScroll) {
    if (!elementToScroll) {
      return false;
    }
    const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
    if (distances === null) {
      resetScrolling2();
      return false;
    }
    const isAlreadyScrolling = !!scrollingInfo.directionObj;
    let [scrollingVertically, scrollingHorizontally] = [false, false];
    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
      if (distances.bottom < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: 1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
      } else if (distances.top < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: -1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
      }
      if (!isAlreadyScrolling && scrollingVertically) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
      if (distances.right < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: 1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
      } else if (distances.left < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: -1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
      }
      if (!isAlreadyScrolling && scrollingHorizontally) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    resetScrolling2();
    return false;
  }
  __name(scrollIfNeeded2, "scrollIfNeeded");
  return {
    scrollIfNeeded: scrollIfNeeded2,
    resetScrolling: resetScrolling2
  };
}
__name(makeScroller, "makeScroller");
function toString(object) {
  return JSON.stringify(object, null, 2);
}
__name(toString, "toString");
function getDepth(node) {
  if (!node) {
    throw new Error("cannot get depth of a falsy node");
  }
  return _getDepth(node, 0);
}
__name(getDepth, "getDepth");
function _getDepth(node, countSoFar = 0) {
  if (!node.parentElement) {
    return countSoFar - 1;
  }
  return _getDepth(node.parentElement, countSoFar + 1);
}
__name(_getDepth, "_getDepth");
function areObjectsShallowEqual(objA, objB) {
  if (Object.keys(objA).length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA in objA) {
    if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {
      return false;
    }
  }
  return true;
}
__name(areObjectsShallowEqual, "areObjectsShallowEqual");
function areArraysShallowEqualSameOrder(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }
  return true;
}
__name(areArraysShallowEqualSameOrder, "areArraysShallowEqualSameOrder");
const INTERVAL_MS$1 = 200;
const TOLERANCE_PX = 10;
const { scrollIfNeeded: scrollIfNeeded$1, resetScrolling: resetScrolling$1 } = makeScroller();
let next$1;
function observe(draggedEl2, dropZones, intervalMs = INTERVAL_MS$1) {
  let lastDropZoneFound;
  let lastIndexFound;
  let lastIsDraggedInADropZone = false;
  let lastCentrePositionOfDragged;
  const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));
  function andNow() {
    const currentCenterOfDragged = findCenterOfElement(draggedEl2);
    const scrolled = scrollIfNeeded$1(currentCenterOfDragged, lastDropZoneFound);
    if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
      next$1 = window.setTimeout(andNow, intervalMs);
      return;
    }
    if (isElementOffDocument(draggedEl2)) {
      dispatchDraggedLeftDocument(draggedEl2);
      return;
    }
    lastCentrePositionOfDragged = currentCenterOfDragged;
    let isDraggedInADropZone = false;
    for (const dz of dropZonesFromDeepToShallow) {
      if (scrolled)
        resetIndexesCacheForDz(lastDropZoneFound);
      const indexObj = findWouldBeIndex(draggedEl2, dz);
      if (indexObj === null) {
        continue;
      }
      const { index } = indexObj;
      isDraggedInADropZone = true;
      if (dz !== lastDropZoneFound) {
        lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl2, dz);
        dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl2);
        lastDropZoneFound = dz;
      } else if (index !== lastIndexFound) {
        dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl2);
        lastIndexFound = index;
      }
      break;
    }
    if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {
      dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl2);
      lastDropZoneFound = void 0;
      lastIndexFound = void 0;
      lastIsDraggedInADropZone = false;
    } else {
      lastIsDraggedInADropZone = true;
    }
    next$1 = window.setTimeout(andNow, intervalMs);
  }
  __name(andNow, "andNow");
  andNow();
}
__name(observe, "observe");
function unobserve() {
  clearTimeout(next$1);
  resetScrolling$1();
  resetIndexesCache();
}
__name(unobserve, "unobserve");
const INTERVAL_MS = 300;
let mousePosition;
function updateMousePosition(e) {
  const c = e.touches ? e.touches[0] : e;
  mousePosition = { x: c.clientX, y: c.clientY };
}
__name(updateMousePosition, "updateMousePosition");
const { scrollIfNeeded, resetScrolling } = makeScroller();
let next;
function loop() {
  if (mousePosition) {
    const scrolled = scrollIfNeeded(mousePosition, document.documentElement);
    if (scrolled)
      resetIndexesCache();
  }
  next = window.setTimeout(loop, INTERVAL_MS);
}
__name(loop, "loop");
function armWindowScroller() {
  window.addEventListener("mousemove", updateMousePosition);
  window.addEventListener("touchmove", updateMousePosition);
  loop();
}
__name(armWindowScroller, "armWindowScroller");
function disarmWindowScroller() {
  window.removeEventListener("mousemove", updateMousePosition);
  window.removeEventListener("touchmove", updateMousePosition);
  mousePosition = void 0;
  window.clearTimeout(next);
  resetScrolling();
}
__name(disarmWindowScroller, "disarmWindowScroller");
function svelteNodeClone(el) {
  const cloned = el.cloneNode(true);
  const values = [];
  const elIsSelect = el.tagName === "SELECT";
  const selects = elIsSelect ? [el] : [...el.querySelectorAll("select")];
  for (const select of selects) {
    values.push(select.value);
  }
  if (selects.length <= 0) {
    return cloned;
  }
  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll("select")];
  for (let i = 0; i < clonedSelects.length; i++) {
    const select = clonedSelects[i];
    const value = values[i];
    const optionEl = select.querySelector(`option[value="${value}"`);
    if (optionEl) {
      optionEl.setAttribute("selected", true);
    }
  }
  return cloned;
}
__name(svelteNodeClone, "svelteNodeClone");
const TRANSITION_DURATION_SECONDS = 0.2;
function trs(property) {
  return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;
}
__name(trs, "trs");
function createDraggedElementFrom(originalElement, positionCenterOnXY) {
  const rect = originalElement.getBoundingClientRect();
  const draggedEl2 = svelteNodeClone(originalElement);
  copyStylesFromTo(originalElement, draggedEl2);
  draggedEl2.id = DRAGGED_ELEMENT_ID;
  draggedEl2.style.position = "fixed";
  let elTopPx = rect.top;
  let elLeftPx = rect.left;
  draggedEl2.style.top = `${elTopPx}px`;
  draggedEl2.style.left = `${elLeftPx}px`;
  if (positionCenterOnXY) {
    const center = findCenter(rect);
    elTopPx -= center.y - positionCenterOnXY.y;
    elLeftPx -= center.x - positionCenterOnXY.x;
    window.setTimeout(() => {
      draggedEl2.style.top = `${elTopPx}px`;
      draggedEl2.style.left = `${elLeftPx}px`;
    }, 0);
  }
  draggedEl2.style.margin = "0";
  draggedEl2.style.boxSizing = "border-box";
  draggedEl2.style.height = `${rect.height}px`;
  draggedEl2.style.width = `${rect.width}px`;
  draggedEl2.style.transition = `${trs("top")}, ${trs("left")}, ${trs("background-color")}, ${trs("opacity")}, ${trs("color")} `;
  window.setTimeout(() => draggedEl2.style.transition += `, ${trs("width")}, ${trs("height")}`, 0);
  draggedEl2.style.zIndex = "9999";
  draggedEl2.style.cursor = "grabbing";
  return draggedEl2;
}
__name(createDraggedElementFrom, "createDraggedElementFrom");
function moveDraggedElementToWasDroppedState(draggedEl2) {
  draggedEl2.style.cursor = "grab";
}
__name(moveDraggedElementToWasDroppedState, "moveDraggedElementToWasDroppedState");
function morphDraggedElementToBeLike(draggedEl2, copyFromEl, currentMouseX, currentMouseY) {
  copyStylesFromTo(copyFromEl, draggedEl2);
  const newRect = copyFromEl.getBoundingClientRect();
  const draggedElRect = draggedEl2.getBoundingClientRect();
  const widthChange = newRect.width - draggedElRect.width;
  const heightChange = newRect.height - draggedElRect.height;
  if (widthChange || heightChange) {
    const relativeDistanceOfMousePointerFromDraggedSides = {
      left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
      top: (currentMouseY - draggedElRect.top) / draggedElRect.height
    };
    draggedEl2.style.height = `${newRect.height}px`;
    draggedEl2.style.width = `${newRect.width}px`;
    draggedEl2.style.left = `${parseFloat(draggedEl2.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;
    draggedEl2.style.top = `${parseFloat(draggedEl2.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;
  }
}
__name(morphDraggedElementToBeLike, "morphDraggedElementToBeLike");
function copyStylesFromTo(copyFromEl, copyToEl) {
  const computedStyle = window.getComputedStyle(copyFromEl);
  Array.from(computedStyle).filter(
    (s) => s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type"
  ).forEach((s) => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));
}
__name(copyStylesFromTo, "copyStylesFromTo");
function styleDraggable(draggableEl, dragDisabled) {
  draggableEl.draggable = false;
  draggableEl.ondragstart = () => false;
  if (!dragDisabled) {
    draggableEl.style.userSelect = "none";
    draggableEl.style.WebkitUserSelect = "none";
    draggableEl.style.cursor = "grab";
  } else {
    draggableEl.style.userSelect = "";
    draggableEl.style.WebkitUserSelect = "";
    draggableEl.style.cursor = "";
  }
}
__name(styleDraggable, "styleDraggable");
function hideElement(dragTarget) {
  dragTarget.style.display = "none";
  dragTarget.style.position = "fixed";
  dragTarget.style.zIndex = "-5";
}
__name(hideElement, "hideElement");
function decorateShadowEl(shadowEl) {
  shadowEl.style.visibility = "hidden";
  shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, "true");
}
__name(decorateShadowEl, "decorateShadowEl");
function unDecorateShadowElement(shadowEl) {
  shadowEl.style.visibility = "";
  shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
}
__name(unDecorateShadowElement, "unDecorateShadowElement");
function styleActiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles2 = getStyles(dz);
    Object.keys(styles2).forEach((style) => {
      dz.style[style] = styles2[style];
    });
    getClasses(dz).forEach((c) => dz.classList.add(c));
  });
}
__name(styleActiveDropZones, "styleActiveDropZones");
function styleInactiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles2 = getStyles(dz);
    Object.keys(styles2).forEach((style) => {
      dz.style[style] = "";
    });
    getClasses(dz).forEach((c) => dz.classList.contains(c) && dz.classList.remove(c));
  });
}
__name(styleInactiveDropZones, "styleInactiveDropZones");
function preventShrinking(el) {
  const originalMinHeight = el.style.minHeight;
  el.style.minHeight = window.getComputedStyle(el).getPropertyValue("height");
  const originalMinWidth = el.style.minWidth;
  el.style.minWidth = window.getComputedStyle(el).getPropertyValue("width");
  return /* @__PURE__ */ __name(function undo() {
    el.style.minHeight = originalMinHeight;
    el.style.minWidth = originalMinWidth;
  }, "undo");
}
__name(preventShrinking, "preventShrinking");
const DEFAULT_DROP_ZONE_TYPE$1 = "--any--";
const MIN_OBSERVATION_INTERVAL_MS = 100;
const MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
const DEFAULT_DROP_TARGET_STYLE$1 = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
let originalDragTarget;
let draggedEl;
let draggedElData;
let draggedElType;
let originDropZone;
let originIndex;
let shadowElData;
let shadowElDropZone;
let dragStartMousePosition;
let currentMousePosition;
let isWorkingOnPreviousDrag = false;
let finalizingPreviousDrag = false;
let unlockOriginDzMinDimensions;
let isDraggedOutsideOfAnyDz = false;
let scheduledForRemovalAfterDrop = [];
const typeToDropZones$1 = /* @__PURE__ */ new Map();
const dzToConfig$1 = /* @__PURE__ */ new Map();
const elToMouseDownListener = /* @__PURE__ */ new WeakMap();
function registerDropZone$1(dropZoneEl, type) {
  if (!typeToDropZones$1.has(type)) {
    typeToDropZones$1.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones$1.get(type).has(dropZoneEl)) {
    typeToDropZones$1.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
__name(registerDropZone$1, "registerDropZone$1");
function unregisterDropZone$1(dropZoneEl, type) {
  typeToDropZones$1.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones$1.get(type).size === 0) {
    typeToDropZones$1.delete(type);
  }
}
__name(unregisterDropZone$1, "unregisterDropZone$1");
function watchDraggedElement() {
  armWindowScroller();
  const dropZones = typeToDropZones$1.get(draggedElType);
  for (const dz of dropZones) {
    dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
  const observationIntervalMs = Math.max(
    MIN_OBSERVATION_INTERVAL_MS,
    ...Array.from(dropZones.keys()).map((dz) => dzToConfig$1.get(dz).dropAnimationDurationMs)
  );
  observe(draggedEl, dropZones, observationIntervalMs * 1.07);
}
__name(watchDraggedElement, "watchDraggedElement");
function unWatchDraggedElement() {
  disarmWindowScroller();
  const dropZones = typeToDropZones$1.get(draggedElType);
  for (const dz of dropZones) {
    dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop$1);
  unobserve();
}
__name(unWatchDraggedElement, "unWatchDraggedElement");
function findShadowPlaceHolderIdx(items) {
  return items.findIndex((item) => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);
}
__name(findShadowPlaceHolderIdx, "findShadowPlaceHolderIdx");
function findShadowElementIdx(items) {
  return items.findIndex((item) => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);
}
__name(findShadowElementIdx, "findShadowElementIdx");
function handleDraggedEntered(e) {
  let { items, dropFromOthersDisabled } = dzToConfig$1.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  items = items.filter((item) => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);
  if (originDropZone !== e.currentTarget) {
    const originZoneItems = dzToConfig$1.get(originDropZone).items;
    const newOriginZoneItems = originZoneItems.filter((item) => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);
    dispatchConsiderEvent(originDropZone, newOriginZoneItems, {
      trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  } else {
    const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
    if (shadowPlaceHolderIdx !== -1) {
      items.splice(shadowPlaceHolderIdx, 1);
    }
  }
  const { index, isProximityBased } = e.detail.indexObj;
  const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
  shadowElDropZone = e.currentTarget;
  items.splice(shadowElIdx, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
__name(handleDraggedEntered, "handleDraggedEntered");
function handleDraggedLeft(e) {
  if (!isWorkingOnPreviousDrag)
    return;
  const { items, dropFromOthersDisabled } = dzToConfig$1.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
    return;
  }
  const shadowElIdx = findShadowElementIdx(items);
  const shadowItem = items.splice(shadowElIdx, 1)[0];
  shadowElDropZone = void 0;
  const { type, theOtherDz } = e.detail;
  if (type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY || type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig$1.get(theOtherDz).dropFromOthersDisabled) {
    isDraggedOutsideOfAnyDz = true;
    shadowElDropZone = originDropZone;
    const originZoneItems = dzToConfig$1.get(originDropZone).items;
    originZoneItems.splice(originIndex, 0, shadowItem);
    dispatchConsiderEvent(originDropZone, originZoneItems, {
      trigger: TRIGGERS.DRAGGED_LEFT_ALL,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  }
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_LEFT,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
__name(handleDraggedLeft, "handleDraggedLeft");
function handleDraggedIsOverIndex(e) {
  const { items, dropFromOthersDisabled } = dzToConfig$1.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  const { index } = e.detail.indexObj;
  const shadowElIdx = findShadowElementIdx(items);
  items.splice(shadowElIdx, 1);
  items.splice(index, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
__name(handleDraggedIsOverIndex, "handleDraggedIsOverIndex");
function handleMouseMove(e) {
  e.preventDefault();
  const c = e.touches ? e.touches[0] : e;
  currentMousePosition = { x: c.clientX, y: c.clientY };
  draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${currentMousePosition.y - dragStartMousePosition.y}px, 0)`;
}
__name(handleMouseMove, "handleMouseMove");
function handleDrop$1() {
  finalizingPreviousDrag = true;
  window.removeEventListener("mousemove", handleMouseMove);
  window.removeEventListener("touchmove", handleMouseMove);
  window.removeEventListener("mouseup", handleDrop$1);
  window.removeEventListener("touchend", handleDrop$1);
  unWatchDraggedElement();
  moveDraggedElementToWasDroppedState(draggedEl);
  if (!shadowElDropZone) {
    shadowElDropZone = originDropZone;
  }
  let { items, type } = dzToConfig$1.get(shadowElDropZone);
  styleInactiveDropZones(
    typeToDropZones$1.get(type),
    (dz) => dzToConfig$1.get(dz).dropTargetStyle,
    (dz) => dzToConfig$1.get(dz).dropTargetClasses
  );
  let shadowElIdx = findShadowElementIdx(items);
  if (shadowElIdx === -1)
    shadowElIdx = originIndex;
  items = items.map((item) => item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item);
  function finalizeWithinZone() {
    unlockOriginDzMinDimensions();
    dispatchFinalizeEvent(shadowElDropZone, items, {
      trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
    if (shadowElDropZone !== originDropZone) {
      dispatchFinalizeEvent(originDropZone, dzToConfig$1.get(originDropZone).items, {
        trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
        id: draggedElData[ITEM_ID_KEY],
        source: SOURCES.POINTER
      });
    }
    unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
    cleanupPostDrop();
  }
  __name(finalizeWithinZone, "finalizeWithinZone");
  animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
}
__name(handleDrop$1, "handleDrop$1");
function animateDraggedToFinalPosition(shadowElIdx, callback) {
  const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
  const newTransform = {
    x: shadowElRect.left - parseFloat(draggedEl.style.left),
    y: shadowElRect.top - parseFloat(draggedEl.style.top)
  };
  const { dropAnimationDurationMs } = dzToConfig$1.get(shadowElDropZone);
  const transition = `transform ${dropAnimationDurationMs}ms ease`;
  draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
  draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;
  window.setTimeout(callback, dropAnimationDurationMs);
}
__name(animateDraggedToFinalPosition, "animateDraggedToFinalPosition");
function scheduleDZForRemovalAfterDrop(dz, destroy) {
  scheduledForRemovalAfterDrop.push({ dz, destroy });
  window.requestAnimationFrame(() => {
    hideElement(dz);
    document.body.appendChild(dz);
  });
}
__name(scheduleDZForRemovalAfterDrop, "scheduleDZForRemovalAfterDrop");
function cleanupPostDrop() {
  draggedEl.remove();
  originalDragTarget.remove();
  if (scheduledForRemovalAfterDrop.length) {
    scheduledForRemovalAfterDrop.forEach(({ dz, destroy }) => {
      destroy();
      dz.remove();
    });
    scheduledForRemovalAfterDrop = [];
  }
  draggedEl = void 0;
  originalDragTarget = void 0;
  draggedElData = void 0;
  draggedElType = void 0;
  originDropZone = void 0;
  originIndex = void 0;
  shadowElData = void 0;
  shadowElDropZone = void 0;
  dragStartMousePosition = void 0;
  currentMousePosition = void 0;
  isWorkingOnPreviousDrag = false;
  finalizingPreviousDrag = false;
  unlockOriginDzMinDimensions = void 0;
  isDraggedOutsideOfAnyDz = false;
}
__name(cleanupPostDrop, "cleanupPostDrop");
function dndzone$2(node, options) {
  let initialized = false;
  const config = {
    items: void 0,
    type: void 0,
    flipDurationMs: 0,
    dragDisabled: false,
    morphDisabled: false,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE$1,
    dropTargetClasses: [],
    transformDraggedElement: () => {
    },
    centreDraggedOnCursor: false
  };
  let elToIdx = /* @__PURE__ */ new Map();
  function addMaybeListeners() {
    window.addEventListener("mousemove", handleMouseMoveMaybeDragStart, { passive: false });
    window.addEventListener("touchmove", handleMouseMoveMaybeDragStart, { passive: false, capture: false });
    window.addEventListener("mouseup", handleFalseAlarm, { passive: false });
    window.addEventListener("touchend", handleFalseAlarm, { passive: false });
  }
  __name(addMaybeListeners, "addMaybeListeners");
  function removeMaybeListeners() {
    window.removeEventListener("mousemove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("mouseup", handleFalseAlarm);
    window.removeEventListener("touchend", handleFalseAlarm);
  }
  __name(removeMaybeListeners, "removeMaybeListeners");
  function handleFalseAlarm() {
    removeMaybeListeners();
    originalDragTarget = void 0;
    dragStartMousePosition = void 0;
    currentMousePosition = void 0;
  }
  __name(handleFalseAlarm, "handleFalseAlarm");
  function handleMouseMoveMaybeDragStart(e) {
    e.preventDefault();
    const c = e.touches ? e.touches[0] : e;
    currentMousePosition = { x: c.clientX, y: c.clientY };
    if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
      removeMaybeListeners();
      handleDragStart();
    }
  }
  __name(handleMouseMoveMaybeDragStart, "handleMouseMoveMaybeDragStart");
  function handleMouseDown(e) {
    if (e.target !== e.currentTarget && (e.target.value !== void 0 || e.target.isContentEditable)) {
      return;
    }
    if (e.button) {
      return;
    }
    if (isWorkingOnPreviousDrag) {
      return;
    }
    e.stopPropagation();
    const c = e.touches ? e.touches[0] : e;
    dragStartMousePosition = { x: c.clientX, y: c.clientY };
    currentMousePosition = { ...dragStartMousePosition };
    originalDragTarget = e.currentTarget;
    addMaybeListeners();
  }
  __name(handleMouseDown, "handleMouseDown");
  function handleDragStart() {
    isWorkingOnPreviousDrag = true;
    const currentIdx = elToIdx.get(originalDragTarget);
    originIndex = currentIdx;
    originDropZone = originalDragTarget.parentElement;
    const rootNode = originDropZone.getRootNode();
    const originDropZoneRoot = rootNode.body || rootNode;
    const { items, type, centreDraggedOnCursor } = config;
    draggedElData = { ...items[currentIdx] };
    draggedElType = type;
    shadowElData = { ...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true };
    const placeHolderElData = { ...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID };
    draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
    function keepOriginalElementInDom() {
      if (!draggedEl.parentElement) {
        originDropZoneRoot.appendChild(draggedEl);
        draggedEl.focus();
        watchDraggedElement();
        hideElement(originalDragTarget);
        originDropZoneRoot.appendChild(originalDragTarget);
      } else {
        window.requestAnimationFrame(keepOriginalElementInDom);
      }
    }
    __name(keepOriginalElementInDom, "keepOriginalElementInDom");
    window.requestAnimationFrame(keepOriginalElementInDom);
    styleActiveDropZones(
      Array.from(typeToDropZones$1.get(config.type)).filter((dz) => dz === originDropZone || !dzToConfig$1.get(dz).dropFromOthersDisabled),
      (dz) => dzToConfig$1.get(dz).dropTargetStyle,
      (dz) => dzToConfig$1.get(dz).dropTargetClasses
    );
    items.splice(currentIdx, 1, placeHolderElData);
    unlockOriginDzMinDimensions = preventShrinking(originDropZone);
    dispatchConsiderEvent(originDropZone, items, { trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
    window.addEventListener("mousemove", handleMouseMove, { passive: false });
    window.addEventListener("touchmove", handleMouseMove, { passive: false, capture: false });
    window.addEventListener("mouseup", handleDrop$1, { passive: false });
    window.addEventListener("touchend", handleDrop$1, { passive: false });
  }
  __name(handleDragStart, "handleDragStart");
  function configure({
    items = void 0,
    flipDurationMs: dropAnimationDurationMs = 0,
    type: newType = DEFAULT_DROP_ZONE_TYPE$1,
    dragDisabled = false,
    morphDisabled = false,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE$1,
    dropTargetClasses = [],
    transformDraggedElement = /* @__PURE__ */ __name(() => {
    }, "transformDraggedElement"),
    centreDraggedOnCursor = false
  }) {
    config.dropAnimationDurationMs = dropAnimationDurationMs;
    if (config.type && newType !== config.type) {
      unregisterDropZone$1(node, config.type);
    }
    config.type = newType;
    registerDropZone$1(node, newType);
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.morphDisabled = morphDisabled;
    config.transformDraggedElement = transformDraggedElement;
    config.centreDraggedOnCursor = centreDraggedOnCursor;
    if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
      styleInactiveDropZones(
        [node],
        () => config.dropTargetStyle,
        () => dropTargetClasses
      );
      styleActiveDropZones(
        [node],
        () => dropTargetStyle,
        () => dropTargetClasses
      );
    }
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = [...dropTargetClasses];
    function getConfigProp(dz, propName) {
      return dzToConfig$1.get(dz) ? dzToConfig$1.get(dz)[propName] : config[propName];
    }
    __name(getConfigProp, "getConfigProp");
    if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {
      if (dropFromOthersDisabled) {
        styleInactiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      } else {
        styleActiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      }
    }
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    dzToConfig$1.set(node, config);
    const shadowElIdx = findShadowElementIdx(config.items);
    for (let idx = 0; idx < node.children.length; idx++) {
      const draggableEl = node.children[idx];
      styleDraggable(draggableEl, dragDisabled);
      if (idx === shadowElIdx) {
        config.transformDraggedElement(draggedEl, draggedElData, idx);
        if (!morphDisabled) {
          morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
        }
        decorateShadowEl(draggableEl);
        continue;
      }
      draggableEl.removeEventListener("mousedown", elToMouseDownListener.get(draggableEl));
      draggableEl.removeEventListener("touchstart", elToMouseDownListener.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("mousedown", handleMouseDown);
        draggableEl.addEventListener("touchstart", handleMouseDown);
        elToMouseDownListener.set(draggableEl, handleMouseDown);
      }
      elToIdx.set(draggableEl, idx);
      if (!initialized) {
        initialized = true;
      }
    }
  }
  __name(configure, "configure");
  configure(options);
  return {
    update: (newOptions) => {
      configure(newOptions);
    },
    destroy: () => {
      function destroyDz() {
        unregisterDropZone$1(node, dzToConfig$1.get(node).type);
        dzToConfig$1.delete(node);
      }
      __name(destroyDz, "destroyDz");
      if (isWorkingOnPreviousDrag) {
        scheduleDZForRemovalAfterDrop(node, destroyDz);
      } else {
        destroyDz();
      }
    }
  };
}
__name(dndzone$2, "dndzone$2");
const INSTRUCTION_IDs$1 = {
  DND_ZONE_ACTIVE: "dnd-zone-active",
  DND_ZONE_DRAG_DISABLED: "dnd-zone-drag-disabled"
};
const ID_TO_INSTRUCTION = {
  [INSTRUCTION_IDs$1.DND_ZONE_ACTIVE]: "Tab to one the items and press space-bar or enter to start dragging it",
  [INSTRUCTION_IDs$1.DND_ZONE_DRAG_DISABLED]: "This is a disabled drag and drop list"
};
const ALERT_DIV_ID = "dnd-action-aria-alert";
let alertsDiv;
function initAriaOnBrowser() {
  if (alertsDiv) {
    return;
  }
  alertsDiv = document.createElement("div");
  (/* @__PURE__ */ __name(function initAlertsDiv() {
    alertsDiv.id = ALERT_DIV_ID;
    alertsDiv.style.position = "fixed";
    alertsDiv.style.bottom = "0";
    alertsDiv.style.left = "0";
    alertsDiv.style.zIndex = "-5";
    alertsDiv.style.opacity = "0";
    alertsDiv.style.height = "0";
    alertsDiv.style.width = "0";
    alertsDiv.setAttribute("role", "alert");
  }, "initAlertsDiv"))();
  document.body.prepend(alertsDiv);
  Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));
}
__name(initAriaOnBrowser, "initAriaOnBrowser");
function initAria() {
  if (isOnServer)
    return null;
  if (document.readyState === "complete") {
    initAriaOnBrowser();
  } else {
    window.addEventListener("DOMContentLoaded", initAriaOnBrowser);
  }
  return { ...INSTRUCTION_IDs$1 };
}
__name(initAria, "initAria");
function destroyAria() {
  if (isOnServer || !alertsDiv)
    return;
  Object.keys(ID_TO_INSTRUCTION).forEach((id) => document.getElementById(id)?.remove());
  alertsDiv.remove();
  alertsDiv = void 0;
}
__name(destroyAria, "destroyAria");
function instructionToHiddenDiv(id, txt) {
  const div = document.createElement("div");
  div.id = id;
  div.innerHTML = `<p>${txt}</p>`;
  div.style.display = "none";
  div.style.position = "fixed";
  div.style.zIndex = "-5";
  return div;
}
__name(instructionToHiddenDiv, "instructionToHiddenDiv");
function alertToScreenReader(txt) {
  if (isOnServer)
    return;
  if (!alertsDiv) {
    initAriaOnBrowser();
  }
  alertsDiv.innerHTML = "";
  const alertText = document.createTextNode(txt);
  alertsDiv.appendChild(alertText);
  alertsDiv.style.display = "none";
  alertsDiv.style.display = "inline";
}
__name(alertToScreenReader, "alertToScreenReader");
const DEFAULT_DROP_ZONE_TYPE = "--any--";
const DEFAULT_DROP_TARGET_STYLE = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
let isDragging = false;
let draggedItemType;
let focusedDz;
let focusedDzLabel = "";
let focusedItem;
let focusedItemId;
let focusedItemLabel = "";
const allDragTargets = /* @__PURE__ */ new WeakSet();
const elToKeyDownListeners = /* @__PURE__ */ new WeakMap();
const elToFocusListeners = /* @__PURE__ */ new WeakMap();
const dzToHandles = /* @__PURE__ */ new Map();
const dzToConfig = /* @__PURE__ */ new Map();
const typeToDropZones = /* @__PURE__ */ new Map();
let INSTRUCTION_IDs;
function registerDropZone(dropZoneEl, type) {
  if (typeToDropZones.size === 0) {
    INSTRUCTION_IDs = initAria();
    window.addEventListener("keydown", globalKeyDownHandler);
    window.addEventListener("click", globalClickHandler);
  }
  if (!typeToDropZones.has(type)) {
    typeToDropZones.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones.get(type).has(dropZoneEl)) {
    typeToDropZones.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
__name(registerDropZone, "registerDropZone");
function unregisterDropZone(dropZoneEl, type) {
  if (focusedDz === dropZoneEl) {
    handleDrop();
  }
  typeToDropZones.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones.get(type).size === 0) {
    typeToDropZones.delete(type);
  }
  if (typeToDropZones.size === 0) {
    window.removeEventListener("keydown", globalKeyDownHandler);
    window.removeEventListener("click", globalClickHandler);
    INSTRUCTION_IDs = void 0;
    destroyAria();
  }
}
__name(unregisterDropZone, "unregisterDropZone");
function globalKeyDownHandler(e) {
  if (!isDragging)
    return;
  switch (e.key) {
    case "Escape": {
      handleDrop();
      break;
    }
  }
}
__name(globalKeyDownHandler, "globalKeyDownHandler");
function globalClickHandler() {
  if (!isDragging)
    return;
  if (!allDragTargets.has(document.activeElement)) {
    handleDrop();
  }
}
__name(globalClickHandler, "globalClickHandler");
function handleZoneFocus(e) {
  if (!isDragging)
    return;
  const newlyFocusedDz = e.currentTarget;
  if (newlyFocusedDz === focusedDz)
    return;
  focusedDzLabel = newlyFocusedDz.getAttribute("aria-label") || "";
  const { items: originItems } = dzToConfig.get(focusedDz);
  const originItem = originItems.find((item) => item[ITEM_ID_KEY] === focusedItemId);
  const originIdx = originItems.indexOf(originItem);
  const itemToMove = originItems.splice(originIdx, 1)[0];
  const { items: targetItems, autoAriaDisabled } = dzToConfig.get(newlyFocusedDz);
  if (newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top || newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left) {
    targetItems.push(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);
    }
  } else {
    targetItems.unshift(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);
    }
  }
  const dzFrom = focusedDz;
  dispatchFinalizeEvent(dzFrom, originItems, { trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD });
  dispatchFinalizeEvent(newlyFocusedDz, targetItems, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
  focusedDz = newlyFocusedDz;
}
__name(handleZoneFocus, "handleZoneFocus");
function triggerAllDzsUpdate() {
  dzToHandles.forEach(({ update: update2 }, dz) => update2(dzToConfig.get(dz)));
}
__name(triggerAllDzsUpdate, "triggerAllDzsUpdate");
function handleDrop(dispatchConsider = true) {
  if (!dzToConfig.get(focusedDz).autoAriaDisabled) {
    alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);
  }
  if (allDragTargets.has(document.activeElement)) {
    document.activeElement.blur();
  }
  if (dispatchConsider) {
    dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {
      trigger: TRIGGERS.DRAG_STOPPED,
      id: focusedItemId,
      source: SOURCES.KEYBOARD
    });
  }
  styleInactiveDropZones(
    typeToDropZones.get(draggedItemType),
    (dz) => dzToConfig.get(dz).dropTargetStyle,
    (dz) => dzToConfig.get(dz).dropTargetClasses
  );
  focusedItem = null;
  focusedItemId = null;
  focusedItemLabel = "";
  draggedItemType = null;
  focusedDz = null;
  focusedDzLabel = "";
  isDragging = false;
  triggerAllDzsUpdate();
}
__name(handleDrop, "handleDrop");
function dndzone$1(node, options) {
  const config = {
    items: void 0,
    type: void 0,
    dragDisabled: false,
    zoneTabIndex: 0,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses: [],
    autoAriaDisabled: false
  };
  function swap(arr, i, j) {
    if (arr.length <= 1)
      return;
    arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);
  }
  __name(swap, "swap");
  function handleKeyDown(e) {
    switch (e.key) {
      case "Enter":
      case " ": {
        if ((e.target.disabled !== void 0 || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (isDragging) {
          handleDrop();
        } else {
          handleDragStart(e);
        }
        break;
      }
      case "ArrowDown":
      case "ArrowRight": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        if (idx < children2.length - 1) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx + 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
      case "ArrowUp":
      case "ArrowLeft": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        if (idx > 0) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx - 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleDragStart(e) {
    setCurrentFocusedItem(e.currentTarget);
    focusedDz = node;
    draggedItemType = config.type;
    isDragging = true;
    const dropTargets = Array.from(typeToDropZones.get(config.type)).filter((dz) => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);
    styleActiveDropZones(
      dropTargets,
      (dz) => dzToConfig.get(dz).dropTargetStyle,
      (dz) => dzToConfig.get(dz).dropTargetClasses
    );
    if (!config.autoAriaDisabled) {
      let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;
      if (dropTargets.length > 1) {
        msg += `, or tab to another list in order to move the item into it`;
      }
      alertToScreenReader(msg);
    }
    dispatchConsiderEvent(node, dzToConfig.get(node).items, { trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD });
    triggerAllDzsUpdate();
  }
  __name(handleDragStart, "handleDragStart");
  function handleClick(e) {
    if (!isDragging)
      return;
    if (e.currentTarget === focusedItem)
      return;
    e.stopPropagation();
    handleDrop(false);
    handleDragStart(e);
  }
  __name(handleClick, "handleClick");
  function setCurrentFocusedItem(draggableEl) {
    const { items } = dzToConfig.get(node);
    const children2 = Array.from(node.children);
    const focusedItemIdx = children2.indexOf(draggableEl);
    focusedItem = draggableEl;
    focusedItem.tabIndex = 0;
    focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
    focusedItemLabel = children2[focusedItemIdx].getAttribute("aria-label") || "";
  }
  __name(setCurrentFocusedItem, "setCurrentFocusedItem");
  function configure({
    items = [],
    type: newType = DEFAULT_DROP_ZONE_TYPE,
    dragDisabled = false,
    zoneTabIndex = 0,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses = [],
    autoAriaDisabled = false
  }) {
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    config.zoneTabIndex = zoneTabIndex;
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = dropTargetClasses;
    config.autoAriaDisabled = autoAriaDisabled;
    if (config.type && newType !== config.type) {
      unregisterDropZone(node, config.type);
    }
    config.type = newType;
    registerDropZone(node, newType);
    if (!autoAriaDisabled) {
      node.setAttribute("aria-disabled", dragDisabled);
      node.setAttribute("role", "list");
      node.setAttribute("aria-describedby", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);
    }
    dzToConfig.set(node, config);
    if (isDragging) {
      node.tabIndex = node === focusedDz || focusedItem.contains(node) || config.dropFromOthersDisabled || focusedDz && config.type !== dzToConfig.get(focusedDz).type ? -1 : 0;
    } else {
      node.tabIndex = config.zoneTabIndex;
    }
    node.addEventListener("focus", handleZoneFocus);
    for (let i = 0; i < node.children.length; i++) {
      const draggableEl = node.children[i];
      allDragTargets.add(draggableEl);
      draggableEl.tabIndex = isDragging ? -1 : 0;
      if (!autoAriaDisabled) {
        draggableEl.setAttribute("role", "listitem");
      }
      draggableEl.removeEventListener("keydown", elToKeyDownListeners.get(draggableEl));
      draggableEl.removeEventListener("click", elToFocusListeners.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("keydown", handleKeyDown);
        elToKeyDownListeners.set(draggableEl, handleKeyDown);
        draggableEl.addEventListener("click", handleClick);
        elToFocusListeners.set(draggableEl, handleClick);
      }
      if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {
        focusedItem = draggableEl;
        focusedItem.tabIndex = 0;
        draggableEl.focus();
      }
    }
  }
  __name(configure, "configure");
  configure(options);
  const handles = {
    update: (newOptions) => {
      configure(newOptions);
    },
    destroy: () => {
      unregisterDropZone(node, config.type);
      dzToConfig.delete(node);
      dzToHandles.delete(node);
    }
  };
  dzToHandles.set(node, handles);
  return handles;
}
__name(dndzone$1, "dndzone$1");
function dndzone(node, options) {
  validateOptions(options);
  const pointerZone = dndzone$2(node, options);
  const keyboardZone = dndzone$1(node, options);
  return {
    update: (newOptions) => {
      validateOptions(newOptions);
      pointerZone.update(newOptions);
      keyboardZone.update(newOptions);
    },
    destroy: () => {
      pointerZone.destroy();
      keyboardZone.destroy();
    }
  };
}
__name(dndzone, "dndzone");
function validateOptions(options) {
  const {
    items,
    flipDurationMs: flipDurationMs2,
    type,
    dragDisabled,
    morphDisabled,
    dropFromOthersDisabled,
    zoneTabIndex,
    dropTargetStyle,
    dropTargetClasses,
    transformDraggedElement,
    autoAriaDisabled,
    centreDraggedOnCursor,
    ...rest
  } = options;
  if (Object.keys(rest).length > 0) {
    console.warn(`dndzone will ignore unknown options`, rest);
  }
  if (!items) {
    throw new Error("no 'items' key provided to dndzone");
  }
  const itemWithMissingId = items.find((item) => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));
  if (itemWithMissingId) {
    throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);
  }
  if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {
    throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);
  }
  if (zoneTabIndex && !isInt(zoneTabIndex)) {
    throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);
  }
}
__name(validateOptions, "validateOptions");
function isInt(value) {
  return !isNaN(value) && function(x) {
    return (x | 0) === x;
  }(parseFloat(value));
}
__name(isInt, "isInt");
const PriceList_svelte_svelte_type_style_lang = "";
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  child_ctx[32] = i;
  return child_ctx;
}
__name(get_each_context$8, "get_each_context$8");
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  child_ctx[33] = list;
  child_ctx[32] = i;
  return child_ctx;
}
__name(get_each_context_1$3, "get_each_context_1$3");
function create_if_block_3$a(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fas fa-times"></i>`;
      attr(a, "class", "item-piles-clickable-red");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[16]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$a, "create_if_block_3$a");
function create_if_block_2$a(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Drop to add";
      attr(div, "class", "drop-to-add svelte-1c30usg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_2$a, "create_if_block_2$a");
function create_else_block$4(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[24](ctx[32]);
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fas fa-eye"></i> View item`;
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block$4, "create_else_block$4");
function create_if_block_1$a(ctx) {
  let input;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[23].call(input, ctx[33], ctx[32]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "system.attributes.hp.value");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[30].data.path);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1 && input.value !== ctx[30].data.path) {
        set_input_value(input, ctx[30].data.path);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$a, "create_if_block_1$a");
function create_each_block_1$3(key_1, ctx) {
  let div9;
  let div0;
  let i0;
  let div0_tabindex_value;
  let div0_style_value;
  let t0;
  let div1;
  let input0;
  let t1;
  let div2;
  let input1;
  let t2;
  let div3;
  let input2;
  let input2_max_value;
  let t3;
  let div4;
  let input3;
  let t4;
  let div5;
  let input4;
  let t5;
  let div6;
  let filepicker;
  let updating_value;
  let t6;
  let div7;
  let t7;
  let div8;
  let button;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  function input0_input_handler() {
    ctx[17].call(input0, ctx[33], ctx[32]);
  }
  __name(input0_input_handler, "input0_input_handler");
  function input1_input_handler() {
    ctx[18].call(input1, ctx[33], ctx[32]);
  }
  __name(input1_input_handler, "input1_input_handler");
  function input2_change_handler() {
    ctx[19].call(input2, ctx[33], ctx[32]);
  }
  __name(input2_change_handler, "input2_change_handler");
  function input3_change_handler() {
    ctx[20].call(input3, ctx[33], ctx[32]);
  }
  __name(input3_change_handler, "input3_change_handler");
  function input4_input_handler() {
    ctx[21].call(input4, ctx[33], ctx[32]);
  }
  __name(input4_input_handler, "input4_input_handler");
  function filepicker_value_binding(value) {
    ctx[22](value, ctx[30]);
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  let filepicker_props = {
    type: "imagevideo",
    showImage: true,
    showInput: false
  };
  if (ctx[30].img !== void 0) {
    filepicker_props.value = ctx[30].img;
  }
  filepicker = new FilePicker_1({ props: filepicker_props });
  binding_callbacks.push(() => bind$1(filepicker, "value", filepicker_value_binding));
  function select_block_type(ctx2, dirty) {
    if (ctx2[30].type === "attribute")
      return create_if_block_1$a;
    return create_else_block$4;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  function click_handler_22() {
    return ctx[25](ctx[32]);
  }
  __name(click_handler_22, "click_handler_2");
  return {
    key: key_1,
    first: null,
    c() {
      div9 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      div1 = element("div");
      input0 = element("input");
      t1 = space();
      div2 = element("div");
      input1 = element("input");
      t2 = space();
      div3 = element("div");
      input2 = element("input");
      t3 = space();
      div4 = element("div");
      input3 = element("input");
      t4 = space();
      div5 = element("div");
      input4 = element("input");
      t5 = space();
      div6 = element("div");
      create_component(filepicker.$$.fragment);
      t6 = space();
      div7 = element("div");
      if_block.c();
      t7 = space();
      div8 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      attr(i0, "class", "fas fa-bars");
      attr(div0, "tabindex", div0_tabindex_value = ctx[4] ? 0 : -1);
      attr(div0, "aria-label", "drag-handle");
      attr(div0, "style", div0_style_value = ctx[4] ? "cursor: grab" : "cursor: grabbing");
      attr(input0, "type", "text");
      attr(input1, "type", "number");
      attr(input2, "type", "checkbox");
      attr(input2, "min", "0");
      attr(input2, "max", input2_max_value = ctx[30].percent ? 100 : 1e15);
      attr(input3, "type", "checkbox");
      attr(input4, "type", "text");
      attr(button, "type", "button");
      attr(div9, "class", "item-piles-sortable-list-columns item-piles-sortable-list-entry item-piles-even-color svelte-1c30usg");
      this.first = div9;
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div0);
      append(div0, i0);
      append(div9, t0);
      append(div9, div1);
      append(div1, input0);
      set_input_value(input0, ctx[30].name);
      append(div9, t1);
      append(div9, div2);
      append(div2, input1);
      set_input_value(input1, ctx[30].quantity);
      append(div9, t2);
      append(div9, div3);
      append(div3, input2);
      input2.checked = ctx[30].fixed;
      append(div9, t3);
      append(div9, div4);
      append(div4, input3);
      input3.checked = ctx[30].percent;
      append(div9, t4);
      append(div9, div5);
      append(div5, input4);
      set_input_value(input4, ctx[30].abbreviation);
      append(div9, t5);
      append(div9, div6);
      mount_component(filepicker, div6, null);
      append(div9, t6);
      append(div9, div7);
      if_block.m(div7, null);
      append(div9, t7);
      append(div9, div8);
      append(div8, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "mousedown", ctx[14]),
          listen(div0, "touchstart", ctx[14]),
          listen(div0, "keydown", ctx[15]),
          listen(input0, "input", input0_input_handler),
          listen(input1, "input", input1_input_handler),
          listen(input2, "change", input2_change_handler),
          listen(input3, "change", input3_change_handler),
          listen(input4, "input", input4_input_handler),
          listen(button, "click", click_handler_22)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 16 && div0_tabindex_value !== (div0_tabindex_value = ctx[4] ? 0 : -1)) {
        attr(div0, "tabindex", div0_tabindex_value);
      }
      if (!current || dirty[0] & 16 && div0_style_value !== (div0_style_value = ctx[4] ? "cursor: grab" : "cursor: grabbing")) {
        attr(div0, "style", div0_style_value);
      }
      if (dirty[0] & 1 && input0.value !== ctx[30].name) {
        set_input_value(input0, ctx[30].name);
      }
      if (dirty[0] & 1 && to_number(input1.value) !== ctx[30].quantity) {
        set_input_value(input1, ctx[30].quantity);
      }
      if (!current || dirty[0] & 1 && input2_max_value !== (input2_max_value = ctx[30].percent ? 100 : 1e15)) {
        attr(input2, "max", input2_max_value);
      }
      if (dirty[0] & 1) {
        input2.checked = ctx[30].fixed;
      }
      if (dirty[0] & 1) {
        input3.checked = ctx[30].percent;
      }
      if (dirty[0] & 1 && input4.value !== ctx[30].abbreviation) {
        set_input_value(input4, ctx[30].abbreviation);
      }
      const filepicker_changes = {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        filepicker_changes.value = ctx[30].img;
        add_flush_callback(() => updating_value = false);
      }
      filepicker.$set(filepicker_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div7, null);
        }
      }
    },
    r() {
      rect = div9.getBoundingClientRect();
    },
    f() {
      fix_position(div9);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(div9, rect, flip, { duration: flipDurationMs });
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      destroy_component(filepicker);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block_1$3, "create_each_block_1$3");
function create_if_block$f(ctx) {
  let div;
  let span;
  let t1;
  let select;
  let option;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ctx[6];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[32], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.PricePreset")}`;
      t1 = space();
      select = element("select");
      option = element("option");
      option.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.SelectPreset")}`;
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(span, "margin-right", "0.25rem");
      option.__value = "";
      option.value = option.__value;
      attr(select, "class", "price-preset-selector svelte-1c30usg");
      if (ctx[5] === void 0)
        add_render_callback(() => ctx[27].call(select));
      attr(div, "class", "full-span svelte-1c30usg");
      set_style(div, "margin-top", "0.5rem");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      append(div, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[5]);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[27]),
          listen(select, "change", ctx[28])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64) {
        each_value = ctx2[6];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$8, null, get_each_context$8);
      }
      if (dirty[0] & 96) {
        select_option(select, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$f, "create_if_block$f");
function create_each_block$8(key_1, ctx) {
  let option;
  let t_value = ctx[30].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[32];
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block$8, "create_each_block$8");
function create_default_slot$7(ctx) {
  let div12;
  let div9;
  let div0;
  let t0;
  let div1;
  let t2;
  let div2;
  let t4;
  let div3;
  let t6;
  let div4;
  let t8;
  let div5;
  let t10;
  let div6;
  let t12;
  let div7;
  let t14;
  let div8;
  let t15;
  let section;
  let t16;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t17;
  let div11;
  let div10;
  let a;
  let t19;
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_3$a(ctx);
  let if_block1 = ctx[3] && create_if_block_2$a();
  let each_value_1 = ctx[0];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[30].id, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
  }
  let if_block2 = ctx[6].length && ctx[2] && create_if_block$f(ctx);
  return {
    c() {
      div12 = element("div");
      div9 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      div1.textContent = "Name";
      t2 = space();
      div2 = element("div");
      div2.textContent = "Cost";
      t4 = space();
      div3 = element("div");
      div3.textContent = "Fixed";
      t6 = space();
      div4 = element("div");
      div4.textContent = "%";
      t8 = space();
      div5 = element("div");
      div5.textContent = "Short";
      t10 = space();
      div6 = element("div");
      div6.textContent = "Icon";
      t12 = space();
      div7 = element("div");
      div7.textContent = "Data";
      t14 = space();
      div8 = element("div");
      if (if_block0)
        if_block0.c();
      t15 = space();
      section = element("section");
      if (if_block1)
        if_block1.c();
      t16 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t17 = space();
      div11 = element("div");
      div10 = element("div");
      a = element("a");
      a.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DropMeClickMe")}`;
      t19 = space();
      if (if_block2)
        if_block2.c();
      attr(div9, "class", "item-piles-sortable-list-columns header svelte-1c30usg");
      attr(a, "class", "svelte-1c30usg");
      toggle_class(a, "invisible", ctx[3]);
      attr(div10, "class", "full-span svelte-1c30usg");
      attr(div11, "class", "item-piles-sortable-list-columns svelte-1c30usg");
      set_style(div11, "margin-top", "0.5rem");
      attr(div12, "class", "table-container item-piles-top-divider svelte-1c30usg");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div9);
      append(div9, div0);
      append(div9, t0);
      append(div9, div1);
      append(div9, t2);
      append(div9, div2);
      append(div9, t4);
      append(div9, div3);
      append(div9, t6);
      append(div9, div4);
      append(div9, t8);
      append(div9, div5);
      append(div9, t10);
      append(div9, div6);
      append(div9, t12);
      append(div9, div7);
      append(div9, t14);
      append(div9, div8);
      if (if_block0)
        if_block0.m(div8, null);
      append(div12, t15);
      append(div12, section);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t16);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(section, null);
      }
      append(section, t17);
      append(section, div11);
      append(div11, div10);
      append(div10, a);
      append(div11, t19);
      if (if_block2)
        if_block2.m(div11, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[26]),
          action_destroyer(dndzone_action = dndzone.call(null, section, {
            items: ctx[0],
            dragDisabled: ctx[4],
            flipDurationMs
          })),
          listen(section, "consider", ctx[12]),
          listen(section, "finalize", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$a(ctx2);
          if_block0.c();
          if_block0.m(div8, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_2$a();
          if_block1.c();
          if_block1.m(section, t16);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 51345) {
        each_value_1 = ctx2[0];
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, section, fix_and_outro_and_destroy_block, create_each_block_1$3, t17, get_each_context_1$3);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty[0] & 8) {
        toggle_class(a, "invisible", ctx2[3]);
      }
      if (ctx2[6].length && ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$f(ctx2);
          if_block2.c();
          if_block2.m(div11, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty[0] & 17)
        dndzone_action.update.call(null, {
          items: ctx2[0],
          dragDisabled: ctx2[4],
          flipDurationMs
        });
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$7, "create_default_slot$7");
function create_fragment$i(ctx) {
  let dropzone;
  let updating_isHovering;
  let current;
  function dropzone_isHovering_binding(value) {
    ctx[29](value);
  }
  __name(dropzone_isHovering_binding, "dropzone_isHovering_binding");
  let dropzone_props = {
    callback: ctx[10],
    $$slots: { default: [create_default_slot$7] },
    $$scope: { ctx }
  };
  if (ctx[3] !== void 0) {
    dropzone_props.isHovering = ctx[3];
  }
  dropzone = new DropZone({ props: dropzone_props });
  binding_callbacks.push(() => bind$1(dropzone, "isHovering", dropzone_isHovering_binding));
  return {
    c() {
      create_component(dropzone.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dropzone, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropzone_changes = {};
      if (dirty[0] & 63 | dirty[1] & 8) {
        dropzone_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_isHovering && dirty[0] & 8) {
        updating_isHovering = true;
        dropzone_changes.isHovering = ctx2[3];
        add_flush_callback(() => updating_isHovering = false);
      }
      dropzone.$set(dropzone_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropzone.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropzone.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropzone, detaching);
    }
  };
}
__name(create_fragment$i, "create_fragment$i");
let flipDurationMs = 200;
function instance$i($$self, $$props, $$invalidate) {
  let { prices } = $$props;
  let { remove = false } = $$props;
  let { presets = true } = $$props;
  let presetPrices = getSetting(SETTINGS.PRICE_PRESETS);
  let isHovering = false;
  let dragDisabled = true;
  let selectedPreset = "";
  function removeEntry(index) {
    prices.splice(index, 1);
    $$invalidate(0, prices);
  }
  __name(removeEntry, "removeEntry");
  function addAttribute() {
    $$invalidate(0, prices = [
      ...prices,
      {
        id: randomID(),
        type: "attribute",
        name: "New Attribute",
        img: "",
        abbreviation: "{#}N",
        data: { path: "" },
        quantity: 1,
        fixed: true,
        percent: false
      }
    ]);
  }
  __name(addAttribute, "addAttribute");
  function addPreset(index) {
    const preset = foundry.utils.duplicate(presetPrices[index]);
    preset.id = randomID();
    $$invalidate(0, prices = [...prices, preset]);
  }
  __name(addPreset, "addPreset");
  async function dropData(data) {
    if (!data.type) {
      throw custom_error("Something went wrong when dropping this item!");
    }
    if (data.type !== "Item") {
      throw custom_error("You must drop an item, not " + data.type.toLowerCase() + "!");
    }
    let uuid = false;
    if (data.pack) {
      uuid = "Compendium" + data.pack + "." + data.id;
    }
    let item = await Item.implementation.fromDropData(data);
    let itemData = item.toObject();
    if (!itemData) {
      console.error(data);
      throw custom_error("Something went wrong when dropping this item!");
    }
    const itemCurrencies = prices.map((entry) => entry.data?.item ?? {});
    const foundItem = findSimilarItem(itemCurrencies, itemData);
    if (foundItem) {
      const index = itemCurrencies.indexOf(foundItem);
      $$invalidate(0, prices[index].data = { uuid, item: itemData }, prices);
      custom_notify(`Updated item data for ${localize(prices[index].name)} (item name ${itemData.name})`);
    } else {
      $$invalidate(0, prices = [
        ...prices,
        {
          id: randomID(),
          type: "item",
          name: itemData.name,
          img: itemData.img,
          abbreviation: "{#} " + itemData.name,
          data: { uuid, item: itemData },
          quantity: 1,
          fixed: true,
          percent: false
        }
      ]);
    }
  }
  __name(dropData, "dropData");
  async function editItem(index) {
    const data = prices[index].data;
    let item;
    if (data.uuid) {
      item = await fromUuid(data.uuid);
    } else {
      let itemData = data.item;
      if (itemData._id)
        delete itemData._id;
      if (itemData.permission)
        delete itemData._id;
      const items = Array.from(game.items);
      item = findSimilarItem(items, itemData);
      if (!item) {
        setProperty(itemData, CONSTANTS.FLAGS.TEMPORARY_ITEM, true);
        item = await Item.implementation.create(itemData);
        custom_notify(`An item has been created for ${item.name} - drag and drop it into the list to update the stored item data`);
      }
    }
    item.sheet.render(true);
  }
  __name(editItem, "editItem");
  function handleConsider(e) {
    const { items: newItems, info: { source, trigger } } = e.detail;
    $$invalidate(0, prices = newItems);
    if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {
      $$invalidate(4, dragDisabled = true);
    }
  }
  __name(handleConsider, "handleConsider");
  function handleFinalize(e) {
    const { items: newItems, info: { source } } = e.detail;
    $$invalidate(0, prices = newItems);
    if (source === SOURCES.POINTER) {
      $$invalidate(4, dragDisabled = true);
    }
  }
  __name(handleFinalize, "handleFinalize");
  function startDrag(e) {
    e.preventDefault();
    $$invalidate(4, dragDisabled = false);
  }
  __name(startDrag, "startDrag");
  function handleKeyDown(e) {
    if ((e.key === "Enter" || e.key === " ") && dragDisabled)
      $$invalidate(4, dragDisabled = false);
  }
  __name(handleKeyDown, "handleKeyDown");
  const click_handler = /* @__PURE__ */ __name(() => remove(), "click_handler");
  function input0_input_handler(each_value_1, index) {
    each_value_1[index].name = this.value;
    $$invalidate(0, prices);
  }
  __name(input0_input_handler, "input0_input_handler");
  function input1_input_handler(each_value_1, index) {
    each_value_1[index].quantity = to_number(this.value);
    $$invalidate(0, prices);
  }
  __name(input1_input_handler, "input1_input_handler");
  function input2_change_handler(each_value_1, index) {
    each_value_1[index].fixed = this.checked;
    $$invalidate(0, prices);
  }
  __name(input2_change_handler, "input2_change_handler");
  function input3_change_handler(each_value_1, index) {
    each_value_1[index].percent = this.checked;
    $$invalidate(0, prices);
  }
  __name(input3_change_handler, "input3_change_handler");
  function input4_input_handler(each_value_1, index) {
    each_value_1[index].abbreviation = this.value;
    $$invalidate(0, prices);
  }
  __name(input4_input_handler, "input4_input_handler");
  function filepicker_value_binding(value, price) {
    if ($$self.$$.not_equal(price.img, value)) {
      price.img = value;
      $$invalidate(0, prices);
    }
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  function input_input_handler(each_value_1, index) {
    each_value_1[index].data.path = this.value;
    $$invalidate(0, prices);
  }
  __name(input_input_handler, "input_input_handler");
  const click_handler_1 = /* @__PURE__ */ __name((index) => editItem(index), "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name((index) => removeEntry(index), "click_handler_2");
  const click_handler_32 = /* @__PURE__ */ __name(() => addAttribute(), "click_handler_3");
  function select_change_handler() {
    selectedPreset = select_value(this);
    $$invalidate(5, selectedPreset);
    $$invalidate(6, presetPrices);
  }
  __name(select_change_handler, "select_change_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    addPreset(selectedPreset);
    $$invalidate(5, selectedPreset = "");
  }, "change_handler");
  function dropzone_isHovering_binding(value) {
    isHovering = value;
    $$invalidate(3, isHovering);
  }
  __name(dropzone_isHovering_binding, "dropzone_isHovering_binding");
  $$self.$$set = ($$props2) => {
    if ("prices" in $$props2)
      $$invalidate(0, prices = $$props2.prices);
    if ("remove" in $$props2)
      $$invalidate(1, remove = $$props2.remove);
    if ("presets" in $$props2)
      $$invalidate(2, presets = $$props2.presets);
  };
  return [
    prices,
    remove,
    presets,
    isHovering,
    dragDisabled,
    selectedPreset,
    presetPrices,
    removeEntry,
    addAttribute,
    addPreset,
    dropData,
    editItem,
    handleConsider,
    handleFinalize,
    startDrag,
    handleKeyDown,
    click_handler,
    input0_input_handler,
    input1_input_handler,
    input2_change_handler,
    input3_change_handler,
    input4_input_handler,
    filepicker_value_binding,
    input_input_handler,
    click_handler_1,
    click_handler_22,
    click_handler_32,
    select_change_handler,
    change_handler,
    dropzone_isHovering_binding
  ];
}
__name(instance$i, "instance$i");
class PriceList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, { prices: 0, remove: 1, presets: 2 }, null, [-1, -1]);
  }
}
__name(PriceList, "PriceList");
const itemEditorShell_svelte_svelte_type_style_lang = "";
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  child_ctx[35] = list;
  child_ctx[36] = i;
  return child_ctx;
}
__name(get_each_context$7, "get_each_context$7");
function create_if_block_3$9(ctx) {
  let div10;
  let div0;
  let label0;
  let t0_value = localize("ITEM-PILES.Applications.ItemEditor.CustomCategory") + "";
  let t0;
  let br0;
  let t1;
  let p0;
  let t3;
  let input0;
  let input0_placeholder_value;
  let t4;
  let div1;
  let label1;
  let t5_value = localize("ITEM-PILES.Applications.ItemEditor.Hidden") + "";
  let t5;
  let br1;
  let t6;
  let p1;
  let t8;
  let input1;
  let t9;
  let div2;
  let label2;
  let t10_value = localize("ITEM-PILES.Applications.ItemEditor.NotForSale") + "";
  let t10;
  let br2;
  let t11;
  let p2;
  let t13;
  let input2;
  let t14;
  let div3;
  let label3;
  let t15_value = localize("ITEM-PILES.Applications.ItemEditor.CantBeSoldToMerchants") + "";
  let t15;
  let br3;
  let t16;
  let p3;
  let t18;
  let input3;
  let t19;
  let div4;
  let label4;
  let t20_value = localize("ITEM-PILES.Applications.ItemEditor.InfiniteQuantity") + "";
  let t20;
  let br4;
  let t21;
  let p4;
  let t23;
  let input4;
  let t24;
  let div5;
  let label5;
  let span0;
  let t26;
  let p5;
  let t28;
  let input5;
  let t29;
  let div6;
  let label6;
  let t30_value = localize("ITEM-PILES.Applications.ItemEditor.DisplayQuantity") + "";
  let t30;
  let br5;
  let t31;
  let p6;
  let t33;
  let select;
  let option0;
  let option1;
  let option2;
  let t39;
  let div7;
  let label7;
  let t40_value = localize("ITEM-PILES.Applications.ItemEditor.Service") + "";
  let t40;
  let br6;
  let t41;
  let p7;
  let t43;
  let input6;
  let t44;
  let div8;
  let label8;
  let span1;
  let t46;
  let p8;
  let t48;
  let div9;
  let macroselector;
  let updating_macro;
  let current;
  let mounted;
  let dispose;
  function macroselector_macro_binding(value) {
    ctx[23](value);
  }
  __name(macroselector_macro_binding, "macroselector_macro_binding");
  let macroselector_props = {};
  if (ctx[5].macro !== void 0) {
    macroselector_props.macro = ctx[5].macro;
  }
  macroselector = new MacroSelector({ props: macroselector_props });
  binding_callbacks.push(() => bind$1(macroselector, "macro", macroselector_macro_binding));
  return {
    c() {
      div10 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text(t0_value);
      br0 = element("br");
      t1 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.CustomCategoryExplanation")}`;
      t3 = space();
      input0 = element("input");
      t4 = space();
      div1 = element("div");
      label1 = element("label");
      t5 = text(t5_value);
      br1 = element("br");
      t6 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.HiddenExplanation")}`;
      t8 = space();
      input1 = element("input");
      t9 = space();
      div2 = element("div");
      label2 = element("label");
      t10 = text(t10_value);
      br2 = element("br");
      t11 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.NotForSaleExplanation")}`;
      t13 = space();
      input2 = element("input");
      t14 = space();
      div3 = element("div");
      label3 = element("label");
      t15 = text(t15_value);
      br3 = element("br");
      t16 = space();
      p3 = element("p");
      p3.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.CantBeSoldToMerchantsExplanation")}`;
      t18 = space();
      input3 = element("input");
      t19 = space();
      div4 = element("div");
      label4 = element("label");
      t20 = text(t20_value);
      br4 = element("br");
      t21 = space();
      p4 = element("p");
      p4.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.InfiniteQuantityExplanation")}`;
      t23 = space();
      input4 = element("input");
      t24 = space();
      div5 = element("div");
      label5 = element("label");
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.KeepZero")}`;
      t26 = space();
      p5 = element("p");
      p5.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.KeepZeroExplanation")}`;
      t28 = space();
      input5 = element("input");
      t29 = space();
      div6 = element("div");
      label6 = element("label");
      t30 = text(t30_value);
      br5 = element("br");
      t31 = space();
      p6 = element("p");
      p6.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DisplayQuantityExplanation")}`;
      t33 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DisplayQuantityDefault")} 
              `;
      option1 = element("option");
      option1.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DisplayQuantityYes")} 
              `;
      option2 = element("option");
      option2.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DisplayQuantityNo")}`;
      t39 = space();
      div7 = element("div");
      label7 = element("label");
      t40 = text(t40_value);
      br6 = element("br");
      t41 = space();
      p7 = element("p");
      p7.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.ServiceExplanation")}`;
      t43 = space();
      input6 = element("input");
      t44 = space();
      div8 = element("div");
      label8 = element("label");
      span1 = element("span");
      span1.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.PurchaseMacro")}`;
      t46 = space();
      p8 = element("p");
      p8.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.PurchaseMacroExplanation")}`;
      t48 = space();
      div9 = element("div");
      create_component(macroselector.$$.fragment);
      set_style(label0, "flex", "4");
      attr(input0, "type", "text");
      attr(input0, "placeholder", input0_placeholder_value = ctx[1].type);
      attr(div0, "class", "form-group");
      set_style(label1, "flex", "4");
      attr(input1, "type", "checkbox");
      attr(div1, "class", "form-group");
      set_style(label2, "flex", "4");
      attr(input2, "type", "checkbox");
      attr(div2, "class", "form-group");
      set_style(label3, "flex", "4");
      attr(input3, "type", "checkbox");
      attr(div3, "class", "form-group");
      set_style(label4, "flex", "4");
      attr(input4, "type", "checkbox");
      attr(div4, "class", "form-group");
      attr(input5, "type", "checkbox");
      attr(div5, "class", "form-group");
      option0.__value = "default";
      option0.value = option0.__value;
      option1.__value = "yes";
      option1.value = option1.__value;
      option2.__value = "no";
      option2.value = option2.__value;
      set_style(select, "flex", "0 1 auto");
      if (ctx[5].displayQuantity === void 0)
        add_render_callback(() => ctx[21].call(select));
      attr(div6, "class", "form-group");
      set_style(label7, "flex", "4");
      attr(input6, "type", "checkbox");
      attr(div7, "class", "form-group");
      set_style(label8, "flex", "4");
      attr(div8, "class", "form-group");
      attr(div9, "class", "form-group");
      attr(div10, "class", "tab flex svelte-lesn2z");
    },
    m(target, anchor) {
      insert(target, div10, anchor);
      append(div10, div0);
      append(div0, label0);
      append(label0, t0);
      append(label0, br0);
      append(label0, t1);
      append(label0, p0);
      append(div0, t3);
      append(div0, input0);
      set_input_value(input0, ctx[5].customCategory);
      append(div10, t4);
      append(div10, div1);
      append(div1, label1);
      append(label1, t5);
      append(label1, br1);
      append(label1, t6);
      append(label1, p1);
      append(div1, t8);
      append(div1, input1);
      input1.checked = ctx[5].hidden;
      append(div10, t9);
      append(div10, div2);
      append(div2, label2);
      append(label2, t10);
      append(label2, br2);
      append(label2, t11);
      append(label2, p2);
      append(div2, t13);
      append(div2, input2);
      input2.checked = ctx[5].notForSale;
      append(div10, t14);
      append(div10, div3);
      append(div3, label3);
      append(label3, t15);
      append(label3, br3);
      append(label3, t16);
      append(label3, p3);
      append(div3, t18);
      append(div3, input3);
      input3.checked = ctx[5].cantBeSoldToMerchants;
      append(div10, t19);
      append(div10, div4);
      append(div4, label4);
      append(label4, t20);
      append(label4, br4);
      append(label4, t21);
      append(label4, p4);
      append(div4, t23);
      append(div4, input4);
      input4.checked = ctx[5].infiniteQuantity;
      append(div10, t24);
      append(div10, div5);
      append(div5, label5);
      append(label5, span0);
      append(label5, t26);
      append(label5, p5);
      append(div5, t28);
      append(div5, input5);
      input5.checked = ctx[5].keepZeroQuantity;
      append(div10, t29);
      append(div10, div6);
      append(div6, label6);
      append(label6, t30);
      append(label6, br5);
      append(label6, t31);
      append(label6, p6);
      append(div6, t33);
      append(div6, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      select_option(select, ctx[5].displayQuantity);
      append(div10, t39);
      append(div10, div7);
      append(div7, label7);
      append(label7, t40);
      append(label7, br6);
      append(label7, t41);
      append(label7, p7);
      append(div7, t43);
      append(div7, input6);
      input6.checked = ctx[5].isService;
      append(div10, t44);
      append(div10, div8);
      append(div8, label8);
      append(label8, span1);
      append(label8, t46);
      append(label8, p8);
      append(div10, t48);
      append(div10, div9);
      mount_component(macroselector, div9, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[15]),
          listen(input1, "change", ctx[16]),
          listen(input2, "change", ctx[17]),
          listen(input3, "change", ctx[18]),
          listen(input4, "change", ctx[19]),
          listen(input5, "change", ctx[20]),
          listen(select, "change", ctx[21]),
          listen(input6, "change", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 2 && input0_placeholder_value !== (input0_placeholder_value = ctx2[1].type)) {
        attr(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty[0] & 32 && input0.value !== ctx2[5].customCategory) {
        set_input_value(input0, ctx2[5].customCategory);
      }
      if (dirty[0] & 32) {
        input1.checked = ctx2[5].hidden;
      }
      if (dirty[0] & 32) {
        input2.checked = ctx2[5].notForSale;
      }
      if (dirty[0] & 32) {
        input3.checked = ctx2[5].cantBeSoldToMerchants;
      }
      if (dirty[0] & 32) {
        input4.checked = ctx2[5].infiniteQuantity;
      }
      if (dirty[0] & 32) {
        input5.checked = ctx2[5].keepZeroQuantity;
      }
      if (dirty[0] & 32) {
        select_option(select, ctx2[5].displayQuantity);
      }
      if (dirty[0] & 32) {
        input6.checked = ctx2[5].isService;
      }
      const macroselector_changes = {};
      if (!updating_macro && dirty[0] & 32) {
        updating_macro = true;
        macroselector_changes.macro = ctx2[5].macro;
        add_flush_callback(() => updating_macro = false);
      }
      macroselector.$set(macroselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macroselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macroselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div10);
      destroy_component(macroselector);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$9, "create_if_block_3$9");
function create_if_block$e(ctx) {
  let div3;
  let t0;
  let div0;
  let label0;
  let t1_value = localize("ITEM-PILES.Applications.ItemEditor.Free") + "";
  let t1;
  let br0;
  let t2;
  let p0;
  let t4;
  let input0;
  let t5;
  let div1;
  let label1;
  let t6_value = localize("ITEM-PILES.Applications.ItemEditor.DisableNormalCost") + "";
  let t6;
  let br1;
  let t7;
  let p1;
  let t9;
  let input1;
  let t10;
  let div2;
  let label2;
  let t11_value = localize("ITEM-PILES.Applications.ItemEditor.PurchaseOptions") + "";
  let t11;
  let br2;
  let t12;
  let p2;
  let t14;
  let button;
  let i;
  let t15;
  let t16_value = localize("ITEM-PILES.Applications.ItemEditor.AddPurchaseOption") + "";
  let t16;
  let t17;
  let current;
  let mounted;
  let dispose;
  let if_block0 = game.system.id !== "pf2e" && create_if_block_2$9(ctx);
  let if_block1 = ctx[5].prices.length && create_if_block_1$9(ctx);
  return {
    c() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      label0 = element("label");
      t1 = text(t1_value);
      br0 = element("br");
      t2 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.FreeExplanation")}`;
      t4 = space();
      input0 = element("input");
      t5 = space();
      div1 = element("div");
      label1 = element("label");
      t6 = text(t6_value);
      br1 = element("br");
      t7 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.DisableNormalCostExplanation")}`;
      t9 = space();
      input1 = element("input");
      t10 = space();
      div2 = element("div");
      label2 = element("label");
      t11 = text(t11_value);
      br2 = element("br");
      t12 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.PurchaseOptionsExplanation")}`;
      t14 = space();
      button = element("button");
      i = element("i");
      t15 = space();
      t16 = text(t16_value);
      t17 = space();
      if (if_block1)
        if_block1.c();
      set_style(label0, "flex", "4");
      attr(input0, "type", "checkbox");
      attr(div0, "class", "form-group");
      set_style(label1, "flex", "4");
      attr(input1, "type", "checkbox");
      attr(div1, "class", "form-group");
      set_style(label2, "flex", "4");
      attr(i, "class", "fas fa-plus");
      attr(button, "type", "button");
      attr(div2, "class", "form-group");
      attr(div3, "class", "tab flex svelte-lesn2z");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t0);
      append(div3, div0);
      append(div0, label0);
      append(label0, t1);
      append(label0, br0);
      append(label0, t2);
      append(label0, p0);
      append(div0, t4);
      append(div0, input0);
      input0.checked = ctx[5].free;
      append(div3, t5);
      append(div3, div1);
      append(div1, label1);
      append(label1, t6);
      append(label1, br1);
      append(label1, t7);
      append(label1, p1);
      append(div1, t9);
      append(div1, input1);
      input1.checked = ctx[5].disableNormalCost;
      append(div3, t10);
      append(div3, div2);
      append(div2, label2);
      append(label2, t11);
      append(label2, br2);
      append(label2, t12);
      append(label2, p2);
      append(div2, t14);
      append(div2, button);
      append(button, i);
      append(button, t15);
      append(button, t16);
      append(div3, t17);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[26]),
          listen(input1, "change", ctx[27]),
          listen(button, "click", ctx[28])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (game.system.id !== "pf2e")
        if_block0.p(ctx2, dirty);
      if (dirty[0] & 32) {
        input0.checked = ctx2[5].free;
      }
      if (dirty[0] & 32) {
        input1.checked = ctx2[5].disableNormalCost;
      }
      if (ctx2[5].prices.length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$e, "create_if_block$e");
function create_if_block_2$9(ctx) {
  let div;
  let label;
  let t0_value = localize("ITEM-PILES.Applications.ItemEditor.BasePrice") + "";
  let t0;
  let br;
  let t1;
  let p;
  let t3;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      br = element("br");
      t1 = space();
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Applications.ItemEditor.BasePriceExplanation")}`;
      t3 = space();
      input = element("input");
      set_style(label, "flex", "4");
      attr(input, "type", "text");
      attr(div, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, br);
      append(label, t1);
      append(label, p);
      append(div, t3);
      append(div, input);
      set_input_value(input, ctx[6]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[24]),
          listen(input, "change", ctx[25])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && input.value !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_2$9, "create_if_block_2$9");
function create_if_block_1$9(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[5].prices;
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[36], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 288) {
        each_value = ctx2[5].prices;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$7, each_1_anchor, get_each_context$7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
__name(create_if_block_1$9, "create_if_block_1$9");
function create_each_block$7(key_1, ctx) {
  let first;
  let pricelist;
  let updating_prices;
  let current;
  function func2() {
    return ctx[29](ctx[36]);
  }
  __name(func2, "func");
  function pricelist_prices_binding(value) {
    ctx[30](value, ctx[34], ctx[35], ctx[36]);
  }
  __name(pricelist_prices_binding, "pricelist_prices_binding");
  let pricelist_props = { remove: func2 };
  if (ctx[34] !== void 0) {
    pricelist_props.prices = ctx[34];
  }
  pricelist = new PriceList({ props: pricelist_props });
  binding_callbacks.push(() => bind$1(pricelist, "prices", pricelist_prices_binding));
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pricelist.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pricelist, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pricelist_changes = {};
      if (dirty[0] & 32)
        pricelist_changes.remove = func2;
      if (!updating_prices && dirty[0] & 32) {
        updating_prices = true;
        pricelist_changes.prices = ctx[34];
        add_flush_callback(() => updating_prices = false);
      }
      pricelist.$set(pricelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pricelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pricelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(pricelist, detaching);
    }
  };
}
__name(create_each_block$7, "create_each_block$7");
function create_default_slot$6(ctx) {
  let form_1;
  let tabs;
  let updating_activeTab;
  let t0;
  let section;
  let t1;
  let t2;
  let footer;
  let button0;
  let i0;
  let t3;
  let t4_value = localize("ITEM-PILES.Applications.ItemEditor.Update") + "";
  let t4;
  let t5;
  let button1;
  let i1;
  let t6;
  let t7_value = localize("Cancel") + "";
  let t7;
  let current;
  let mounted;
  let dispose;
  function tabs_activeTab_binding(value) {
    ctx[14](value);
  }
  __name(tabs_activeTab_binding, "tabs_activeTab_binding");
  let tabs_props = {
    tabs: [
      {
        value: "general",
        label: localize("ITEM-PILES.Applications.ItemEditor.General")
      },
      {
        value: "price",
        label: localize("ITEM-PILES.Applications.ItemEditor.Price")
      }
    ]
  };
  if (ctx[4] !== void 0) {
    tabs_props.activeTab = ctx[4];
  }
  tabs = new Tabs({ props: tabs_props });
  binding_callbacks.push(() => bind$1(tabs, "activeTab", tabs_activeTab_binding));
  let if_block0 = ctx[4] === "general" && create_if_block_3$9(ctx);
  let if_block1 = ctx[4] === "price" && create_if_block$e(ctx);
  return {
    c() {
      form_1 = element("form");
      create_component(tabs.$$.fragment);
      t0 = space();
      section = element("section");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      footer = element("footer");
      button0 = element("button");
      i0 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      button1 = element("button");
      i1 = element("i");
      t6 = space();
      t7 = text(t7_value);
      attr(section, "class", "tab-body");
      attr(i0, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i1, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
      attr(form_1, "class", "item-piles-config-container");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      mount_component(tabs, form_1, null);
      append(form_1, t0);
      append(form_1, section);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t1);
      if (if_block1)
        if_block1.m(section, null);
      append(form_1, t2);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i0);
      append(button0, t3);
      append(button0, t4);
      append(footer, t5);
      append(footer, button1);
      append(button1, i1);
      append(button1, t6);
      append(button1, t7);
      ctx[32](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[31], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[11]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (!updating_activeTab && dirty[0] & 16) {
        updating_activeTab = true;
        tabs_changes.activeTab = ctx2[4];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs.$set(tabs_changes);
      if (ctx2[4] === "general") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4] === "price") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(tabs.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(tabs);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$6, "create_default_slot$6");
function create_fragment$h(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[33](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$6] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 122 | dirty[1] & 64) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$h, "create_fragment$h");
function instance$h($$self, $$props, $$invalidate) {
  let itemFlagData;
  let $flagDataStore;
  let $price;
  const { application } = getContext("external");
  let { item } = $$props;
  let { elementRoot } = $$props;
  let store = ItemPriceStore.make(item);
  const flagDataStore = store.data;
  component_subscribe($$self, flagDataStore, (value) => $$invalidate(13, $flagDataStore = value));
  let price = store.price;
  component_subscribe($$self, price, (value) => $$invalidate(6, $price = value));
  let form;
  async function updateSettings() {
    await updateItemData(item, store.export());
    application.options.resolve();
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function addGroup() {
    $$invalidate(5, itemFlagData.prices = [...itemFlagData.prices, []], itemFlagData);
  }
  __name(addGroup, "addGroup");
  let activeTab = "general";
  function tabs_activeTab_binding(value) {
    activeTab = value;
    $$invalidate(4, activeTab);
  }
  __name(tabs_activeTab_binding, "tabs_activeTab_binding");
  function input0_input_handler() {
    itemFlagData.customCategory = this.value;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input0_input_handler, "input0_input_handler");
  function input1_change_handler() {
    itemFlagData.hidden = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input1_change_handler, "input1_change_handler");
  function input2_change_handler() {
    itemFlagData.notForSale = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input2_change_handler, "input2_change_handler");
  function input3_change_handler() {
    itemFlagData.cantBeSoldToMerchants = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input3_change_handler, "input3_change_handler");
  function input4_change_handler() {
    itemFlagData.infiniteQuantity = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input4_change_handler, "input4_change_handler");
  function input5_change_handler() {
    itemFlagData.keepZeroQuantity = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input5_change_handler, "input5_change_handler");
  function select_change_handler() {
    itemFlagData.displayQuantity = select_value(this);
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(select_change_handler, "select_change_handler");
  function input6_change_handler() {
    itemFlagData.isService = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input6_change_handler, "input6_change_handler");
  function macroselector_macro_binding(value) {
    if ($$self.$$.not_equal(itemFlagData.macro, value)) {
      itemFlagData.macro = value;
      $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
    }
  }
  __name(macroselector_macro_binding, "macroselector_macro_binding");
  function input_input_handler() {
    $price = this.value;
    price.set($price);
  }
  __name(input_input_handler, "input_input_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    set_store_value(
      price,
      $price = isNaN(Number($price)) ? $price : $price.max(0, Number($price)),
      $price
    );
  }, "change_handler");
  function input0_change_handler() {
    itemFlagData.free = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input0_change_handler, "input0_change_handler");
  function input1_change_handler_1() {
    itemFlagData.disableNormalCost = this.checked;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(input1_change_handler_1, "input1_change_handler_1");
  const click_handler = /* @__PURE__ */ __name(() => {
    addGroup();
  }, "click_handler");
  const func2 = /* @__PURE__ */ __name((groupIndex) => {
    store.removeGroup(groupIndex);
  }, "func");
  function pricelist_prices_binding(value, prices, each_value, groupIndex) {
    each_value[groupIndex] = value;
    $$invalidate(5, itemFlagData), $$invalidate(13, $flagDataStore);
  }
  __name(pricelist_prices_binding, "pricelist_prices_binding");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler_1");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8192) {
      $$invalidate(5, itemFlagData = $flagDataStore);
    }
  };
  return [
    elementRoot,
    item,
    requestSubmit,
    form,
    activeTab,
    itemFlagData,
    $price,
    application,
    store,
    flagDataStore,
    price,
    updateSettings,
    addGroup,
    $flagDataStore,
    tabs_activeTab_binding,
    input0_input_handler,
    input1_change_handler,
    input2_change_handler,
    input3_change_handler,
    input4_change_handler,
    input5_change_handler,
    select_change_handler,
    input6_change_handler,
    macroselector_macro_binding,
    input_input_handler,
    change_handler,
    input0_change_handler,
    input1_change_handler_1,
    click_handler,
    func2,
    pricelist_prices_binding,
    click_handler_1,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$h, "instance$h");
class Item_editor_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$h,
      create_fragment$h,
      safe_not_equal,
      {
        item: 1,
        elementRoot: 0,
        requestSubmit: 2
      },
      null,
      [-1, -1]
    );
  }
  get item() {
    return this.$$.ctx[1];
  }
  set item(item) {
    this.$$set({ item });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Item_editor_shell, "Item_editor_shell");
class ItemEditor extends SvelteApplication {
  constructor(item = false, options) {
    super({
      id: `item-pile-item-editor-${item.id}`,
      title: game.i18n.format("ITEM-PILES.Applications.ItemEditor.Title", { item_name: item.name }),
      svelte: {
        class: Item_editor_shell,
        target: document.body,
        props: {
          item
        }
      },
      close: () => this.options.resolve(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 500,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApp(id) {
    return Object.values(ui.windows).find((app) => app.id === `item-pile-item-editor-${id}`);
  }
  static async show(item = false, options = {}, dialogData = {}) {
    const app = this.getActiveApp(item.id);
    if (app)
      return app.render(false, { focus: true });
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(item, options, dialogData).render(true, { focus: true });
    });
  }
}
__name(ItemEditor, "ItemEditor");
const get_right_slot_changes = /* @__PURE__ */ __name((dirty) => ({}), "get_right_slot_changes");
const get_right_slot_context = /* @__PURE__ */ __name((ctx) => ({}), "get_right_slot_context");
function create_else_block$3(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[9]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 512)
        set_data(t, ctx2[9]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_else_block$3, "create_else_block$3");
function create_if_block_4$6(ctx) {
  let a;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t = text(ctx[9]);
      attr(a, "class", "item-piles-clickable");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[17](ctx[0])))
            ctx[17](ctx[0]).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 512)
        set_data(t, ctx[9]);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$6, "create_if_block_4$6");
function create_if_block_1$8(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block_2$8;
    if (!ctx2[1])
      return create_if_block_3$8;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_1$8, "create_if_block_1$8");
function create_if_block_3$8(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text("(x");
      t1 = text(ctx[3]);
      t2 = text(")");
      attr(span, "class", "item-piles-small-text");
      toggle_class(span, "item-piles-clickable-link", game.user.isGM);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      if (!mounted) {
        dispose = listen(span, "click", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t1, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$8, "create_if_block_3$8");
function create_if_block_2$8(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "(\u221E)";
      attr(span, "class", "item-piles-small-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_if_block_2$8, "create_if_block_2$8");
function create_if_block$d(ctx) {
  let div1;
  let div0;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "text");
      input.autofocus = true;
      attr(div0, "class", "item-piles-quantity-input-container");
      attr(div1, "class", "item-piles-quantity-container");
      set_style(div1, "flex", "0 1 50px");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      set_input_value(input, ctx[2]);
      input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[25]),
          listen(input, "change", ctx[26]),
          listen(input, "keydown", ctx[27])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$d, "create_if_block$d");
function create_fragment$g(ctx) {
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let div1;
  let t1;
  let t2;
  let t3;
  let current;
  function select_block_type(ctx2, dirty) {
    if (ctx2[8].canInspectItems || game.user.isGM)
      return create_if_block_4$6;
    return create_else_block$3;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[5] && ctx[0].canStack && create_if_block_1$8(ctx);
  let if_block2 = ctx[1] && create_if_block$d(ctx);
  const right_slot_template = ctx[23].right;
  const right_slot = create_slot(right_slot_template, ctx, ctx[22], get_right_slot_context);
  return {
    c() {
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (right_slot)
        right_slot.c();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[7]))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      toggle_class(div0, "not-for-sale", ctx[6].notForSale || !ctx[3]);
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name item-piles-text");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, img);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      if_block0.m(div1, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      insert(target, t3, anchor);
      if (right_slot) {
        right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 128 && !src_url_equal(img.src, img_src_value = ctx2[7])) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & 72) {
        toggle_class(div0, "not-for-sale", ctx2[6].notForSale || !ctx2[3]);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div1, t1);
        }
      }
      if (ctx2[5] && ctx2[0].canStack) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$8(ctx2);
          if_block1.c();
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$d(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(right_slot_template, ctx2[22], dirty, get_right_slot_changes),
            get_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t3);
      if (right_slot)
        right_slot.d(detaching);
    }
  };
}
__name(create_fragment$g, "create_fragment$g");
function instance$g($$self, $$props, $$invalidate) {
  let itemFlagData;
  let displayQuantity;
  let infiniteQuantity;
  let quantity;
  let editQuantity;
  let $quantityStore;
  let $infiniteQuantityStore;
  let $displayQuantityStore;
  let $itemFlagDataStore;
  let $itemImage;
  let $pileData;
  let $itemName;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  const itemName = item.name;
  component_subscribe($$self, itemName, (value) => $$invalidate(9, $itemName = value));
  const itemImage = item.img;
  component_subscribe($$self, itemImage, (value) => $$invalidate(7, $itemImage = value));
  const store = item.store;
  const pileData = store.pileData;
  component_subscribe($$self, pileData, (value) => $$invalidate(8, $pileData = value));
  const displayQuantityStore = item.displayQuantity;
  component_subscribe($$self, displayQuantityStore, (value) => $$invalidate(20, $displayQuantityStore = value));
  const infiniteQuantityStore = item.infiniteQuantity;
  component_subscribe($$self, infiniteQuantityStore, (value) => $$invalidate(19, $infiniteQuantityStore = value));
  const quantityStore = item.quantity;
  component_subscribe($$self, quantityStore, (value) => $$invalidate(18, $quantityStore = value));
  const itemFlagDataStore = item.itemFlagData;
  component_subscribe($$self, itemFlagDataStore, (value) => $$invalidate(21, $itemFlagDataStore = value));
  let showEditQuantity = false;
  store.actor.isOwner;
  !!store.recipient;
  function previewItem2(item2) {
    item2 = store.actor.items.get(item2.id);
    if (game.user.isGM || item2.permission[game.user.id] === 3) {
      return item2.sheet.render(true);
    }
    const cls = item2._getSheetClass();
    const sheet = new cls(item2, { editable: false });
    return sheet._render(true);
  }
  __name(previewItem2, "previewItem");
  const click_handler = /* @__PURE__ */ __name(() => {
    if (game.user.isGM)
      $$invalidate(1, showEditQuantity = true);
  }, "click_handler");
  function input_input_handler() {
    editQuantity = this.value;
    $$invalidate(2, editQuantity), $$invalidate(18, $quantityStore);
  }
  __name(input_input_handler, "input_input_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(1, showEditQuantity = false);
    item.updateQuantity(editQuantity);
  }, "change_handler");
  const keydown_handler2 = /* @__PURE__ */ __name((evt) => {
    if (evt.key === "Enter")
      $$invalidate(1, showEditQuantity = false);
  }, "keydown_handler");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2097152) {
      $$invalidate(6, itemFlagData = $itemFlagDataStore);
    }
    if ($$self.$$.dirty & 1048576) {
      $$invalidate(5, displayQuantity = $displayQuantityStore);
    }
    if ($$self.$$.dirty & 524288) {
      $$invalidate(4, infiniteQuantity = $infiniteQuantityStore);
    }
    if ($$self.$$.dirty & 262144) {
      $$invalidate(3, quantity = $quantityStore);
    }
    if ($$self.$$.dirty & 262144) {
      $$invalidate(2, editQuantity = $quantityStore);
    }
  };
  return [
    item,
    showEditQuantity,
    editQuantity,
    quantity,
    infiniteQuantity,
    displayQuantity,
    itemFlagData,
    $itemImage,
    $pileData,
    $itemName,
    itemName,
    itemImage,
    pileData,
    displayQuantityStore,
    infiniteQuantityStore,
    quantityStore,
    itemFlagDataStore,
    previewItem2,
    $quantityStore,
    $infiniteQuantityStore,
    $displayQuantityStore,
    $itemFlagDataStore,
    $$scope,
    slots,
    click_handler,
    input_input_handler,
    change_handler,
    keydown_handler2
  ];
}
__name(instance$g, "instance$g");
class ItemEntry extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, { item: 0 });
  }
}
__name(ItemEntry, "ItemEntry");
const MerchantItemBuyEntry_svelte_svelte_type_style_lang = "";
function create_if_block_2$7(ctx) {
  let t0;
  let span0;
  let i0;
  let t1;
  let span1;
  let i1;
  let mounted;
  let dispose;
  let if_block = game.user.isGM && create_if_block_3$7(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      span0 = element("span");
      i0 = element("i");
      t1 = space();
      span1 = element("span");
      i1 = element("i");
      attr(i0, "class", "fas");
      toggle_class(i0, "fa-eye", !ctx[2].hidden);
      toggle_class(i0, "fa-eye-slash", ctx[2].hidden);
      attr(span0, "class", "item-piles-clickable-link svelte-1lotooc");
      attr(i1, "class", "fas");
      toggle_class(i1, "fa-store", !ctx[2].notForSale);
      toggle_class(i1, "fa-store-slash", ctx[2].notForSale);
      attr(span1, "class", "item-piles-clickable-link svelte-1lotooc");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, span0, anchor);
      append(span0, i0);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      append(span1, i1);
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[13]),
          listen(span1, "click", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (game.user.isGM)
        if_block.p(ctx2, dirty);
      if (dirty & 4) {
        toggle_class(i0, "fa-eye", !ctx2[2].hidden);
      }
      if (dirty & 4) {
        toggle_class(i0, "fa-eye-slash", ctx2[2].hidden);
      }
      if (dirty & 4) {
        toggle_class(i1, "fa-store", !ctx2[2].notForSale);
      }
      if (dirty & 4) {
        toggle_class(i1, "fa-store-slash", ctx2[2].notForSale);
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_2$7, "create_if_block_2$7");
function create_if_block_3$7(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      span.innerHTML = `<i class="fas fa-cog"></i>`;
      attr(span, "class", "item-piles-clickable-link svelte-1lotooc");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "click", ctx[12]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$7, "create_if_block_3$7");
function create_if_block$c(ctx) {
  let span;
  let i;
  let t;
  let mounted;
  let dispose;
  let if_block = !ctx[7] && create_if_block_1$7();
  return {
    c() {
      span = element("span");
      i = element("i");
      t = space();
      if (if_block)
        if_block.c();
      attr(i, "class", "fas fa-shopping-cart");
      attr(span, "class", "svelte-1lotooc");
      toggle_class(span, "item-piles-clickable-link", !ctx[2].notForSale || game.user.isGM);
      toggle_class(span, "item-piles-clickable-link-disabled", ctx[1] <= 0 || ctx[2].notForSale && !game.user.isGM);
      toggle_class(span, "buy-button", ctx[7]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, i);
      append(span, t);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = listen(span, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[7])
        if_block.p(ctx2, dirty);
      if (dirty & 4) {
        toggle_class(span, "item-piles-clickable-link", !ctx2[2].notForSale || game.user.isGM);
      }
      if (dirty & 6) {
        toggle_class(span, "item-piles-clickable-link-disabled", ctx2[1] <= 0 || ctx2[2].notForSale && !game.user.isGM);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$c, "create_if_block$c");
function create_if_block_1$7(ctx) {
  let t_value = localize("ITEM-PILES.Merchant.Buy") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_if_block_1$7, "create_if_block_1$7");
function create_fragment$f(ctx) {
  let div1;
  let itementry;
  let t0;
  let priceselector;
  let t1;
  let div0;
  let t2;
  let div1_transition;
  let current;
  itementry = new ItemEntry({ props: { item: ctx[0] } });
  priceselector = new PriceSelector({ props: { item: ctx[0] } });
  let if_block0 = ctx[7] && create_if_block_2$7(ctx);
  let if_block1 = ctx[8] && create_if_block$c(ctx);
  return {
    c() {
      div1 = element("div");
      create_component(itementry.$$.fragment);
      t0 = space();
      create_component(priceselector.$$.fragment);
      t1 = space();
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "item-piles-flexrow sidebar-buttons svelte-1lotooc");
      attr(div1, "class", "item-piles-flexrow item-piles-item-row item-piles-odd-color svelte-1lotooc");
      set_style(div1, "flex", "1 0 auto");
      toggle_class(div1, "merchant-item-hidden", ctx[2].hidden);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(itementry, div1, null);
      append(div1, t0);
      mount_component(priceselector, div1, null);
      append(div1, t1);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const itementry_changes = {};
      if (dirty & 1)
        itementry_changes.item = ctx2[0];
      itementry.$set(itementry_changes);
      const priceselector_changes = {};
      if (dirty & 1)
        priceselector_changes.item = ctx2[0];
      priceselector.$set(priceselector_changes);
      if (ctx2[7])
        if_block0.p(ctx2, dirty);
      if (ctx2[8])
        if_block1.p(ctx2, dirty);
      if (!current || dirty & 4) {
        toggle_class(div1, "merchant-item-hidden", ctx2[2].hidden);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(itementry.$$.fragment, local);
      transition_in(priceselector.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, { duration: 250 }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(itementry.$$.fragment, local);
      transition_out(priceselector.$$.fragment, local);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: 250 }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(itementry);
      destroy_component(priceselector);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching && div1_transition)
        div1_transition.end();
    }
  };
}
__name(create_fragment$f, "create_fragment$f");
function instance$f($$self, $$props, $$invalidate) {
  let itemFlagData;
  let quantity;
  let $quantityStore;
  let $displayQuantityStore;
  let $itemFlagDataStore;
  let { item } = $$props;
  item.name;
  item.img;
  const store = item.store;
  store.pileData;
  const displayQuantityStore = item.displayQuantity;
  component_subscribe($$self, displayQuantityStore, (value) => $$invalidate(10, $displayQuantityStore = value));
  const quantityStore = item.quantity;
  component_subscribe($$self, quantityStore, (value) => $$invalidate(9, $quantityStore = value));
  const itemFlagDataStore = item.itemFlagData;
  component_subscribe($$self, itemFlagDataStore, (value) => $$invalidate(11, $itemFlagDataStore = value));
  const displayControlButtons = store.actor.isOwner;
  const displayBuyButton = !!store.recipient;
  const click_handler = /* @__PURE__ */ __name(() => {
    ItemEditor.show(item.item);
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    $$invalidate(2, itemFlagData.hidden = !itemFlagData.hidden, itemFlagData);
    item.updateItemFlagData();
  }, "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    $$invalidate(2, itemFlagData.notForSale = !itemFlagData.notForSale, itemFlagData);
    item.updateItemFlagData();
  }, "click_handler_2");
  const click_handler_32 = /* @__PURE__ */ __name(() => {
    if (quantity <= 0 || itemFlagData.notForSale && !game.user.isGM)
      return;
    store.tradeItem(item);
  }, "click_handler_3");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $$invalidate(2, itemFlagData = $itemFlagDataStore);
    }
    if ($$self.$$.dirty & 1024)
      ;
    if ($$self.$$.dirty & 512) {
      $$invalidate(1, quantity = $quantityStore);
    }
    if ($$self.$$.dirty & 512)
      ;
  };
  return [
    item,
    quantity,
    itemFlagData,
    store,
    displayQuantityStore,
    quantityStore,
    itemFlagDataStore,
    displayControlButtons,
    displayBuyButton,
    $quantityStore,
    $displayQuantityStore,
    $itemFlagDataStore,
    click_handler,
    click_handler_1,
    click_handler_22,
    click_handler_32
  ];
}
__name(instance$f, "instance$f");
class MerchantItemBuyEntry extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, { item: 0 });
  }
}
__name(MerchantItemBuyEntry, "MerchantItemBuyEntry");
const MerchantBuyTab_svelte_svelte_type_style_lang = "";
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[27] = list;
  child_ctx[28] = i;
  return child_ctx;
}
__name(get_each_context$6, "get_each_context$6");
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  return child_ctx;
}
__name(get_each_context_1$2, "get_each_context_1$2");
function get_each_context_2$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
__name(get_each_context_2$1, "get_each_context_2$1");
function create_if_block_6$1(ctx) {
  let select;
  let option;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value_2 = ctx[3];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[26].type, "get_key");
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
  }
  return {
    c() {
      select = element("select");
      option = element("option");
      option.textContent = `${localize("ITEM-PILES.Merchant.AllTypes")}`;
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      option.__value = "all";
      option.value = option.__value;
      set_style(select, "flex", "0 1 auto");
      set_style(select, "margin-left", "0.4rem");
      set_style(select, "height", "26px");
      if (ctx[5] === void 0)
        add_render_callback(() => ctx[21].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[5]);
      if (!mounted) {
        dispose = listen(select, "change", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8) {
        each_value_2 = ctx2[3];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, select, destroy_block, create_each_block_2$1, null, get_each_context_2$1);
      }
      if (dirty[0] & 40) {
        select_option(select, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_6$1, "create_if_block_6$1");
function create_each_block_2$1(key_1, ctx) {
  let option;
  let t_value = localize(ctx[26].label) + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[26].type;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 8 && t_value !== (t_value = localize(ctx[26].label) + ""))
        set_data(t, t_value);
      if (dirty[0] & 8 && option_value_value !== (option_value_value = ctx[26].type)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block_2$1, "create_each_block_2$1");
function create_if_block_4$5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[7][ctx[26].type] && create_if_block_5$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7][ctx2[26].type]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 132) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_4$5, "create_if_block_4$5");
function create_if_block_5$2(ctx) {
  let t0_value = localize("ITEM-PILES.Merchant.Override") + "";
  let t0;
  let t1;
  let input;
  let t2;
  let sliderinput;
  let updating_value;
  let current;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[22].call(input, ctx[26]);
  }
  __name(input_change_handler, "input_change_handler");
  function sliderinput_value_binding(value) {
    ctx[23](value, ctx[26]);
  }
  __name(sliderinput_value_binding, "sliderinput_value_binding");
  let sliderinput_props = {};
  if (ctx[7][ctx[26].type].buyPriceModifier !== void 0) {
    sliderinput_props.value = ctx[7][ctx[26].type].buyPriceModifier;
  }
  sliderinput = new SliderInput({ props: sliderinput_props });
  binding_callbacks.push(() => bind$1(sliderinput, "value", sliderinput_value_binding));
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(":\r\n            ");
      input = element("input");
      t2 = space();
      create_component(sliderinput.$$.fragment);
      attr(input, "type", "checkbox");
      attr(input, "class", "svelte-lcxw4g");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, input, anchor);
      input.checked = ctx[7][ctx[26].type].override;
      insert(target, t2, anchor);
      mount_component(sliderinput, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", input_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 132) {
        input.checked = ctx[7][ctx[26].type].override;
      }
      const sliderinput_changes = {};
      if (!updating_value && dirty[0] & 132) {
        updating_value = true;
        sliderinput_changes.value = ctx[7][ctx[26].type].buyPriceModifier;
        add_flush_callback(() => updating_value = false);
      }
      sliderinput.$set(sliderinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sliderinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sliderinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(input);
      if (detaching)
        detach(t2);
      destroy_component(sliderinput, detaching);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_5$2, "create_if_block_5$2");
function create_if_block_2$6(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[7][ctx2[26].type])
      return create_if_block_3$6;
    return create_else_block_1$1;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_2$6, "create_if_block_2$6");
function create_else_block_1$1(ctx) {
  let i;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[25](ctx[26]);
  }
  __name(click_handler_1, "click_handler_1");
  return {
    c() {
      i = element("i");
      attr(i, "class", "fas fa-plus item-piles-clickable-green");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      if (!mounted) {
        dispose = listen(i, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(i);
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block_1$1, "create_else_block_1$1");
function create_if_block_3$6(ctx) {
  let i;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[24](ctx[26]);
  }
  __name(click_handler, "click_handler");
  return {
    c() {
      i = element("i");
      attr(i, "class", "fas fa-times item-piles-clickable-red");
    },
    m(target, anchor) {
      insert(target, i, anchor);
      if (!mounted) {
        dispose = listen(i, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(i);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$6, "create_if_block_3$6");
function create_each_block_1$2(key_1, ctx) {
  let first;
  let merchantitembuyentry;
  let current;
  merchantitembuyentry = new MerchantItemBuyEntry({ props: { item: ctx[29] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(merchantitembuyentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(merchantitembuyentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const merchantitembuyentry_changes = {};
      if (dirty[0] & 260)
        merchantitembuyentry_changes.item = ctx[29];
      merchantitembuyentry.$set(merchantitembuyentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantitembuyentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantitembuyentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(merchantitembuyentry, detaching);
    }
  };
}
__name(create_each_block_1$2, "create_each_block_1$2");
function create_each_block$6(key_1, ctx) {
  let div4;
  let h3;
  let div0;
  let t0_value = localize(ctx[26].label) + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let div2;
  let t3;
  let div3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div4_intro;
  let current;
  let if_block0 = ctx[6] && create_if_block_4$5(ctx);
  let if_block1 = ctx[6] && create_if_block_2$6(ctx);
  let each_value_1 = ctx[8][ctx[26].type].items;
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[29].id, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$2(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div4 = element("div");
      h3 = element("h3");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div1, "class", "price-header svelte-lcxw4g");
      set_style(div1, "font-size", "0.75rem");
      set_style(div2, "flex", "0 1 auto");
      attr(h3, "class", "merchant-item-group-type item-piles-flexrow svelte-lcxw4g");
      attr(div3, "class", "item-piles-items-list svelte-lcxw4g");
      this.first = div4;
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, h3);
      append(h3, div0);
      append(div0, t0);
      append(h3, t1);
      append(h3, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(h3, t2);
      append(h3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div4, t3);
      append(div4, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div3, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & 4) && t0_value !== (t0_value = localize(ctx[26].label) + ""))
        set_data(t0, t0_value);
      if (ctx[6]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$5(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[6]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$6(ctx);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 260) {
        each_value_1 = ctx[8][ctx[26].type].items;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div3, outro_and_destroy_block, create_each_block_1$2, null, get_each_context_1$2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        if (!div4_intro) {
          add_render_callback(() => {
            div4_intro = create_in_transition(div4, fade, { duration: 150 });
            div4_intro.start();
          });
        }
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_each_block$6, "create_each_block$6");
function create_if_block$b(ctx) {
  let div;
  let span;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[9].length)
      return create_if_block_1$6;
    return create_else_block$2;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      span = element("span");
      if_block.c();
      attr(span, "class", "align-center-row");
      set_style(span, "font-size", "1.25rem");
      set_style(span, "opacity", "0.8");
      set_style(div, "height", "calc(100% - 51px)");
      attr(div, "class", "item-piles-flexcol align-center-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
__name(create_if_block$b, "create_if_block$b");
function create_else_block$2(ctx) {
  let t_value = localize("ITEM-PILES.Merchant.NoItemsForSale") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_else_block$2, "create_else_block$2");
function create_if_block_1$6(ctx) {
  let t_value = localize("ITEM-PILES.Merchant.NoMatchFound") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_if_block_1$6, "create_if_block_1$6");
function create_fragment$e(ctx) {
  let div;
  let input;
  let t0;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3].length > 1 && create_if_block_6$1(ctx);
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[26].type, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
  }
  let if_block1 = !ctx[1].length && create_if_block$b(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(input, "type", "text");
      attr(input, "placeholder", "Type to search...");
      attr(div, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[4]);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && input.value !== ctx2[4]) {
        set_input_value(input, ctx2[4]);
      }
      if (ctx2[3].length > 1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$1(ctx2);
          if_block0.c();
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 453) {
        each_value = ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t2.parentNode, outro_and_destroy_block, create_each_block$6, t2, get_each_context$6);
        check_outros();
      }
      if (!ctx2[1].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$b(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$e, "create_fragment$e");
function instance$e($$self, $$props, $$invalidate) {
  let categoryDropDown;
  let categories;
  let $categoryStore;
  let $itemCategoriesStore;
  let $searchStore;
  let $typeFilterStore;
  let $editPrices;
  let $priceModifiersPerType;
  let $itemsPerCategoryStore;
  let $visibleItemsStore;
  let { store } = $$props;
  let { categoryFilter } = $$props;
  const searchStore = store.search;
  component_subscribe($$self, searchStore, (value) => $$invalidate(4, $searchStore = value));
  const visibleItemsStore = store.visibleItems;
  component_subscribe($$self, visibleItemsStore, (value) => $$invalidate(9, $visibleItemsStore = value));
  const itemsPerCategoryStore = store.itemsPerCategory;
  component_subscribe($$self, itemsPerCategoryStore, (value) => $$invalidate(8, $itemsPerCategoryStore = value));
  const categoryStore = store.categories;
  component_subscribe($$self, categoryStore, (value) => $$invalidate(1, $categoryStore = value));
  const priceModifiersPerType = store.priceModifiersPerType;
  component_subscribe($$self, priceModifiersPerType, (value) => $$invalidate(7, $priceModifiersPerType = value));
  const itemCategoriesStore = store.itemCategories;
  component_subscribe($$self, itemCategoriesStore, (value) => $$invalidate(19, $itemCategoriesStore = value));
  const typeFilterStore = store.typeFilter;
  component_subscribe($$self, typeFilterStore, (value) => $$invalidate(5, $typeFilterStore = value));
  const editPrices = store.editPrices;
  component_subscribe($$self, editPrices, (value) => $$invalidate(6, $editPrices = value));
  function input_input_handler() {
    $searchStore = this.value;
    searchStore.set($searchStore);
  }
  __name(input_input_handler, "input_input_handler");
  function select_change_handler() {
    $typeFilterStore = select_value(this);
    typeFilterStore.set($typeFilterStore);
    $$invalidate(3, categoryDropDown), $$invalidate(19, $itemCategoriesStore), $$invalidate(18, categoryFilter);
  }
  __name(select_change_handler, "select_change_handler");
  function input_change_handler(category) {
    $priceModifiersPerType[category.type].override = this.checked;
    priceModifiersPerType.set($priceModifiersPerType);
  }
  __name(input_change_handler, "input_change_handler");
  function sliderinput_value_binding(value, category) {
    if ($$self.$$.not_equal($priceModifiersPerType[category.type].buyPriceModifier, value)) {
      $priceModifiersPerType[category.type].buyPriceModifier = value;
      priceModifiersPerType.set($priceModifiersPerType);
    }
  }
  __name(sliderinput_value_binding, "sliderinput_value_binding");
  const click_handler = /* @__PURE__ */ __name((category) => {
    store.removeOverrideTypePrice(category.type);
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name((category) => {
    store.addOverrideTypePrice(category.type);
  }, "click_handler_1");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
    if ("categoryFilter" in $$props2)
      $$invalidate(18, categoryFilter = $$props2.categoryFilter);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 786432) {
      $$invalidate(3, categoryDropDown = $itemCategoriesStore.filter((category) => categoryFilter(category)));
    }
    if ($$self.$$.dirty[0] & 262146) {
      $$invalidate(2, categories = $categoryStore.filter((category) => categoryFilter(category)));
    }
  };
  return [
    store,
    $categoryStore,
    categories,
    categoryDropDown,
    $searchStore,
    $typeFilterStore,
    $editPrices,
    $priceModifiersPerType,
    $itemsPerCategoryStore,
    $visibleItemsStore,
    searchStore,
    visibleItemsStore,
    itemsPerCategoryStore,
    categoryStore,
    priceModifiersPerType,
    itemCategoriesStore,
    typeFilterStore,
    editPrices,
    categoryFilter,
    $itemCategoriesStore,
    input_input_handler,
    select_change_handler,
    input_change_handler,
    sliderinput_value_binding,
    click_handler,
    click_handler_1
  ];
}
__name(instance$e, "instance$e");
class MerchantBuyTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, { store: 0, categoryFilter: 18 }, null, [-1, -1]);
  }
}
__name(MerchantBuyTab, "MerchantBuyTab");
const MerchantItemSellEntry_svelte_svelte_type_style_lang = "";
function create_if_block_2$5(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].infiniteQuantity)
      return create_if_block_3$5;
    if (!ctx2[1])
      return create_if_block_4$4;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_if_block_2$5, "create_if_block_2$5");
function create_if_block_4$4(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text("(x");
      t1 = text(ctx[4]);
      t2 = text(")");
      attr(span, "class", "item-piles-small-text");
      toggle_class(span, "item-piles-clickable-link", game.user.isGM);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      if (!mounted) {
        dispose = listen(span, "click", ctx[22]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t1, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_4$4, "create_if_block_4$4");
function create_if_block_3$5(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "(\u221E)";
      attr(span, "class", "item-piles-small-text");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
__name(create_if_block_3$5, "create_if_block_3$5");
function create_if_block_1$5(ctx) {
  let div1;
  let div0;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "text");
      input.autofocus = true;
      attr(div0, "class", "item-piles-quantity-input-container");
      attr(div1, "class", "item-piles-quantity-container");
      set_style(div1, "flex", "0 1 50px");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      set_input_value(input, ctx[3]);
      input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[23]),
          listen(input, "change", ctx[24]),
          listen(input, "keydown", ctx[25])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$5, "create_if_block_1$5");
function create_if_block$a(ctx) {
  let span;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Merchant.Sell") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-hand-holding-usd");
      attr(span, "class", "svelte-1lotooc");
      toggle_class(span, "item-piles-clickable-link", ctx[4] > 0 && !ctx[6].cantBeSoldToMerchants);
      toggle_class(span, "item-piles-clickable-link-disabled", ctx[4] <= 0 || ctx[6].cantBeSoldToMerchants);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, i);
      append(span, t0);
      append(span, t1);
      if (!mounted) {
        dispose = listen(span, "click", ctx[26]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 80) {
        toggle_class(span, "item-piles-clickable-link", ctx2[4] > 0 && !ctx2[6].cantBeSoldToMerchants);
      }
      if (dirty & 80) {
        toggle_class(span, "item-piles-clickable-link-disabled", ctx2[4] <= 0 || ctx2[6].cantBeSoldToMerchants);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$a, "create_if_block$a");
function create_fragment$d(ctx) {
  let div4;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let div1;
  let a;
  let t1;
  let t2;
  let t3;
  let t4;
  let priceselector;
  let t5;
  let div3;
  let div4_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_2$5(ctx);
  let if_block1 = ctx[1] && create_if_block_1$5(ctx);
  priceselector = new PriceSelector({ props: { item: ctx[0] } });
  let if_block2 = ctx[16] && create_if_block$a(ctx);
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      a = element("a");
      t1 = text(ctx[8]);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      create_component(priceselector.$$.fragment);
      t5 = space();
      div3 = element("div");
      if (if_block2)
        if_block2.c();
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[7]))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container svelte-1lotooc");
      toggle_class(div0, "not-for-sale", !ctx[4] || ctx[6].cantBeSoldToMerchants);
      toggle_class(a, "item-piles-clickable", ctx[2]);
      attr(div1, "class", "item-piles-name-container svelte-1lotooc");
      attr(div2, "class", "item-piles-name item-piles-text svelte-1lotooc");
      attr(div3, "class", "item-piles-flexrow sidebar-buttons svelte-1lotooc");
      attr(div4, "class", "item-piles-flexrow item-piles-item-row item-piles-odd-color svelte-1lotooc");
      set_style(div4, "flex", "1 0 auto");
      toggle_class(div4, "merchant-item-hidden", ctx[6].hidden);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, img);
      append(div4, t0);
      append(div4, div2);
      append(div2, div1);
      append(div1, a);
      append(a, t1);
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      append(div4, t4);
      mount_component(priceselector, div4, null);
      append(div4, t5);
      append(div4, div3);
      if (if_block2)
        if_block2.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[17](ctx[0])))
            ctx[17](ctx[0]).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & 128 && !src_url_equal(img.src, img_src_value = ctx[7])) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & 80) {
        toggle_class(div0, "not-for-sale", !ctx[4] || ctx[6].cantBeSoldToMerchants);
      }
      if (!current || dirty & 256)
        set_data(t1, ctx[8]);
      if (!current || dirty & 4) {
        toggle_class(a, "item-piles-clickable", ctx[2]);
      }
      if (ctx[5]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_2$5(ctx);
          if_block0.c();
          if_block0.m(div1, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[1]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_1$5(ctx);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const priceselector_changes = {};
      if (dirty & 1)
        priceselector_changes.item = ctx[0];
      priceselector.$set(priceselector_changes);
      if (ctx[16])
        if_block2.p(ctx, dirty);
      if (!current || dirty & 64) {
        toggle_class(div4, "merchant-item-hidden", ctx[6].hidden);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(priceselector.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!div4_transition)
            div4_transition = create_bidirectional_transition(div4, fade, { duration: 250 }, true);
          div4_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(priceselector.$$.fragment, local);
      if (local) {
        if (!div4_transition)
          div4_transition = create_bidirectional_transition(div4, fade, { duration: 250 }, false);
        div4_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(priceselector);
      if (if_block2)
        if_block2.d();
      if (detaching && div4_transition)
        div4_transition.end();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$d, "create_fragment$d");
function instance$d($$self, $$props, $$invalidate) {
  let itemFlagData;
  let displayQuantity;
  let quantity;
  let editQuantity;
  let canInspectItems;
  let $pileData;
  let $quantityStore;
  let $displayQuantityStore;
  let $itemFlagDataStore;
  let $itemImage;
  let $itemName;
  let { item } = $$props;
  const store = item.store;
  const itemName = item.name;
  component_subscribe($$self, itemName, (value) => $$invalidate(8, $itemName = value));
  const itemImage = item.img;
  component_subscribe($$self, itemImage, (value) => $$invalidate(7, $itemImage = value));
  const pileData = store.pileData;
  component_subscribe($$self, pileData, (value) => $$invalidate(18, $pileData = value));
  const displayQuantityStore = item.displayQuantity;
  component_subscribe($$self, displayQuantityStore, (value) => $$invalidate(20, $displayQuantityStore = value));
  const quantityStore = item.quantity;
  component_subscribe($$self, quantityStore, (value) => $$invalidate(19, $quantityStore = value));
  const itemFlagDataStore = item.itemFlagData;
  component_subscribe($$self, itemFlagDataStore, (value) => $$invalidate(21, $itemFlagDataStore = value));
  let showEditQuantity = false;
  const displayBuyButton = !!store.recipient;
  function previewItem2(item2) {
    if (!canInspectItems)
      return;
    item2 = store.actor.items.get(item2.id);
    if (game.user.isGM || item2.permission[game.user.id] === 3) {
      return item2.sheet.render(true);
    }
    const cls = item2._getSheetClass();
    const sheet = new cls(item2, { editable: false });
    return sheet._render(true);
  }
  __name(previewItem2, "previewItem");
  const click_handler = /* @__PURE__ */ __name(() => {
    if (game.user.isGM)
      $$invalidate(1, showEditQuantity = true);
  }, "click_handler");
  function input_input_handler() {
    editQuantity = this.value;
    $$invalidate(3, editQuantity), $$invalidate(19, $quantityStore);
  }
  __name(input_input_handler, "input_input_handler");
  const change_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(1, showEditQuantity = false);
    item.updateQuantity(editQuantity);
  }, "change_handler");
  const keydown_handler2 = /* @__PURE__ */ __name((evt) => {
    if (evt.key === "Enter")
      $$invalidate(1, showEditQuantity = false);
  }, "keydown_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    if (quantity <= 0 || itemFlagData.cantBeSoldToMerchants)
      return;
    store.tradeItem(item, true);
  }, "click_handler_1");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2097152) {
      $$invalidate(6, itemFlagData = $itemFlagDataStore);
    }
    if ($$self.$$.dirty & 1048576) {
      $$invalidate(5, displayQuantity = $displayQuantityStore);
    }
    if ($$self.$$.dirty & 524288) {
      $$invalidate(4, quantity = $quantityStore);
    }
    if ($$self.$$.dirty & 524288) {
      $$invalidate(3, editQuantity = $quantityStore);
    }
    if ($$self.$$.dirty & 262144) {
      $$invalidate(2, canInspectItems = $pileData.canInspectItems || game.user.isGM);
    }
  };
  return [
    item,
    showEditQuantity,
    canInspectItems,
    editQuantity,
    quantity,
    displayQuantity,
    itemFlagData,
    $itemImage,
    $itemName,
    store,
    itemName,
    itemImage,
    pileData,
    displayQuantityStore,
    quantityStore,
    itemFlagDataStore,
    displayBuyButton,
    previewItem2,
    $pileData,
    $quantityStore,
    $displayQuantityStore,
    $itemFlagDataStore,
    click_handler,
    input_input_handler,
    change_handler,
    keydown_handler2,
    click_handler_1
  ];
}
__name(instance$d, "instance$d");
class MerchantItemSellEntry extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$d, safe_not_equal, { item: 0 });
  }
}
__name(MerchantItemSellEntry, "MerchantItemSellEntry");
const MerchantSellTab_svelte_svelte_type_style_lang = "";
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
}
__name(get_each_context$5, "get_each_context$5");
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
__name(get_each_context_1$1, "get_each_context_1$1");
function create_each_block_1$1(key_1, ctx) {
  let first;
  let merchantitemsellentry;
  let current;
  merchantitemsellentry = new MerchantItemSellEntry({ props: { item: ctx[11] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(merchantitemsellentry.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(merchantitemsellentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const merchantitemsellentry_changes = {};
      if (dirty & 3)
        merchantitemsellentry_changes.item = ctx[11];
      merchantitemsellentry.$set(merchantitemsellentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantitemsellentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantitemsellentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(merchantitemsellentry, detaching);
    }
  };
}
__name(create_each_block_1$1, "create_each_block_1$1");
function create_each_block$5(key_1, ctx) {
  let div2;
  let h3;
  let div0;
  let t0_value = localize(ctx[8].label) + "";
  let t0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div2_intro;
  let current;
  let each_value_1 = ctx[1][ctx[8].type].items;
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[11].id, "get_key");
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      h3 = element("h3");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h3, "class", "merchant-item-group-type item-piles-flexrow svelte-qd2k4s");
      attr(div1, "class", "item-piles-items-list svelte-qd2k4s");
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      append(h3, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = localize(ctx[8].label) + ""))
        set_data(t0, t0_value);
      if (dirty & 3) {
        each_value_1 = ctx[1][ctx[8].type].items;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        if (!div2_intro) {
          add_render_callback(() => {
            div2_intro = create_in_transition(div2, fade, { duration: 150 });
            div2_intro.start();
          });
        }
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_each_block$5, "create_each_block$5");
function create_if_block$9(ctx) {
  let div;
  let span;
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Merchant.NoItemsToSell")}`;
      attr(span, "class", "align-center-row");
      set_style(span, "font-size", "1.25rem");
      set_style(span, "opacity", "0.8");
      set_style(span, "text-align", "center");
      set_style(div, "height", "100%");
      attr(div, "class", "item-piles-flexcol align-center-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block$9, "create_if_block$9");
function create_fragment$c(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let if_block_anchor;
  let current;
  let each_value = ctx[0];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[8].type, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
  }
  let if_block = !ctx[0].length && create_if_block$9();
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block$5, t, get_each_context$5);
        check_outros();
      }
      if (!ctx2[0].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$9();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_fragment$c, "create_fragment$c");
function instance$c($$self, $$props, $$invalidate) {
  let $categoryStore;
  let $itemsPerCategoryStore;
  let { store } = $$props;
  store.search;
  const itemsPerCategoryStore = store.itemsPerCategory;
  component_subscribe($$self, itemsPerCategoryStore, (value) => $$invalidate(1, $itemsPerCategoryStore = value));
  const categoryStore = store.categories;
  component_subscribe($$self, categoryStore, (value) => $$invalidate(0, $categoryStore = value));
  store.priceModifiersPerType;
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(4, store = $$props2.store);
  };
  return [
    $categoryStore,
    $itemsPerCategoryStore,
    itemsPerCategoryStore,
    categoryStore,
    store
  ];
}
__name(instance$c, "instance$c");
class MerchantSellTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, { store: 4 });
  }
}
__name(MerchantSellTab, "MerchantSellTab");
const MerchantPopulateItemsTab_svelte_svelte_type_style_lang = "";
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i];
  child_ctx[47] = list;
  child_ctx[48] = i;
  return child_ctx;
}
__name(get_each_context$4, "get_each_context$4");
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i][0];
  child_ctx[50] = list[i][1];
  return child_ctx;
}
__name(get_each_context_1, "get_each_context_1");
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i];
  child_ctx[53] = list;
  child_ctx[54] = i;
  return child_ctx;
}
__name(get_each_context_2, "get_each_context_2");
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i];
  return child_ctx;
}
__name(get_each_context_3, "get_each_context_3");
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i];
  return child_ctx;
}
__name(get_each_context_4, "get_each_context_4");
function create_right_slot(ctx) {
  let button;
  let i;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[23](ctx[46]);
  }
  __name(click_handler, "click_handler");
  return {
    c() {
      button = element("button");
      i = element("i");
      attr(i, "class", "fas fa-trash svelte-1hoentp");
      attr(button, "slot", "right");
      attr(button, "class", "item-piles-rolled-item-button svelte-1hoentp");
      set_style(button, "color", "red");
      attr(button, "title", localize("ITEM-PILES.Merchant.RemoveItem"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_right_slot, "create_right_slot");
function create_each_block_4(key_1, ctx) {
  let div;
  let itementry;
  let current;
  itementry = new ItemEntry({
    props: {
      item: ctx[46],
      $$slots: { right: [create_right_slot] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      create_component(itementry.$$.fragment);
      attr(div, "class", "item-piles-flexrow item-piles-item-row item-piles-even-color");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(itementry, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const itementry_changes = {};
      if (dirty[0] & 64)
        itementry_changes.item = ctx[46];
      if (dirty[0] & 64 | dirty[1] & 268435456) {
        itementry_changes.$$scope = { dirty, ctx };
      }
      itementry.$set(itementry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(itementry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(itementry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(itementry);
    }
  };
}
__name(create_each_block_4, "create_each_block_4");
function create_if_block_6(ctx) {
  let button;
  let i;
  let t0;
  let t1_value = localize("ITEM-PILES.Merchant.ClearAllItems") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-trash");
      attr(button, "class", "item-piles-button svelte-1hoentp");
      set_style(button, "margin", "5px 0");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[24]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_6, "create_if_block_6");
function create_if_block_3$4(ctx) {
  let div2;
  let div1;
  let div0;
  let label;
  let t0;
  let label_for_value;
  let t1;
  let input;
  let input_id_value;
  let t2;
  let t3;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[29].call(input, ctx[53], ctx[54]);
  }
  __name(input_change_handler, "input_change_handler");
  function change_handler() {
    return ctx[30](ctx[50], ctx[53], ctx[54]);
  }
  __name(change_handler, "change_handler");
  let if_block0 = !ctx[50].addAll && create_if_block_5$1(ctx);
  let if_block1 = ctx[50].addAll && create_if_block_4$3(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text("Add all items:");
      t1 = space();
      input = element("input");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      set_style(label, "flex", "0 1 auto");
      set_style(label, "margin-right", "5px");
      attr(label, "for", label_for_value = "table-id-" + ctx[50].id);
      set_style(input, "width", "15px");
      set_style(input, "height", "15px");
      set_style(input, "margin", "0");
      set_style(input, "flex", "0");
      attr(input, "id", input_id_value = "table-id-" + ctx[50].id);
      attr(input, "type", "checkbox");
      attr(div0, "class", "item-piles-flexrow");
      set_style(div0, "align-items", "center");
      set_style(div0, "flex", "0 1 auto");
      set_style(div0, "min-height", "26px");
      attr(div1, "class", "item-piles-flexrow");
      attr(div2, "class", "item-piles-flexcol");
      set_style(div2, "margin-top", "5px");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, label);
      append(label, t0);
      append(div0, t1);
      append(div0, input);
      input.checked = ctx[50].addAll;
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div2, t3);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(input, "change", change_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 4 && label_for_value !== (label_for_value = "table-id-" + ctx[50].id)) {
        attr(label, "for", label_for_value);
      }
      if (!current || dirty[0] & 4 && input_id_value !== (input_id_value = "table-id-" + ctx[50].id)) {
        attr(input, "id", input_id_value);
      }
      if (dirty[0] & 4) {
        input.checked = ctx[50].addAll;
      }
      if (!ctx[50].addAll) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_5$1(ctx);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[50].addAll) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_4$3(ctx);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: quintOut }, true);
        div2_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div2_transition)
        div2_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: quintOut }, false);
      div2_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$4, "create_if_block_3$4");
function create_if_block_5$1(ctx) {
  let div;
  let label;
  let t1;
  let input;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[31].call(input, ctx[53], ctx[54]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Time to roll on table:";
      t1 = space();
      input = element("input");
      set_style(label, "margin-right", "5px");
      set_style(label, "text-align", "right");
      attr(input, "type", "text");
      attr(input, "placeholder", "2d6+4");
      set_style(input, "height", "20px");
      set_style(input, "margin", "3px");
      set_style(input, "max-width", "50px");
      set_style(input, "font-size", "0.75rem");
      attr(div, "class", "item-piles-flexrow item-piles-item-row");
      set_style(div, "align-items", "center");
      set_style(div, "flex", "1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      set_input_value(input, ctx[50].timesToRoll);
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 4 && input.value !== ctx[50].timesToRoll) {
        set_input_value(input, ctx[50].timesToRoll);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_5$1, "create_if_block_5$1");
function create_if_block_4$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value_3 = ctx[3][ctx[50].id].items;
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[46].id, "get_key");
  for (let i = 0; i < each_value_3.length; i += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_3(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 12) {
        each_value_3 = ctx2[3][ctx2[50].id].items;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block_3, each_1_anchor, get_each_context_3);
      }
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
__name(create_if_block_4$3, "create_if_block_4$3");
function create_each_block_3(key_1, ctx) {
  let div5;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let div2;
  let div1;
  let a;
  let t1_value = ctx[46].text + "";
  let t1;
  let t2;
  let div4;
  let div3;
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  function click_handler_6() {
    return ctx[32](ctx[46]);
  }
  __name(click_handler_6, "click_handler_6");
  function change_handler_1(...args) {
    return ctx[33](ctx[50], ctx[46], ctx[53], ctx[54], ...args);
  }
  __name(change_handler_1, "change_handler_1");
  return {
    key: key_1,
    first: null,
    c() {
      div5 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      a = element("a");
      t1 = text(t1_value);
      t2 = space();
      div4 = element("div");
      div3 = element("div");
      input = element("input");
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[46].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      attr(a, "class", "item-piles-clickable");
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name item-piles-text svelte-1hoentp");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "text");
      input.value = input_value_value = ctx[50]?.items?.[ctx[46].id] ?? "1d4";
      attr(div3, "class", "item-piles-quantity-input-container svelte-1hoentp");
      attr(div4, "class", "item-piles-quantity-container svelte-1hoentp");
      set_style(div4, "flex", "0 1 75px");
      attr(div5, "class", "item-piles-flexrow item-piles-item-row item-piles-odd-color");
      this.first = div5;
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, img);
      append(div5, t0);
      append(div5, div2);
      append(div2, div1);
      append(div1, a);
      append(a, t1);
      append(div5, t2);
      append(div5, div4);
      append(div4, div3);
      append(div3, input);
      if (!mounted) {
        dispose = [
          listen(a, "click", click_handler_6),
          listen(input, "change", change_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 12 && !src_url_equal(img.src, img_src_value = ctx[46].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & 12 && t1_value !== (t1_value = ctx[46].text + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 12 && input_value_value !== (input_value_value = ctx[50]?.items?.[ctx[46].id] ?? "1d4") && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block_3, "create_each_block_3");
function create_each_block_2(ctx) {
  let div2;
  let div1;
  let div0;
  let strong;
  let t0_value = ctx[3][ctx[50].id].name + "";
  let t0;
  let t1;
  let button0;
  let i0;
  let t2;
  let button1;
  let i1;
  let t3;
  let button2;
  let i2;
  let t4;
  let current;
  let mounted;
  let dispose;
  function click_handler_32() {
    return ctx[26](ctx[50]);
  }
  __name(click_handler_32, "click_handler_3");
  function click_handler_4() {
    return ctx[27](ctx[50], ctx[53], ctx[54]);
  }
  __name(click_handler_4, "click_handler_4");
  function click_handler_5() {
    return ctx[28](ctx[50], ctx[53], ctx[54]);
  }
  __name(click_handler_5, "click_handler_5");
  let if_block = ctx[50].open && create_if_block_3$4(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      strong = element("strong");
      t0 = text(t0_value);
      t1 = space();
      button0 = element("button");
      i0 = element("i");
      t2 = space();
      button1 = element("button");
      i1 = element("i");
      t3 = space();
      button2 = element("button");
      i2 = element("i");
      t4 = space();
      if (if_block)
        if_block.c();
      attr(i0, "class", "fas fa-trash svelte-1hoentp");
      set_style(i0, "color", "#de0e0e");
      attr(button0, "class", "item-piles-rolled-item-button svelte-1hoentp");
      attr(button0, "title", localize("ITEM-PILES.Merchant.ToolTipRemoveTable"));
      attr(i1, "class", "fas fa-cog svelte-1hoentp");
      attr(button1, "class", "item-piles-rolled-item-button svelte-1hoentp");
      attr(button1, "title", localize("ITEM-PILES.Merchant.TooltipConfigureTable"));
      attr(i2, "class", "fas fa-dice-d20 svelte-1hoentp");
      attr(button2, "class", "item-piles-rolled-item-button svelte-1hoentp");
      attr(button2, "title", localize("ITEM-PILES.Merchant.TooltipRollTable"));
      set_style(button2, "margin-right", "0");
      attr(div1, "class", "item-piles-flexrow");
      set_style(div1, "align-items", "center");
      attr(div2, "class", "item-piles-item-row item-piles-even-color");
      set_style(div2, "min-height", "28px");
      set_style(div2, "padding", "3px 3px 3px 5px");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, strong);
      append(strong, t0);
      append(div1, t1);
      append(div1, button0);
      append(button0, i0);
      append(div1, t2);
      append(div1, button1);
      append(button1, i1);
      append(div1, t3);
      append(div1, button2);
      append(button2, i2);
      append(div2, t4);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_32),
          listen(button1, "click", click_handler_4),
          listen(button2, "click", click_handler_5)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & 12) && t0_value !== (t0_value = ctx[3][ctx[50].id].name + ""))
        set_data(t0, t0_value);
      if (ctx[50].open) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block_2, "create_each_block_2");
function create_each_block_1(key_1, ctx) {
  let option;
  let t_value = ctx[50].name + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[49];
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1 && t_value !== (t_value = ctx[50].name + ""))
        set_data(t, t_value);
      if (dirty[0] & 1 && option_value_value !== (option_value_value = ctx[49])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_each_block_1, "create_each_block_1");
function create_if_block_2$4(ctx) {
  let option;
  return {
    c() {
      option = element("option");
      option.textContent = `${localize("ITEM-PILES.Merchant.NoRollTables")}`;
      option.__value = "";
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_if_block_2$4, "create_if_block_2$4");
function create_if_block$8(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div;
  let button0;
  let t1_value = localize("ITEM-PILES.Merchant.AddAll") + "";
  let t1;
  let t2;
  let i0;
  let t3;
  let button1;
  let i1;
  let mounted;
  let dispose;
  let each_value = ctx[7];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[46].documentId, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div = element("div");
      button0 = element("button");
      t1 = text(t1_value);
      t2 = space();
      i0 = element("i");
      t3 = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fas fa-arrow-left");
      attr(button0, "class", "item-piles-button svelte-1hoentp");
      attr(i1, "class", "fas fa-trash");
      attr(button1, "class", "item-piles-button svelte-1hoentp");
      set_style(button1, "color", "red");
      set_style(button1, "max-width", "30px");
      attr(button1, "title", localize("ITEM-PILES.Merchant.ToolTipRemoveAllRolledItems"));
      attr(div, "class", "item-piles-flexrow");
      set_style(div, "margin", "5px 0");
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t1);
      append(button0, t2);
      append(button0, i0);
      append(div, t3);
      append(div, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[41]),
          listen(button1, "click", ctx[42])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 49280) {
        each_value = ctx2[7];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t0.parentNode, destroy_block, create_each_block$4, t0, get_each_context$4);
      }
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$8, "create_if_block$8");
function create_if_block_1$4(ctx) {
  let small;
  let t0_value = ctx[46].price + "";
  let t0;
  let t1;
  let i;
  return {
    c() {
      small = element("small");
      t0 = text(t0_value);
      t1 = space();
      i = element("i");
      set_style(small, "white-space", "nowrap");
      attr(i, "class", "fas fa-times");
      set_style(i, "color", "#555");
      set_style(i, "font-size", "0.75rem");
      set_style(i, "opacity", "0.75");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t0);
      insert(target, t1, anchor);
      insert(target, i, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && t0_value !== (t0_value = ctx2[46].price + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(i);
    }
  };
}
__name(create_if_block_1$4, "create_if_block_1$4");
function create_each_block$4(key_1, ctx) {
  let div5;
  let button0;
  let i0;
  let t0;
  let div0;
  let img;
  let img_src_value;
  let t1;
  let div2;
  let div1;
  let a;
  let t2_value = ctx[46].text + "";
  let t2;
  let t3;
  let div4;
  let t4;
  let div3;
  let input;
  let t5;
  let button1;
  let i1;
  let mounted;
  let dispose;
  function click_handler_8() {
    return ctx[37](ctx[46]);
  }
  __name(click_handler_8, "click_handler_8");
  function click_handler_9(...args) {
    return ctx[38](ctx[46], ...args);
  }
  __name(click_handler_9, "click_handler_9");
  let if_block = ctx[46].price && create_if_block_1$4(ctx);
  function input_input_handler_1() {
    ctx[39].call(input, ctx[47], ctx[48]);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  function click_handler_10() {
    return ctx[40](ctx[46]);
  }
  __name(click_handler_10, "click_handler_10");
  return {
    key: key_1,
    first: null,
    c() {
      div5 = element("div");
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      div0 = element("div");
      img = element("img");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      a = element("a");
      t2 = text(t2_value);
      t3 = space();
      div4 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div3 = element("div");
      input = element("input");
      t5 = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fas fa-arrow-left svelte-1hoentp");
      attr(button0, "class", "item-piles-rolled-item-button svelte-1hoentp");
      attr(button0, "title", localize("ITEM-PILES.Merchant.AddItem"));
      attr(img, "class", "item-piles-img");
      if (!src_url_equal(img.src, img_src_value = ctx[46].img))
        attr(img, "src", img_src_value);
      attr(div0, "class", "item-piles-img-container");
      attr(a, "class", "item-piles-clickable");
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name svelte-1hoentp");
      attr(input, "class", "item-piles-quantity");
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(div3, "class", "item-piles-quantity-input-container svelte-1hoentp");
      attr(div4, "class", "item-piles-quantity-container svelte-1hoentp");
      attr(i1, "class", "fas fa-trash svelte-1hoentp");
      attr(button1, "class", "item-piles-rolled-item-button svelte-1hoentp");
      set_style(button1, "color", "red");
      attr(button1, "title", localize("ITEM-PILES.Merchant.RemoveItem"));
      attr(div5, "class", "item-piles-flexrow item-piles-item-row item-piles-even-color");
      this.first = div5;
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, button0);
      append(button0, i0);
      append(div5, t0);
      append(div5, div0);
      append(div0, img);
      append(div5, t1);
      append(div5, div2);
      append(div2, div1);
      append(div1, a);
      append(a, t2);
      append(div5, t3);
      append(div5, div4);
      if (if_block)
        if_block.m(div4, null);
      append(div4, t4);
      append(div4, div3);
      append(div3, input);
      set_input_value(input, ctx[46].quantity);
      append(div5, t5);
      append(div5, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_8),
          listen(a, "click", click_handler_9),
          listen(input, "input", input_input_handler_1),
          listen(button1, "click", click_handler_10)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 128 && !src_url_equal(img.src, img_src_value = ctx[46].img)) {
        attr(img, "src", img_src_value);
      }
      if (dirty[0] & 128 && t2_value !== (t2_value = ctx[46].text + ""))
        set_data(t2, t2_value);
      if (ctx[46].price) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$4(ctx);
          if_block.c();
          if_block.m(div4, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 128 && to_number(input.value) !== ctx[46].quantity) {
        set_input_value(input, ctx[46].quantity);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block$4, "create_each_block$4");
function create_fragment$b(ctx) {
  let div8;
  let div7;
  let div1;
  let div0;
  let t0_value = localize(ctx[6].length ? "ITEM-PILES.Merchant.CurrentItems" : "ITEM-PILES.Merchant.BuyNoItems") + "";
  let t0;
  let t1;
  let each_blocks_2 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t2;
  let t3;
  let div6;
  let div2;
  let span;
  let t5;
  let button0;
  let i;
  let t6;
  let t7_value = localize("ITEM-PILES.Merchant.RollAllTables") + "";
  let t7;
  let t8;
  let t9;
  let div3;
  let select;
  let each_blocks = [];
  let each2_lookup = /* @__PURE__ */ new Map();
  let each2_anchor;
  let show_if = foundry.utils.isEmpty(ctx[3]);
  let t10;
  let button1;
  let t12;
  let hr;
  let t13;
  let div5;
  let label0;
  let t14_value = localize(
    ctx[4] && ctx[7].length ? "ITEM-PILES.Merchant.RolledTimes" : "ITEM-PILES.Merchant.ClickRoll",
    { rolls: ctx[4] }
  ) + "";
  let t14;
  let t15;
  let div4;
  let label1;
  let t17;
  let input;
  let t18;
  let current;
  let mounted;
  let dispose;
  let each_value_4 = ctx[6];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[46].id, "get_key");
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i2);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_2[i2] = create_each_block_4(key, child_ctx));
  }
  let if_block0 = ctx[6].length && create_if_block_6(ctx);
  let each_value_2 = ctx[2];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = /* @__PURE__ */ __name((i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  }), "out");
  let each_value_1 = ctx[0];
  const get_key_1 = /* @__PURE__ */ __name((ctx2) => ctx2[49], "get_key_1");
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i2);
    let key = get_key_1(child_ctx);
    each2_lookup.set(key, each_blocks[i2] = create_each_block_1(key, child_ctx));
  }
  let if_block1 = show_if && create_if_block_2$4();
  let if_block2 = ctx[7].length && create_if_block$8(ctx);
  return {
    c() {
      div8 = element("div");
      div7 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].c();
      }
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div6 = element("div");
      div2 = element("div");
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Merchant.RollableTables")}`;
      t5 = space();
      button0 = element("button");
      i = element("i");
      t6 = space();
      t7 = text(t7_value);
      t8 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t9 = space();
      div3 = element("div");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each2_anchor = empty();
      if (if_block1)
        if_block1.c();
      t10 = space();
      button1 = element("button");
      button1.textContent = `${localize("ITEM-PILES.Merchant.AddTable")}`;
      t12 = space();
      hr = element("hr");
      t13 = space();
      div5 = element("div");
      label0 = element("label");
      t14 = text(t14_value);
      t15 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${localize("ITEM-PILES.Merchant.KeepRolled")}`;
      t17 = space();
      input = element("input");
      t18 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "item-piles-populate-header svelte-1hoentp");
      set_style(div1, "margin-right", "0.5rem");
      set_style(span, "flex", "1 0 auto");
      attr(i, "class", "fas fa-dice-d20");
      set_style(button0, "height", "20px");
      set_style(button0, "line-height", "inherit");
      set_style(button0, "font-size", "0.75rem");
      set_style(button0, "flex", "1 0 auto");
      set_style(button0, "margin", "0");
      attr(div2, "class", "item-piles-populate-header svelte-1hoentp");
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[34].call(select));
      attr(button1, "class", "item-piles-button svelte-1hoentp");
      set_style(button1, "max-width", "80px");
      set_style(button1, "min-width", "80px");
      attr(div3, "class", "item-piles-flexrow");
      set_style(div3, "margin-top", "0.5rem");
      set_style(div3, "flex-wrap", "nowrap");
      set_style(hr, "margin", "5px 0");
      attr(input, "type", "checkbox");
      attr(input, "class", "svelte-1hoentp");
      attr(div4, "class", "item-piles-flexrow item-piles-keep-rolled svelte-1hoentp");
      attr(div5, "class", "item-piles-flexrow item-piles-roll-header svelte-1hoentp");
      set_style(div6, "padding-right", "0.25rem");
      attr(div7, "class", "item-piles-flexrow");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div7);
      append(div7, div1);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].m(div1, null);
      }
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div7, t3);
      append(div7, div6);
      append(div6, div2);
      append(div2, span);
      append(div2, t5);
      append(div2, button0);
      append(button0, i);
      append(button0, t6);
      append(button0, t7);
      append(div6, t8);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].m(div6, null);
      }
      append(div6, t9);
      append(div6, div3);
      append(div3, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      append(select, each2_anchor);
      if (if_block1)
        if_block1.m(select, null);
      select_option(select, ctx[1]);
      append(div3, t10);
      append(div3, button1);
      append(div6, t12);
      append(div6, hr);
      append(div6, t13);
      append(div6, div5);
      append(div5, label0);
      append(label0, t14);
      append(div5, t15);
      append(div5, div4);
      append(div4, label1);
      append(div4, t17);
      append(div4, input);
      input.checked = ctx[5];
      append(div6, t18);
      if (if_block2)
        if_block2.m(div6, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[25]),
          listen(select, "change", ctx[34]),
          listen(button1, "click", ctx[35]),
          listen(input, "change", ctx[36])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 64) && t0_value !== (t0_value = localize(ctx2[6].length ? "ITEM-PILES.Merchant.CurrentItems" : "ITEM-PILES.Merchant.BuyNoItems") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 262208) {
        each_value_4 = ctx2[6];
        group_outros();
        each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key, 1, ctx2, each_value_4, each0_lookup, div1, outro_and_destroy_block, create_each_block_4, t2, get_each_context_4);
        check_outros();
      }
      if (ctx2[6].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 1056812) {
        each_value_2 = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_2(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div6, t9);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty[0] & 1) {
        each_value_1 = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value_1, each2_lookup, select, destroy_block, create_each_block_1, each2_anchor, get_each_context_1);
      }
      if (dirty[0] & 8)
        show_if = foundry.utils.isEmpty(ctx2[3]);
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$4();
          if_block1.c();
          if_block1.m(select, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 3) {
        select_option(select, ctx2[1]);
      }
      if ((!current || dirty[0] & 144) && t14_value !== (t14_value = localize(
        ctx2[4] && ctx2[7].length ? "ITEM-PILES.Merchant.RolledTimes" : "ITEM-PILES.Merchant.ClickRoll",
        { rolls: ctx2[4] }
      ) + ""))
        set_data(t14, t14_value);
      if (dirty[0] & 32) {
        input.checked = ctx2[5];
      }
      if (ctx2[7].length) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$8(ctx2);
          if_block2.c();
          if_block2.m(div6, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks_2[i2]);
      }
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        transition_out(each_blocks_2[i2]);
      }
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].d();
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks_1, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_fragment$b, "create_fragment$b");
async function getItem(itemToGet) {
  let item;
  if (itemToGet.documentCollection === "Item") {
    item = game.items.get(itemToGet.documentId);
  } else {
    const compendium = game.packs.get(itemToGet.documentCollection);
    if (compendium) {
      item = await compendium.getDocument(itemToGet.documentId);
    }
  }
  return item;
}
__name(getItem, "getItem");
async function previewItem(itemData) {
  itemData.item?.sheet?.render(true);
}
__name(previewItem, "previewItem");
function instance$b($$self, $$props, $$invalidate) {
  let currentItems;
  let $itemsRolled;
  let $populationTables;
  let $tables;
  let $itemStore;
  let { store } = $$props;
  let tables = writable(getTables());
  component_subscribe($$self, tables, (value) => $$invalidate(3, $tables = value));
  let populationTables = writable((get_store_value(store.pileData).tablesForPopulate ?? []).map((t) => {
    return {
      id: t.id,
      addAll: t.addAll ?? false,
      open: false,
      timesToRoll: t.timesToRoll ?? "1d4",
      items: t.items ?? {}
    };
  }));
  component_subscribe($$self, populationTables, (value) => $$invalidate(2, $populationTables = value));
  let timesRolled = "";
  let keepRolled = false;
  let itemStore = store.items;
  component_subscribe($$self, itemStore, (value) => $$invalidate(22, $itemStore = value));
  let selectableTables = [];
  let selectedTable = "";
  let itemsRolled = writable([]);
  component_subscribe($$self, itemsRolled, (value) => $$invalidate(7, $itemsRolled = value));
  function getTables() {
    let tables2 = Array.from(game.tables);
    const folderId = getSetting(SETTINGS.POPULATION_TABLES_FOLDER);
    if (folderId !== "root" && game.folders.find((f) => f.type === "RollTable" && f.id === folderId)) {
      tables2 = tables2.filter((t) => t.folder?.id === folderId);
    }
    const mappedTables = {};
    for (const table of tables2) {
      mappedTables[table.id] = {
        name: table.name,
        items: Array.from(table.collections.results)
      };
    }
    return mappedTables;
  }
  __name(getTables, "getTables");
  async function rollAllTables() {
    if (!keepRolled) {
      itemsRolled.set([]);
    }
    for (const table of $populationTables) {
      table.open = false;
      await evaluateTable(table, true);
    }
    $$invalidate(4, timesRolled = $itemsRolled.reduce(
      (total, item) => {
        return total + item.quantity;
      },
      0
    ));
  }
  __name(rollAllTables, "rollAllTables");
  async function evaluateTable(table, keepRolledItems) {
    const rollableTable = game.tables.get(table.id);
    if (!rollableTable)
      return;
    await rollableTable.reset();
    await rollableTable.normalize();
    if (!keepRolledItems) {
      itemsRolled.set([]);
    }
    let newItems = [];
    if (table.addAll) {
      for (const [itemId, formula] of Object.entries(table.items)) {
        const rollResult = rollableTable.results.get(itemId).toObject();
        const item = await getItem(rollResult);
        const roll = new Roll(formula).evaluate({ async: false });
        if (roll.total <= 0)
          continue;
        newItems.push({
          ...rollResult,
          item,
          quantity: roll.total
        });
      }
    } else {
      const roll = new Roll((table.timesToRoll ?? "1").toString()).evaluate({ async: false });
      if (roll.total <= 0) {
        return;
      }
      newItems = await game.itempiles.API.rollItemTable(rollableTable, { timesToRoll: roll.total });
    }
    const processedItems = newItems.map((itemData) => {
      const prices = game.itempiles.API.getPricesForItem(itemData.item, { seller: store.actor });
      itemData.price = prices[0]?.free ? localize("ITEM-PILES.Merchant.ItemFree") : prices[0]?.priceString;
      return itemData;
    });
    itemsRolled.update((items) => {
      processedItems.forEach((newItem) => {
        const existingItem = items.find((item) => item.documentId === newItem.documentId);
        if (existingItem) {
          existingItem.quantity++;
        } else {
          items.push({ ...newItem });
        }
      });
      items.sort((a, b) => {
        return a.text < b.text ? -1 : 1;
      });
      return items;
    });
  }
  __name(evaluateTable, "evaluateTable");
  async function addItem(itemToAdd) {
    await game.itempiles.API.addItems(store.actor, [itemToAdd]);
    removeItem(itemToAdd);
  }
  __name(addItem, "addItem");
  function removeItem(itemToRemove) {
    itemsRolled.update((items) => {
      const existingItemIndex = items.findIndex((item) => item.documentId === itemToRemove.documentId);
      items.splice(existingItemIndex, 1);
      return items;
    });
  }
  __name(removeItem, "removeItem");
  async function addAllItems() {
    const itemsToAdd = get_store_value(itemsRolled);
    await game.itempiles.API.addItems(store.actor, itemsToAdd);
    itemsRolled.set([]);
  }
  __name(addAllItems, "addAllItems");
  async function clearAllItems() {
    const doContinue = await TJSDialog.confirm({
      title: localize("ITEM-PILES.Dialogs.ClearAllItems.Title"),
      content: {
        class: CustomDialog,
        props: {
          icon: "fas fa-exclamation-triangle",
          content: localize("ITEM-PILES.Dialogs.ClearAllItems.Content")
        }
      },
      modal: true,
      draggable: false,
      options: {
        height: "auto",
        headerButtonNoClose: true
      }
    });
    if (!doContinue)
      return false;
    const items = game.itempiles.API.getActorItems(store.actor);
    await game.itempiles.API.removeItems(store.actor, items);
  }
  __name(clearAllItems, "clearAllItems");
  async function removeAddedItem(itemToRemove) {
    await game.itempiles.API.removeItems(store.actor, [itemToRemove.item]);
  }
  __name(removeAddedItem, "removeAddedItem");
  function addTable() {
    populationTables.update((tabs) => {
      tabs.push({
        id: selectedTable,
        addAll: false,
        open: false,
        timesToRoll: "1d4-1",
        items: {}
      });
      return tabs;
    });
  }
  __name(addTable, "addTable");
  async function removeTable(tableId) {
    const table = get_store_value(tables)[tableId];
    const doContinue = await TJSDialog.confirm({
      title: game.i18n.localize("ITEM-PILES.Dialogs.RemoveMerchantTable.Title"),
      content: {
        class: CustomDialog,
        props: {
          header: game.i18n.localize("ITEM-PILES.Dialogs.RemoveMerchantTable.Title"),
          content: game.i18n.format("ITEM-PILES.Dialogs.RemoveMerchantTable.Content", { table_name: table.name }),
          icon: "fas fa-exclamation-triangle"
        }
      },
      modal: true,
      draggable: false,
      rejectClose: false,
      defaultYes: true,
      options: { height: "auto" }
    });
    if (!doContinue)
      return;
    populationTables.update((tabs) => {
      return tabs.filter((t) => t.id !== tableId);
    });
  }
  __name(removeTable, "removeTable");
  let createId = Hooks.on("createRollTable", () => {
    tables.set(getTables());
  });
  let deleteId = Hooks.on("deleteRollTable", () => {
    tables.update(() => {
      const newTables = getTables();
      populationTables.update((values) => values.filter((t) => newTables[t.id]));
      return newTables;
    });
  });
  onDestroy(() => {
    Hooks.off("createRollTable", createId);
    Hooks.off("deleteRollTable", deleteId);
  });
  const click_handler = /* @__PURE__ */ __name((item) => removeAddedItem(item), "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => clearAllItems(), "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    rollAllTables();
  }, "click_handler_2");
  const click_handler_32 = /* @__PURE__ */ __name((table) => {
    removeTable(table.id);
  }, "click_handler_3");
  const click_handler_4 = /* @__PURE__ */ __name((table, each_value_2, table_index) => {
    set_store_value(populationTables, each_value_2[table_index].open = !table.open, $populationTables);
  }, "click_handler_4");
  const click_handler_5 = /* @__PURE__ */ __name((table, each_value_2, table_index) => {
    set_store_value(populationTables, each_value_2[table_index].open = false, $populationTables);
    evaluateTable(table, keepRolled);
  }, "click_handler_5");
  function input_change_handler(each_value_2, table_index) {
    each_value_2[table_index].addAll = this.checked;
    populationTables.set($populationTables);
  }
  __name(input_change_handler, "input_change_handler");
  const change_handler = /* @__PURE__ */ __name((table, each_value_2, table_index) => {
    if (!table.addAll)
      return;
    set_store_value(populationTables, each_value_2[table_index].items = Object.fromEntries($tables[table.id].items.map((item) => [item.id, "1d4"])), $populationTables);
  }, "change_handler");
  function input_input_handler(each_value_2, table_index) {
    each_value_2[table_index].timesToRoll = this.value;
    populationTables.set($populationTables);
  }
  __name(input_input_handler, "input_input_handler");
  const click_handler_6 = /* @__PURE__ */ __name((item) => previewItem(item), "click_handler_6");
  const change_handler_1 = /* @__PURE__ */ __name((table, item, each_value_2, table_index, event) => {
    set_store_value(populationTables, each_value_2[table_index].items[item.id] = event.target.value, $populationTables);
  }, "change_handler_1");
  function select_change_handler() {
    selectedTable = select_value(this);
    $$invalidate(1, selectedTable), $$invalidate(3, $tables), $$invalidate(2, $populationTables), $$invalidate(0, selectableTables);
    $$invalidate(0, selectableTables), $$invalidate(3, $tables), $$invalidate(2, $populationTables), $$invalidate(1, selectedTable);
  }
  __name(select_change_handler, "select_change_handler");
  const click_handler_7 = /* @__PURE__ */ __name(() => addTable(), "click_handler_7");
  function input_change_handler_1() {
    keepRolled = this.checked;
    $$invalidate(5, keepRolled);
  }
  __name(input_change_handler_1, "input_change_handler_1");
  const click_handler_8 = /* @__PURE__ */ __name((item) => addItem(item), "click_handler_8");
  const click_handler_9 = /* @__PURE__ */ __name((item, _) => previewItem(item), "click_handler_9");
  function input_input_handler_1(each_value, item_index) {
    each_value[item_index].quantity = to_number(this.value);
    itemsRolled.set($itemsRolled);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  const click_handler_10 = /* @__PURE__ */ __name((item) => removeItem(item), "click_handler_10");
  const click_handler_11 = /* @__PURE__ */ __name(() => addAllItems(), "click_handler_11");
  const click_handler_12 = /* @__PURE__ */ __name(() => {
    set_store_value(itemsRolled, $itemsRolled = [], $itemsRolled);
  }, "click_handler_12");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(21, store = $$props2.store);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4194304) {
      $$invalidate(6, currentItems = $itemStore.sort((a, b) => {
        return a.item.name < b.item.name ? -1 : 1;
      }));
    }
    if ($$self.$$.dirty[0] & 2097164) {
      {
        const pileData = get_store_value(store.pileData);
        pileData.tablesForPopulate = $populationTables.filter((t) => $tables[t.id]).map((t) => ({
          id: t.id,
          addAll: t.addAll,
          items: t.items
        }));
        updateItemPileData(store.actor, pileData);
      }
    }
    if ($$self.$$.dirty[0] & 15) {
      {
        $$invalidate(0, selectableTables = Object.entries($tables).filter((entry) => !$populationTables.some((table) => table.id === entry[0])));
        const tableSet = new Set(selectableTables.map((e) => e[0]));
        $$invalidate(1, selectedTable = tableSet.has(selectedTable) ? selectedTable : tableSet.first());
      }
    }
  };
  return [
    selectableTables,
    selectedTable,
    $populationTables,
    $tables,
    timesRolled,
    keepRolled,
    currentItems,
    $itemsRolled,
    tables,
    populationTables,
    itemStore,
    itemsRolled,
    rollAllTables,
    evaluateTable,
    addItem,
    removeItem,
    addAllItems,
    clearAllItems,
    removeAddedItem,
    addTable,
    removeTable,
    store,
    $itemStore,
    click_handler,
    click_handler_1,
    click_handler_22,
    click_handler_32,
    click_handler_4,
    click_handler_5,
    input_change_handler,
    change_handler,
    input_input_handler,
    click_handler_6,
    change_handler_1,
    select_change_handler,
    click_handler_7,
    input_change_handler_1,
    click_handler_8,
    click_handler_9,
    input_input_handler_1,
    click_handler_10,
    click_handler_11,
    click_handler_12
  ];
}
__name(instance$b, "instance$b");
class MerchantPopulateItemsTab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { store: 21 }, null, [-1, -1]);
  }
}
__name(MerchantPopulateItemsTab, "MerchantPopulateItemsTab");
function create_else_block$1(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  return {
    c() {
      t0 = text(ctx[2]);
      t1 = text(" (x");
      t2 = text(ctx[1]);
      t3 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t0, ctx2[2]);
      if (dirty & 2)
        set_data(t2, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
    }
  };
}
__name(create_else_block$1, "create_else_block$1");
function create_if_block$7(ctx) {
  let t_value = ctx[5].replace("{#}", ctx[1]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[5].replace("{#}", ctx2[1]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
__name(create_if_block$7, "create_if_block$7");
function create_fragment$a(ctx) {
  let div3;
  let div0;
  let img_1;
  let img_1_src_value;
  let t;
  let div2;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block$7;
    return create_else_block$1;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t = space();
      div2 = element("div");
      div1 = element("div");
      if_block.c();
      attr(img_1, "class", "item-piles-img");
      if (!src_url_equal(img_1.src, img_1_src_value = ctx[0]))
        attr(img_1, "src", img_1_src_value);
      attr(div0, "class", "item-piles-img-container");
      attr(div1, "class", "item-piles-name-container");
      attr(div2, "class", "item-piles-name item-piles-text");
      set_style(div2, "flex", "0 1 auto");
      attr(div3, "class", "item-piles-flexrow item-piles-item-row");
      set_style(div3, "flex", "0 1 auto");
      set_style(div3, "margin", "0.5rem 0.25rem");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img_1);
      append(div3, t);
      append(div3, div2);
      append(div2, div1);
      if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && !src_url_equal(img_1.src, img_1_src_value = ctx2[0])) {
        attr(img_1, "src", img_1_src_value);
      }
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
__name(create_fragment$a, "create_fragment$a");
function instance$a($$self, $$props, $$invalidate) {
  let $img;
  let $quantity;
  let $name;
  let { currency } = $$props;
  let name = currency.name;
  component_subscribe($$self, name, (value) => $$invalidate(2, $name = value));
  let img = currency.img;
  component_subscribe($$self, img, (value) => $$invalidate(0, $img = value));
  let abbreviation = currency.abbreviation;
  let quantity = currency.quantity;
  component_subscribe($$self, quantity, (value) => $$invalidate(1, $quantity = value));
  $$self.$$set = ($$props2) => {
    if ("currency" in $$props2)
      $$invalidate(7, currency = $$props2.currency);
  };
  return [$img, $quantity, $name, name, img, abbreviation, quantity, currency];
}
__name(instance$a, "instance$a");
class MerchantCurrencyColumn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { currency: 7 });
  }
}
__name(MerchantCurrencyColumn, "MerchantCurrencyColumn");
const MerchantRightPane_svelte_svelte_type_style_lang = "";
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
__name(get_each_context$3, "get_each_context$3");
function create_if_block_5(ctx) {
  let merchantpopulateitemstab;
  let current;
  merchantpopulateitemstab = new MerchantPopulateItemsTab({ props: { store: ctx[0] } });
  return {
    c() {
      create_component(merchantpopulateitemstab.$$.fragment);
    },
    m(target, anchor) {
      mount_component(merchantpopulateitemstab, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const merchantpopulateitemstab_changes = {};
      if (dirty & 1)
        merchantpopulateitemstab_changes.store = ctx2[0];
      merchantpopulateitemstab.$set(merchantpopulateitemstab_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantpopulateitemstab.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantpopulateitemstab.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchantpopulateitemstab, detaching);
    }
  };
}
__name(create_if_block_5, "create_if_block_5");
function create_if_block_4$2(ctx) {
  let merchantselltab;
  let current;
  merchantselltab = new MerchantSellTab({
    props: { store: ctx[1] }
  });
  return {
    c() {
      create_component(merchantselltab.$$.fragment);
    },
    m(target, anchor) {
      mount_component(merchantselltab, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const merchantselltab_changes = {};
      if (dirty & 2)
        merchantselltab_changes.store = ctx2[1];
      merchantselltab.$set(merchantselltab_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantselltab.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantselltab.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchantselltab, detaching);
    }
  };
}
__name(create_if_block_4$2, "create_if_block_4$2");
function create_if_block_3$3(ctx) {
  let merchantbuytab;
  let current;
  merchantbuytab = new MerchantBuyTab({
    props: {
      store: ctx[0],
      categoryFilter: func_1
    }
  });
  return {
    c() {
      create_component(merchantbuytab.$$.fragment);
    },
    m(target, anchor) {
      mount_component(merchantbuytab, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const merchantbuytab_changes = {};
      if (dirty & 1)
        merchantbuytab_changes.store = ctx2[0];
      merchantbuytab.$set(merchantbuytab_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantbuytab.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantbuytab.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchantbuytab, detaching);
    }
  };
}
__name(create_if_block_3$3, "create_if_block_3$3");
function create_if_block_2$3(ctx) {
  let merchantbuytab;
  let current;
  merchantbuytab = new MerchantBuyTab({
    props: {
      store: ctx[0],
      categoryFilter: func
    }
  });
  return {
    c() {
      create_component(merchantbuytab.$$.fragment);
    },
    m(target, anchor) {
      mount_component(merchantbuytab, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const merchantbuytab_changes = {};
      if (dirty & 1)
        merchantbuytab_changes.store = ctx2[0];
      merchantbuytab.$set(merchantbuytab_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantbuytab.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantbuytab.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchantbuytab, detaching);
    }
  };
}
__name(create_if_block_2$3, "create_if_block_2$3");
function create_if_block_1$3(ctx) {
  let div;
  let span;
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${localize("ITEM-PILES.Merchant.MerchantClosed")}`;
      set_style(div, "display", "grid");
      set_style(div, "place-items", "center");
      set_style(div, "height", "100%");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_1$3, "create_if_block_1$3");
function create_if_block$6(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[3];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[9].identifier, "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "item-piles-flexrow item-piles-currency-list svelte-1blnjm9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        each_value = ctx2[3];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
__name(create_if_block$6, "create_if_block$6");
function create_each_block$3(key_1, ctx) {
  let first;
  let merchantcurrencycolumn;
  let current;
  merchantcurrencycolumn = new MerchantCurrencyColumn({ props: { currency: ctx[9] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(merchantcurrencycolumn.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(merchantcurrencycolumn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const merchantcurrencycolumn_changes = {};
      if (dirty & 8)
        merchantcurrencycolumn_changes.currency = ctx[9];
      merchantcurrencycolumn.$set(merchantcurrencycolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantcurrencycolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantcurrencycolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(merchantcurrencycolumn, detaching);
    }
  };
}
__name(create_each_block$3, "create_each_block$3");
function create_fragment$9(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [
    create_if_block_1$3,
    create_if_block_2$3,
    create_if_block_3$3,
    create_if_block_4$2,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] && !game.user.isGM)
      return 0;
    if (ctx2[5] === "buy")
      return 1;
    if (ctx2[5] === "services")
      return 2;
    if (ctx2[5] === "sell")
      return 3;
    if (ctx2[5] === "tables")
      return 4;
    return -1;
  }
  __name(select_block_type, "select_block_type");
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[1] && ctx[3].length && create_if_block$6(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "merchant-tabbed-center svelte-1blnjm9");
      set_style(div0, "flex", "1");
      set_style(div0, "max-height", "calc(100% - " + (ctx[1] && ctx[3].length ? "46px" : "0px") + ")");
      attr(div1, "class", "merchant-right-pane item-piles-flexcol svelte-1blnjm9");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append(div1, t);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        } else {
          if_block0 = null;
        }
      }
      if (!current || dirty & 10) {
        set_style(div0, "max-height", "calc(100% - " + (ctx2[1] && ctx2[3].length ? "46px" : "0px") + ")");
      }
      if (ctx2[1] && ctx2[3].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 10) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
    }
  };
}
__name(create_fragment$9, "create_fragment$9");
const func = /* @__PURE__ */ __name((category) => {
  return !category.service;
}, "func");
const func_1 = /* @__PURE__ */ __name((category) => {
  return category.service;
}, "func_1");
function instance$9($$self, $$props, $$invalidate) {
  let $currencies;
  let $closed;
  let $activeTab, $$unsubscribe_activeTab = noop, $$subscribe_activeTab = /* @__PURE__ */ __name(() => ($$unsubscribe_activeTab(), $$unsubscribe_activeTab = subscribe(activeTab, ($$value) => $$invalidate(5, $activeTab = $$value)), activeTab), "$$subscribe_activeTab");
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeTab());
  let { store } = $$props;
  let { recipientStore } = $$props;
  let { activeTab } = $$props;
  $$subscribe_activeTab();
  const currencies = recipientStore?.allCurrencies || writable([]);
  component_subscribe($$self, currencies, (value) => $$invalidate(3, $currencies = value));
  store.categories;
  let closed = store.closed;
  component_subscribe($$self, closed, (value) => $$invalidate(4, $closed = value));
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
    if ("recipientStore" in $$props2)
      $$invalidate(1, recipientStore = $$props2.recipientStore);
    if ("activeTab" in $$props2)
      $$subscribe_activeTab($$invalidate(2, activeTab = $$props2.activeTab));
  };
  return [
    store,
    recipientStore,
    activeTab,
    $currencies,
    $closed,
    $activeTab,
    currencies,
    closed
  ];
}
__name(instance$9, "instance$9");
class MerchantRightPane extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, {
      store: 0,
      recipientStore: 1,
      activeTab: 2
    });
  }
}
__name(MerchantRightPane, "MerchantRightPane");
const MerchantTopBar_svelte_svelte_type_style_lang = "";
function create_if_block_3$2(ctx) {
  let a;
  let i;
  let t0;
  let t1_value = localize(`ITEM-PILES.Merchant.${!ctx[4] ? "Open" : "Closed"}`) + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas");
      toggle_class(i, "fa-door-open", !ctx[4]);
      toggle_class(i, "fa-door-closed", ctx[4]);
      set_style(a, "flex", "0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        toggle_class(i, "fa-door-open", !ctx2[4]);
      }
      if (dirty & 16) {
        toggle_class(i, "fa-door-closed", ctx2[4]);
      }
      if (dirty & 16 && t1_value !== (t1_value = localize(`ITEM-PILES.Merchant.${!ctx2[4] ? "Open" : "Closed"}`) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3$2, "create_if_block_3$2");
function create_if_block$5(ctx) {
  let span0;
  let t1;
  let span1;
  let t2;
  let t3;
  let if_block = game.user.isGM && create_if_block_1$2(ctx);
  return {
    c() {
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Merchant.OpenTimes")}`;
      t1 = space();
      span1 = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      t3 = text(ctx[2]);
      set_style(span1, "font-style", "italic");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      if (if_block)
        if_block.m(span1, null);
      append(span1, t2);
      append(span1, t3);
    },
    p(ctx2, dirty) {
      if (game.user.isGM)
        if_block.p(ctx2, dirty);
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span1);
      if (if_block)
        if_block.d();
    }
  };
}
__name(create_if_block$5, "create_if_block$5");
function create_if_block_1$2(ctx) {
  let t0;
  let a;
  let i;
  let t1;
  let t2_value = localize(`ITEM-PILES.Merchant.${!ctx[4] ? "Open" : "Closed"}`) + "";
  let t2;
  let mounted;
  let dispose;
  let if_block = ctx[8] && ctx[1].openTimes.status !== "auto" && create_if_block_2$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      i = element("i");
      t1 = space();
      t2 = text(t2_value);
      attr(i, "class", "fas");
      toggle_class(i, "fa-door-open", !ctx[4]);
      toggle_class(i, "fa-door-closed", ctx[4]);
      attr(a, "class", "item-piles-right-divider svelte-18jt6ec");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, i);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[8] && ctx2[1].openTimes.status !== "auto") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$2(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 16) {
        toggle_class(i, "fa-door-open", !ctx2[4]);
      }
      if (dirty & 16) {
        toggle_class(i, "fa-door-closed", ctx2[4]);
      }
      if (dirty & 16 && t2_value !== (t2_value = localize(`ITEM-PILES.Merchant.${!ctx2[4] ? "Open" : "Closed"}`) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1$2, "create_if_block_1$2");
function create_if_block_2$2(ctx) {
  let a;
  let i;
  let t0;
  let t1_value = localize(`ITEM-PILES.Merchant.OpenCloseAuto`) + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i, "class", "fas fa-clock");
      attr(a, "class", "item-piles-right-divider svelte-18jt6ec");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", ctx[9]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_2$2, "create_if_block_2$2");
function create_fragment$8(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].openTimes.enabled)
      return create_if_block$5;
    if (game.user.isGM)
      return create_if_block_3$2;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[3]);
      t1 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "merchant-name svelte-18jt6ec");
      attr(div1, "class", "opening-hours item-piles-flexcol svelte-18jt6ec");
      attr(div2, "class", "item-piles-flexrow merchant-top-bar item-piles-bottom-divider svelte-18jt6ec");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      if (if_block)
        if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 8)
        set_data(t0, ctx2[3]);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
__name(create_fragment$8, "create_fragment$8");
function instance$8($$self, $$props, $$invalidate) {
  let $pileDataStore;
  let $merchantName;
  let $closed;
  let { store } = $$props;
  const pileDataStore = store.pileData;
  component_subscribe($$self, pileDataStore, (value) => $$invalidate(1, $pileDataStore = value));
  const merchantName = store.name;
  component_subscribe($$self, merchantName, (value) => $$invalidate(3, $merchantName = value));
  const closed = store.closed;
  component_subscribe($$self, closed, (value) => $$invalidate(4, $closed = value));
  let openTimeText = "";
  const aboutTimeEnabled = game.modules.get("foundryvtt-simple-calendar")?.active || false;
  const click_handler = /* @__PURE__ */ __name(() => {
    store.setOpenStatus("auto");
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    store.setOpenStatus($closed ? "open" : "closed");
  }, "click_handler_1");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    store.setOpenStatus($closed ? "open" : "closed");
  }, "click_handler_2");
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(0, store = $$props2.store);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      {
        let open = $pileDataStore.openTimes.open;
        let close = $pileDataStore.openTimes.close;
        let openText = `${open.hour.toString().padStart(2, "0")}:${open.minute.toString().padStart(2, "0")}`;
        let closeText = `${close.hour.toString().padStart(2, "0")}:${close.minute.toString().padStart(2, "0")}`;
        $$invalidate(2, openTimeText = `${openText} - ${closeText}`);
      }
    }
  };
  return [
    store,
    $pileDataStore,
    openTimeText,
    $merchantName,
    $closed,
    pileDataStore,
    merchantName,
    closed,
    aboutTimeEnabled,
    click_handler,
    click_handler_1,
    click_handler_22
  ];
}
__name(instance$8, "instance$8");
class MerchantTopBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, { store: 0 });
  }
}
__name(MerchantTopBar, "MerchantTopBar");
const merchantAppShell_svelte_svelte_type_style_lang = "";
function create_if_block$4(ctx) {
  let merchantleftpane;
  let current;
  merchantleftpane = new MerchantLeftPane({ props: { store: ctx[1] } });
  return {
    c() {
      create_component(merchantleftpane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(merchantleftpane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const merchantleftpane_changes = {};
      if (dirty & 2)
        merchantleftpane_changes.store = ctx2[1];
      merchantleftpane.$set(merchantleftpane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchantleftpane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchantleftpane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchantleftpane, detaching);
    }
  };
}
__name(create_if_block$4, "create_if_block$4");
function create_default_slot_1(ctx) {
  let merchanttopbar;
  let t0;
  let tabs_1;
  let updating_tabs;
  let updating_activeTab;
  let t1;
  let div;
  let t2;
  let merchantrightpane;
  let current;
  merchanttopbar = new MerchantTopBar({ props: { store: ctx[1] } });
  function tabs_1_tabs_binding(value) {
    ctx[17](value);
  }
  __name(tabs_1_tabs_binding, "tabs_1_tabs_binding");
  function tabs_1_activeTab_binding(value) {
    ctx[18](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = {
    style: "flex: 0 1 auto; font-size: 1.1rem; justify-content: flex-start;",
    separateElements: true,
    underscore: true
  };
  if (ctx[3] !== void 0) {
    tabs_1_props.tabs = ctx[3];
  }
  if (ctx[4] !== void 0) {
    tabs_1_props.activeTab = ctx[4];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind$1(tabs_1, "tabs", tabs_1_tabs_binding));
  binding_callbacks.push(() => bind$1(tabs_1, "activeTab", tabs_1_activeTab_binding));
  let if_block = ctx[4] !== "tables" && create_if_block$4(ctx);
  merchantrightpane = new MerchantRightPane({
    props: {
      store: ctx[1],
      recipientStore: ctx[2],
      activeTab: ctx[10]
    }
  });
  return {
    c() {
      create_component(merchanttopbar.$$.fragment);
      t0 = space();
      create_component(tabs_1.$$.fragment);
      t1 = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(merchantrightpane.$$.fragment);
      attr(div, "class", "item-piles-flexrow item-pile-merchant-content svelte-1lp0e8w");
    },
    m(target, anchor) {
      mount_component(merchanttopbar, target, anchor);
      insert(target, t0, anchor);
      mount_component(tabs_1, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t2);
      mount_component(merchantrightpane, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const merchanttopbar_changes = {};
      if (dirty & 2)
        merchanttopbar_changes.store = ctx2[1];
      merchanttopbar.$set(merchanttopbar_changes);
      const tabs_1_changes = {};
      if (!updating_tabs && dirty & 8) {
        updating_tabs = true;
        tabs_1_changes.tabs = ctx2[3];
        add_flush_callback(() => updating_tabs = false);
      }
      if (!updating_activeTab && dirty & 16) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = ctx2[4];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
      if (ctx2[4] !== "tables") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const merchantrightpane_changes = {};
      if (dirty & 2)
        merchantrightpane_changes.store = ctx2[1];
      if (dirty & 4)
        merchantrightpane_changes.recipientStore = ctx2[2];
      merchantrightpane.$set(merchantrightpane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(merchanttopbar.$$.fragment, local);
      transition_in(tabs_1.$$.fragment, local);
      transition_in(if_block);
      transition_in(merchantrightpane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(merchanttopbar.$$.fragment, local);
      transition_out(tabs_1.$$.fragment, local);
      transition_out(if_block);
      transition_out(merchantrightpane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(merchanttopbar, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(merchantrightpane);
    }
  };
}
__name(create_default_slot_1, "create_default_slot_1");
function create_default_slot$5(ctx) {
  let dropzone;
  let current;
  dropzone = new DropZone({
    props: {
      callback: ctx[9],
      style: "display: flex; flex-direction: column; height: 100%;",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropzone.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dropzone, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropzone_changes = {};
      if (dirty & 8388638) {
        dropzone_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropzone.$set(dropzone_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropzone.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropzone.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropzone, detaching);
    }
  };
}
__name(create_default_slot$5, "create_default_slot$5");
function create_fragment$7(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  let mounted;
  let dispose;
  function applicationshell_elementRoot_binding(value) {
    ctx[19](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$5] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(window, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 8388638) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$7, "create_fragment$7");
function instance$7($$self, $$props, $$invalidate) {
  let $activeTab;
  let $visibleItems;
  let $pileData;
  let $priceSelector;
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { merchant } = $$props;
  let { recipient } = $$props;
  let { store = new MerchantStore(application, merchant, recipient) } = $$props;
  let { recipientStore = recipient ? new MerchantStore(application, recipient, merchant, { recipientPileData: store.pileData }) : false } = $$props;
  let pileData = store.pileData;
  component_subscribe($$self, pileData, (value) => $$invalidate(15, $pileData = value));
  store.closed;
  onDestroy(() => {
    store.onDestroy();
  });
  let priceSelector = store.priceSelector;
  component_subscribe($$self, priceSelector, (value) => $$invalidate(5, $priceSelector = value));
  store.categories;
  let visibleItems = store.visibleItems;
  component_subscribe($$self, visibleItems, (value) => $$invalidate(14, $visibleItems = value));
  async function dropData(data) {
    if (!game.user.isGM)
      return;
    if (!data.type) {
      throw custom_error("Something went wrong when dropping this item!");
    }
    if (data.type !== "Item") {
      throw custom_error("You must drop an item, not " + data.type.toLowerCase() + "!");
    }
    const item = await Item.implementation.fromDropData(data);
    const validItem = await checkItemType(merchant, item, {
      errorText: "ITEM-PILES.Errors.DisallowedItemTrade",
      warningTitle: "ITEM-PILES.Dialogs.TypeWarning.Title",
      warningContent: "ITEM-PILES.Dialogs.TypeWarning.TradeContent"
    });
    if (!validItem)
      return;
    return game.itempiles.API.addItems(merchant, [{ item: validItem, quantity: 1 }]);
  }
  __name(dropData, "dropData");
  const activeTab = writable("buy");
  component_subscribe($$self, activeTab, (value) => $$invalidate(4, $activeTab = value));
  let sellHidden;
  let tabs;
  const click_handler = /* @__PURE__ */ __name(() => {
    set_store_value(priceSelector, $priceSelector = "", $priceSelector);
  }, "click_handler");
  function tabs_1_tabs_binding(value) {
    tabs = value;
    $$invalidate(3, tabs), $$invalidate(15, $pileData), $$invalidate(14, $visibleItems), $$invalidate(2, recipientStore), $$invalidate(13, sellHidden), $$invalidate(4, $activeTab);
  }
  __name(tabs_1_tabs_binding, "tabs_1_tabs_binding");
  function tabs_1_activeTab_binding(value) {
    $activeTab = value;
    activeTab.set($activeTab);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("merchant" in $$props2)
      $$invalidate(11, merchant = $$props2.merchant);
    if ("recipient" in $$props2)
      $$invalidate(12, recipient = $$props2.recipient);
    if ("store" in $$props2)
      $$invalidate(1, store = $$props2.store);
    if ("recipientStore" in $$props2)
      $$invalidate(2, recipientStore = $$props2.recipientStore);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 57372) {
      {
        $$invalidate(13, sellHidden = $pileData.purchaseOnly);
        let hasItems = $visibleItems.some((item) => !get_store_value(item.category).service);
        let hasServices = $visibleItems.some((item) => get_store_value(item.category).service);
        $$invalidate(3, tabs = [
          {
            value: "buy",
            label: game.i18n.localize("ITEM-PILES.Merchant.BuyItems"),
            hidden: !hasItems && hasServices
          },
          {
            value: "services",
            label: game.i18n.localize("ITEM-PILES.Merchant.BuyServices"),
            hidden: !hasServices
          },
          {
            value: "sell",
            label: game.i18n.localize("ITEM-PILES.Merchant.SellItems"),
            hidden: !recipientStore || sellHidden
          },
          {
            value: "tables",
            label: game.i18n.localize("ITEM-PILES.Merchant.PopulateItems"),
            hidden: !game.user.isGM
          }
        ]);
        if (tabs.find((tab) => tab.value === $activeTab).hidden) {
          set_store_value(activeTab, $activeTab = tabs.find((tab) => !tab.hidden).value, $activeTab);
        }
      }
    }
  };
  return [
    elementRoot,
    store,
    recipientStore,
    tabs,
    $activeTab,
    $priceSelector,
    pileData,
    priceSelector,
    visibleItems,
    dropData,
    activeTab,
    merchant,
    recipient,
    sellHidden,
    $visibleItems,
    $pileData,
    click_handler,
    tabs_1_tabs_binding,
    tabs_1_activeTab_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$7, "instance$7");
class Merchant_app_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {
      elementRoot: 0,
      merchant: 11,
      recipient: 12,
      store: 1,
      recipientStore: 2
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get merchant() {
    return this.$$.ctx[11];
  }
  set merchant(merchant) {
    this.$$set({ merchant });
    flush();
  }
  get recipient() {
    return this.$$.ctx[12];
  }
  set recipient(recipient) {
    this.$$set({ recipient });
    flush();
  }
  get store() {
    return this.$$.ctx[1];
  }
  set store(store) {
    this.$$set({ store });
    flush();
  }
  get recipientStore() {
    return this.$$.ctx[2];
  }
  set recipientStore(recipientStore) {
    this.$$set({ recipientStore });
    flush();
  }
}
__name(Merchant_app_shell, "Merchant_app_shell");
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[10] = list;
  child_ctx[11] = i;
  return child_ctx;
}
__name(get_each_context$2, "get_each_context$2");
function create_each_block$2(key_1, ctx) {
  let div;
  let label;
  let t0_value = ctx[9].name + "";
  let t0;
  let label_for_value;
  let t1;
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[5].call(input, ctx[10], ctx[11]);
  }
  __name(input_change_handler, "input_change_handler");
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(label, "for", label_for_value = "item-piles-user-" + ctx[9].id);
      attr(label, "class", "item-piles-clickable");
      attr(div, "class", "item-piles-flexrow");
      set_style(div, "align-items", "center");
      attr(input, "id", input_id_value = "item-piles-user-" + ctx[9].id);
      attr(input, "type", "checkbox");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      insert(target, t1, anchor);
      insert(target, input, anchor);
      input.checked = ctx[9].selected;
      if (!mounted) {
        dispose = listen(input, "change", input_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = ctx[9].name + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && label_for_value !== (label_for_value = "item-piles-user-" + ctx[9].id)) {
        attr(label, "for", label_for_value);
      }
      if (dirty & 4 && input_id_value !== (input_id_value = "item-piles-user-" + ctx[9].id)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 4) {
        input.checked = ctx[9].selected;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_each_block$2, "create_each_block$2");
function create_default_slot$4(ctx) {
  let form_1;
  let p;
  let strong;
  let t1;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let footer;
  let button;
  let i;
  let t3;
  let t4_value = localize("Okay") + "";
  let t4;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[9].id, "get_key");
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      form_1 = element("form");
      p = element("p");
      strong = element("strong");
      strong.textContent = `${localize("ITEM-PILES.Dialogs.UserSelect.Content")}`;
      t1 = space();
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      footer = element("footer");
      button = element("button");
      i = element("i");
      t3 = space();
      t4 = text(t4_value);
      set_style(p, "margin-top", "0");
      set_style(p, "text-align", "center");
      set_style(div, "display", "grid");
      set_style(div, "grid-template-columns", "auto 25px");
      attr(i, "class", "fas fa-check");
      attr(button, "type", "button");
      attr(footer, "class", "sheet-footer item-piles-flexrow");
      set_style(footer, "margin-top", "1rem");
      attr(form_1, "class", "item-piles-flexcol");
      set_style(form_1, "padding", "0.5rem");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p);
      append(p, strong);
      append(form_1, t1);
      append(form_1, div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      append(form_1, t2);
      append(form_1, footer);
      append(footer, button);
      append(button, i);
      append(button, t3);
      append(button, t4);
      ctx[6](form_1);
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[3], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[4]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$2, null, get_each_context$2);
      }
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$4, "create_default_slot$4");
function create_fragment$6(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[7](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$4] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 4102) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$6, "create_fragment$6");
function instance$6($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let form;
  const users = game.users.filter((u) => u.active && (u.character || u.isGM) && !(application.options.excludeSelf && u === game.user)).map((u) => ({ id: u.id, name: u.name, selected: true }));
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function submit() {
    const finalUsers = users.filter((user) => user.selected).map((user) => user.id);
    application.options.resolve(finalUsers);
    application.close();
  }
  __name(submit, "submit");
  function input_change_handler(each_value, user_index) {
    each_value[user_index].selected = this.checked;
    $$invalidate(2, users);
  }
  __name(input_change_handler, "input_change_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(1, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [
    elementRoot,
    form,
    users,
    requestSubmit,
    submit,
    input_change_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$6, "instance$6");
class User_select_dialog_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
__name(User_select_dialog_shell, "User_select_dialog_shell");
class UserSelectDialog extends SvelteApplication {
  constructor(options = {}) {
    super({
      title: game.i18n.localize("ITEM-PILES.Dialogs.UserSelect.Title"),
      svelte: {
        class: User_select_dialog_shell,
        target: document.body
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 200,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-drop-currency-${id}`);
  }
  static async show(options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(options).render(true, { focus: true });
    });
  }
}
__name(UserSelectDialog, "UserSelectDialog");
class MerchantApp extends SvelteApplication {
  constructor(merchant, recipient = false, options = {}, dialogData = {}) {
    super({
      title: `Merchant: ${merchant.name}`,
      id: `item-pile-merchant-${merchant.id}`,
      svelte: {
        class: Merchant_app_shell,
        target: document.body,
        props: {
          merchant,
          recipient
        }
      },
      zIndex: 100,
      ...options
    }, dialogData);
    this.merchant = merchant;
    this.recipient = recipient;
    hooks.callAll(HOOKS.OPEN_INTERFACE, this, merchant, recipient, options, dialogData);
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["app window-app sheet", "item-piles-merchant-sheet", "item-piles"],
      width: 800,
      height: 700,
      closeOnSubmit: false,
      resizable: true
    });
  }
  static getActiveApp(id) {
    return Object.values(ui.windows).find((app) => app.id === `item-pile-merchant-${id}`);
  }
  static async show(merchant, recipient = false, options = {}, dialogData = {}) {
    merchant = merchant?.actor ?? merchant;
    recipient = recipient?.actor ?? recipient;
    const result = hooks.call(HOOKS.PRE_OPEN_INTERFACE, merchant, recipient, options, dialogData);
    if (result === false)
      return;
    const app = this.getActiveApp(merchant.id);
    if (app)
      return app.render(false, { focus: true });
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(merchant, recipient, options, dialogData).render(true, { focus: true });
    });
  }
  refreshItems() {
    this.svelte.applicationShell.store.refreshItems();
  }
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    const canConfigure = game.user.isGM;
    if (canConfigure) {
      buttons = [
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.Inspect.OpenSheet" : "",
          class: "item-piles-open-actor-sheet",
          icon: "fas fa-user",
          onclick: () => {
            this.merchant.sheet.render(true, { focus: true });
          }
        },
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.ContextMenu.ShowToPlayers" : "",
          class: "item-piles-show-to-players",
          icon: "fas fa-eye",
          onclick: async (event) => {
            const activeUsers = Array.from(game.users).filter((u) => u.active && u !== game.user).map((u) => u.id);
            if (!activeUsers.length) {
              return custom_warning(game.i18n.localize("ITEM-PILES.Warnings.NoPlayersActive"), true);
            }
            const users = event.altKey ? activeUsers : await UserSelectDialog.show({ excludeSelf: true });
            if (!users || !users.length)
              return;
            custom_notify(game.i18n.format("ITEM-PILES.Notifications.ShownToPlayers", { actor_name: this.merchant.name }));
            return game.itempiles.API.renderItemPileInterface(this.merchant, {
              userIds: users,
              useDefaultCharacter: true
            });
          }
        },
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.HUD.Configure" : "",
          class: "item-piles-configure-pile",
          icon: "fas fa-box-open",
          onclick: () => {
            ItemPileConfig.show(this.merchant);
          }
        }
      ].concat(buttons);
    }
    return buttons;
  }
  async close(options) {
    const result = hooks.call(HOOKS.PRE_CLOSE_INTERFACE, this, this.merchant, this.recipient);
    if (result === false)
      return;
    for (const app of Object.values(ui.windows)) {
      if (app !== this && this.svelte.applicationShell.store === app?.svelte?.applicationShell?.store) {
        app.close();
      }
    }
    hooks.callAll(HOOKS.CLOSE_INTERFACE, this, this.merchant, this.recipient);
    return super.close(options);
  }
}
__name(MerchantApp, "MerchantApp");
function create_if_block_3$1(ctx) {
  let div13;
  let div0;
  let label0;
  let span0;
  let t1;
  let p0;
  let t3;
  let span2;
  let t4;
  let span1;
  let input0;
  let t5;
  let div1;
  let label1;
  let span3;
  let t7;
  let p1;
  let t9;
  let input1;
  let t10;
  let div2;
  let label2;
  let span4;
  let t12;
  let p2;
  let t14;
  let input2;
  let t15;
  let div3;
  let label3;
  let span5;
  let t17;
  let p3;
  let t19;
  let input3;
  let t20;
  let div4;
  let label4;
  let span6;
  let t22;
  let p4;
  let t24;
  let div5;
  let macroselector;
  let updating_macro;
  let t25;
  let div6;
  let label5;
  let span7;
  let t27;
  let p5;
  let t29;
  let select;
  let option0;
  let option1;
  let option2;
  let t36;
  let div7;
  let label6;
  let span8;
  let t38;
  let p6;
  let t40;
  let div8;
  let button0;
  let t42;
  let div9;
  let label7;
  let span9;
  let t44;
  let p7;
  let t46;
  let input4;
  let t47;
  let div10;
  let button1;
  let t48_value = localize("ITEM-PILES.Applications.ItemPileConfig.Main.ConfigureOverrideCurrencies") + "";
  let t48;
  let button1_disabled_value;
  let t49;
  let div11;
  let label8;
  let span10;
  let t51;
  let p8;
  let t53;
  let input5;
  let t54;
  let div12;
  let button2;
  let t55_value = localize("ITEM-PILES.Applications.ItemPileConfig.Main.ConfigureOverrideItemFilters") + "";
  let t55;
  let button2_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[1] && create_if_block_4$1();
  function macroselector_macro_binding(value) {
    ctx[28](value);
  }
  __name(macroselector_macro_binding, "macroselector_macro_binding");
  let macroselector_props = {};
  if (ctx[5].macro !== void 0) {
    macroselector_props.macro = ctx[5].macro;
  }
  macroselector = new MacroSelector({ props: macroselector_props });
  binding_callbacks.push(() => bind$1(macroselector, "macro", macroselector_macro_binding));
  return {
    c() {
      div13 = element("div");
      div0 = element("div");
      label0 = element("label");
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EnabledPile")}`;
      t1 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EnabledPileExplanation")}`;
      t3 = space();
      span2 = element("span");
      if (if_block)
        if_block.c();
      t4 = space();
      span1 = element("span");
      input0 = element("input");
      t5 = space();
      div1 = element("div");
      label1 = element("label");
      span3 = element("span");
      span3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.Distance")}`;
      t7 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.GridUnits")}`;
      t9 = space();
      input1 = element("input");
      t10 = space();
      div2 = element("div");
      label2 = element("label");
      span4 = element("span");
      span4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.InspectItems")}`;
      t12 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.InspectItemsExplanation")}`;
      t14 = space();
      input2 = element("input");
      t15 = space();
      div3 = element("div");
      label3 = element("label");
      span5 = element("span");
      span5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DisplayItemTypes")}`;
      t17 = space();
      p3 = element("p");
      p3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DisplayItemTypesExplanation")}`;
      t19 = space();
      input3 = element("input");
      t20 = space();
      div4 = element("div");
      label4 = element("label");
      span6 = element("span");
      span6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.Macro")}`;
      t22 = space();
      p4 = element("p");
      p4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.MacroExplanation")}`;
      t24 = space();
      div5 = element("div");
      create_component(macroselector.$$.fragment);
      t25 = space();
      div6 = element("div");
      label5 = element("label");
      span7 = element("span");
      span7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DeleteWhenEmpty")}`;
      t27 = space();
      p5 = element("p");
      p5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DeleteWhenEmptyExplanation")}`;
      t29 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DeleteWhenEmptyDefault")}
                (${localize(ctx[8])})
              `;
      option1 = element("option");
      option1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DeleteWhenEmptyYes")}`;
      option2 = element("option");
      option2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.DeleteWhenEmptyNo")}`;
      t36 = space();
      div7 = element("div");
      label6 = element("label");
      span8 = element("span");
      span8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EditDescription")}`;
      t38 = space();
      p6 = element("p");
      p6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EditDescriptionExplanation")}`;
      t40 = space();
      div8 = element("div");
      button0 = element("button");
      button0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.EditDescription")}`;
      t42 = space();
      div9 = element("div");
      label7 = element("label");
      span9 = element("span");
      span9.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.OverrideCurrencies")}`;
      t44 = space();
      p7 = element("p");
      p7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.OverrideCurrenciesExplanation")}`;
      t46 = space();
      input4 = element("input");
      t47 = space();
      div10 = element("div");
      button1 = element("button");
      t48 = text(t48_value);
      t49 = space();
      div11 = element("div");
      label8 = element("label");
      span10 = element("span");
      span10.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.OverrideItemFilters")}`;
      t51 = space();
      p8 = element("p");
      p8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Main.OverrideItemFiltersExplanation")}`;
      t53 = space();
      input5 = element("input");
      t54 = space();
      div12 = element("div");
      button2 = element("button");
      t55 = text(t55_value);
      attr(input0, "type", "checkbox");
      set_style(span1, "flex", "0 1 auto");
      attr(span2, "class", "item-piles-flexrow");
      set_style(span2, "max-width", "100px");
      set_style(span2, "justify-content", "flex-end");
      set_style(span2, "align-items", "center");
      attr(div0, "class", "form-group");
      set_style(label1, "flex", "4");
      set_style(input1, "flex", "4");
      attr(input1, "type", "number");
      attr(input1, "placeholder", "Infinity");
      attr(div1, "class", "form-group");
      attr(input2, "type", "checkbox");
      attr(div2, "class", "form-group");
      attr(input3, "type", "checkbox");
      attr(div3, "class", "form-group");
      set_style(label4, "flex", "4");
      attr(div4, "class", "form-group");
      attr(div5, "class", "form-group");
      set_style(label5, "flex", "4");
      option0.__value = "default";
      option0.value = option0.__value;
      option1.__value = true;
      option1.value = option1.__value;
      option2.__value = false;
      option2.value = option2.__value;
      set_style(select, "flex", "4");
      if (ctx[5].deleteWhenEmpty === void 0)
        add_render_callback(() => ctx[29].call(select));
      attr(div6, "class", "form-group");
      set_style(label6, "flex", "4");
      attr(div7, "class", "form-group");
      attr(button0, "type", "button");
      set_style(button0, "flex", "4");
      attr(div8, "class", "form-group");
      set_style(label7, "flex", "4");
      attr(input4, "type", "checkbox");
      attr(div9, "class", "form-group");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = !ctx[3];
      set_style(button1, "flex", "4");
      attr(div10, "class", "form-group");
      set_style(label8, "flex", "4");
      attr(input5, "type", "checkbox");
      attr(div11, "class", "form-group");
      attr(button2, "type", "button");
      button2.disabled = button2_disabled_value = !ctx[2];
      set_style(button2, "flex", "4");
      attr(div12, "class", "form-group");
      attr(div13, "class", "tab item-piles-flexcol");
    },
    m(target, anchor) {
      insert(target, div13, anchor);
      append(div13, div0);
      append(div0, label0);
      append(label0, span0);
      append(label0, t1);
      append(label0, p0);
      append(div0, t3);
      append(div0, span2);
      if (if_block)
        if_block.m(span2, null);
      append(span2, t4);
      append(span2, span1);
      append(span1, input0);
      input0.checked = ctx[1];
      append(div13, t5);
      append(div13, div1);
      append(div1, label1);
      append(label1, span3);
      append(label1, t7);
      append(label1, p1);
      append(div1, t9);
      append(div1, input1);
      set_input_value(input1, ctx[5].distance);
      append(div13, t10);
      append(div13, div2);
      append(div2, label2);
      append(label2, span4);
      append(label2, t12);
      append(label2, p2);
      append(div2, t14);
      append(div2, input2);
      input2.checked = ctx[5].canInspectItems;
      append(div13, t15);
      append(div13, div3);
      append(div3, label3);
      append(label3, span5);
      append(label3, t17);
      append(label3, p3);
      append(div3, t19);
      append(div3, input3);
      input3.checked = ctx[5].displayItemTypes;
      append(div13, t20);
      append(div13, div4);
      append(div4, label4);
      append(label4, span6);
      append(label4, t22);
      append(label4, p4);
      append(div13, t24);
      append(div13, div5);
      mount_component(macroselector, div5, null);
      append(div13, t25);
      append(div13, div6);
      append(div6, label5);
      append(label5, span7);
      append(label5, t27);
      append(label5, p5);
      append(div6, t29);
      append(div6, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      select_option(select, ctx[5].deleteWhenEmpty);
      append(div13, t36);
      append(div13, div7);
      append(div7, label6);
      append(label6, span8);
      append(label6, t38);
      append(label6, p6);
      append(div13, t40);
      append(div13, div8);
      append(div8, button0);
      append(div13, t42);
      append(div13, div9);
      append(div9, label7);
      append(label7, span9);
      append(label7, t44);
      append(label7, p7);
      append(div9, t46);
      append(div9, input4);
      input4.checked = ctx[3];
      append(div13, t47);
      append(div13, div10);
      append(div10, button1);
      append(button1, t48);
      append(div13, t49);
      append(div13, div11);
      append(div11, label8);
      append(label8, span10);
      append(label8, t51);
      append(label8, p8);
      append(div11, t53);
      append(div11, input5);
      input5.checked = ctx[2];
      append(div13, t54);
      append(div13, div12);
      append(div12, button2);
      append(button2, t55);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[24]),
          listen(input1, "input", ctx[25]),
          listen(input2, "change", ctx[26]),
          listen(input3, "change", ctx[27]),
          listen(select, "change", ctx[29]),
          listen(button0, "click", ctx[30]),
          listen(input4, "change", ctx[31]),
          listen(button1, "click", ctx[32]),
          listen(input5, "change", ctx[33]),
          listen(button2, "click", ctx[34])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_4$1();
          if_block.c();
          if_block.m(span2, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 2) {
        input0.checked = ctx2[1];
      }
      if (dirty[0] & 32 && to_number(input1.value) !== ctx2[5].distance) {
        set_input_value(input1, ctx2[5].distance);
      }
      if (dirty[0] & 32) {
        input2.checked = ctx2[5].canInspectItems;
      }
      if (dirty[0] & 32) {
        input3.checked = ctx2[5].displayItemTypes;
      }
      const macroselector_changes = {};
      if (!updating_macro && dirty[0] & 32) {
        updating_macro = true;
        macroselector_changes.macro = ctx2[5].macro;
        add_flush_callback(() => updating_macro = false);
      }
      macroselector.$set(macroselector_changes);
      if (dirty[0] & 32) {
        select_option(select, ctx2[5].deleteWhenEmpty);
      }
      if (dirty[0] & 8) {
        input4.checked = ctx2[3];
      }
      if (!current || dirty[0] & 8 && button1_disabled_value !== (button1_disabled_value = !ctx2[3])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty[0] & 4) {
        input5.checked = ctx2[2];
      }
      if (!current || dirty[0] & 4 && button2_disabled_value !== (button2_disabled_value = !ctx2[2])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(macroselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macroselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div13);
      if (if_block)
        if_block.d();
      destroy_component(macroselector);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_3$1, "create_if_block_3$1");
function create_if_block_4$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fas fa-exclamation"></i>`;
      set_style(div, "flex", "0 1 auto");
      set_style(div, "margin-right", "1rem");
      attr(div, "class", "blob");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
__name(create_if_block_4$1, "create_if_block_4$1");
function create_if_block_1$1(ctx) {
  let div26;
  let div0;
  let label0;
  let span0;
  let t1;
  let p0;
  let t3;
  let input0;
  let t4;
  let div2;
  let label1;
  let span1;
  let t6;
  let p1;
  let t8;
  let div1;
  let filepicker;
  let updating_value;
  let t9;
  let div3;
  let label2;
  let span2;
  let t11;
  let p2;
  let t13;
  let input1;
  let t14;
  let div4;
  let label3;
  let span3;
  let t16;
  let p3;
  let t18;
  let input2;
  let t19;
  let div5;
  let label4;
  let span4;
  let t21;
  let p4;
  let t23;
  let input3;
  let t24;
  let div7;
  let label5;
  let span5;
  let t26;
  let p5;
  let t28;
  let div6;
  let t29;
  let select0;
  let option0;
  let option1;
  let option2;
  let option3;
  let t37;
  let div8;
  let label6;
  let span6;
  let t39;
  let p6;
  let t41;
  let input4;
  let t42;
  let div9;
  let label7;
  let span7;
  let t44;
  let p7;
  let t46;
  let input5;
  let t47;
  let div10;
  let label8;
  let span8;
  let t49;
  let p8;
  let t51;
  let input6;
  let t52;
  let div11;
  let label9;
  let span9;
  let t54;
  let p9;
  let t56;
  let div12;
  let label10;
  let span10;
  let t58;
  let sliderinput0;
  let updating_value_1;
  let t59;
  let div13;
  let label11;
  let span11;
  let t61;
  let sliderinput1;
  let updating_value_2;
  let t62;
  let div15;
  let div14;
  let label12;
  let span12;
  let t64;
  let p10;
  let t66;
  let button0;
  let t68;
  let div17;
  let div16;
  let label13;
  let span13;
  let t70;
  let p11;
  let t72;
  let button1;
  let t74;
  let div19;
  let label14;
  let span14;
  let t76;
  let p12;
  let t78;
  let div18;
  let t79;
  let select1;
  let option4;
  let option5;
  let t84;
  let div20;
  let label15;
  let span15;
  let t86;
  let p13;
  let t88;
  let input7;
  let t89;
  let div25;
  let div22;
  let label16;
  let t91;
  let div21;
  let input8;
  let input8_disabled_value;
  let t92;
  let span16;
  let t94;
  let input9;
  let input9_disabled_value;
  let t95;
  let div24;
  let label17;
  let t97;
  let div23;
  let input10;
  let input10_disabled_value;
  let t98;
  let span17;
  let t100;
  let input11;
  let input11_disabled_value;
  let current;
  let mounted;
  let dispose;
  function filepicker_value_binding(value) {
    ctx[36](value);
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  let filepicker_props = {
    type: "imagevideo",
    placeholder: "path/image.png"
  };
  if (ctx[5].merchantImage !== void 0) {
    filepicker_props.value = ctx[5].merchantImage;
  }
  filepicker = new FilePicker_1({ props: filepicker_props });
  binding_callbacks.push(() => bind$1(filepicker, "value", filepicker_value_binding));
  function sliderinput0_value_binding(value) {
    ctx[44](value);
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  let sliderinput0_props = { style: "flex:4;" };
  if (ctx[5].buyPriceModifier !== void 0) {
    sliderinput0_props.value = ctx[5].buyPriceModifier;
  }
  sliderinput0 = new SliderInput({ props: sliderinput0_props });
  binding_callbacks.push(() => bind$1(sliderinput0, "value", sliderinput0_value_binding));
  function sliderinput1_value_binding(value) {
    ctx[45](value);
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  let sliderinput1_props = { style: "flex:4;" };
  if (ctx[5].sellPriceModifier !== void 0) {
    sliderinput1_props.value = ctx[5].sellPriceModifier;
  }
  sliderinput1 = new SliderInput({ props: sliderinput1_props });
  binding_callbacks.push(() => bind$1(sliderinput1, "value", sliderinput1_value_binding));
  let if_block = ctx[12] && ctx[5].openTimes.enabled && create_if_block_2$1();
  return {
    c() {
      div26 = element("div");
      div0 = element("div");
      label0 = element("label");
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.Enabled")}`;
      t1 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.EnabledExplanation")}`;
      t3 = space();
      input0 = element("input");
      t4 = space();
      div2 = element("div");
      label1 = element("label");
      span1 = element("span");
      span1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.MerchantImage")}`;
      t6 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.MerchantImageExplanation")}`;
      t8 = space();
      div1 = element("div");
      create_component(filepicker.$$.fragment);
      t9 = space();
      div3 = element("div");
      label2 = element("label");
      span2 = element("span");
      span2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.InfiniteQuantity")}`;
      t11 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.InfiniteQuantityExplanation")}`;
      t13 = space();
      input1 = element("input");
      t14 = space();
      div4 = element("div");
      label3 = element("label");
      span3 = element("span");
      span3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.InfiniteCurrency")}`;
      t16 = space();
      p3 = element("p");
      p3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.InfiniteCurrencyExplanation")}`;
      t18 = space();
      input2 = element("input");
      t19 = space();
      div5 = element("div");
      label4 = element("label");
      span4 = element("span");
      span4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.KeepZero")}`;
      t21 = space();
      p4 = element("p");
      p4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.KeepZeroExplanation")}`;
      t23 = space();
      input3 = element("input");
      t24 = space();
      div7 = element("div");
      label5 = element("label");
      span5 = element("span");
      span5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantity")}`;
      t26 = space();
      p5 = element("p");
      p5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantityExplanation")}`;
      t28 = space();
      div6 = element("div");
      t29 = space();
      select0 = element("select");
      option0 = element("option");
      option0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantityYes")} 
              `;
      option1 = element("option");
      option1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantityNo")} 
              `;
      option2 = element("option");
      option2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantityYesAlways")} 
              `;
      option3 = element("option");
      option3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.DisplayQuantityNoAlways")}`;
      t37 = space();
      div8 = element("div");
      label6 = element("label");
      span6 = element("span");
      span6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PurchaseOnly")}`;
      t39 = space();
      p6 = element("p");
      p6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PurchaseOnlyExplanation")}`;
      t41 = space();
      input4 = element("input");
      t42 = space();
      div9 = element("div");
      label7 = element("label");
      span7 = element("span");
      span7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.HideNewItems")}`;
      t44 = space();
      p7 = element("p");
      p7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.HideNewItemsExplanation")}`;
      t46 = space();
      input5 = element("input");
      t47 = space();
      div10 = element("div");
      label8 = element("label");
      span8 = element("span");
      span8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OnyAcceptBasePrice")}`;
      t49 = space();
      p8 = element("p");
      p8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OnyAcceptBasePriceExplanation")}`;
      t51 = space();
      input6 = element("input");
      t52 = space();
      div11 = element("div");
      label9 = element("label");
      span9 = element("span");
      span9.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PriceModifierTitle")}`;
      t54 = space();
      p9 = element("p");
      p9.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.PriceModifierExplanation")}`;
      t56 = space();
      div12 = element("div");
      label10 = element("label");
      span10 = element("span");
      span10.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.BuyPriceModifier")}`;
      t58 = space();
      create_component(sliderinput0.$$.fragment);
      t59 = space();
      div13 = element("div");
      label11 = element("label");
      span11 = element("span");
      span11.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.SellPriceModifier")}`;
      t61 = space();
      create_component(sliderinput1.$$.fragment);
      t62 = space();
      div15 = element("div");
      div14 = element("div");
      label12 = element("label");
      span12 = element("span");
      span12.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ItemTypeModifier")}`;
      t64 = space();
      p10 = element("p");
      p10.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ItemTypeModifiersExplanation")}`;
      t66 = space();
      button0 = element("button");
      button0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ConfigureItemTypePriceModifiers")}`;
      t68 = space();
      div17 = element("div");
      div16 = element("div");
      label13 = element("label");
      span13 = element("span");
      span13.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ActorPriceModifiers")}`;
      t70 = space();
      p11 = element("p");
      p11.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ActorPriceModifiersExplanation")}`;
      t72 = space();
      button1 = element("button");
      button1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.ConfigureActorPriceModifiers")}`;
      t74 = space();
      div19 = element("div");
      label14 = element("label");
      span14 = element("span");
      span14.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenStatus")}`;
      t76 = space();
      p12 = element("p");
      p12.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenStatusExplanation")}`;
      t78 = space();
      div18 = element("div");
      t79 = space();
      select1 = element("select");
      option4 = element("option");
      option4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenStatusOpen")} 
              `;
      option5 = element("option");
      option5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenStatusClosed")} 
              `;
      if (if_block)
        if_block.c();
      t84 = space();
      div20 = element("div");
      label15 = element("label");
      span15 = element("span");
      span15.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenTimes")}`;
      t86 = space();
      p13 = element("p");
      p13.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenTimesExplanation")}`;
      t88 = space();
      input7 = element("input");
      t89 = space();
      div25 = element("div");
      div22 = element("div");
      label16 = element("label");
      label16.textContent = "Open Time:";
      t91 = space();
      div21 = element("div");
      input8 = element("input");
      t92 = space();
      span16 = element("span");
      span16.textContent = ":";
      t94 = space();
      input9 = element("input");
      t95 = space();
      div24 = element("div");
      label17 = element("label");
      label17.textContent = "Close Time:";
      t97 = space();
      div23 = element("div");
      input10 = element("input");
      t98 = space();
      span17 = element("span");
      span17.textContent = ":";
      t100 = space();
      input11 = element("input");
      attr(input0, "type", "checkbox");
      attr(div0, "class", "form-group");
      attr(div1, "class", "form-fields");
      attr(div2, "class", "form-group");
      attr(input1, "type", "checkbox");
      attr(div3, "class", "form-group");
      attr(input2, "type", "checkbox");
      attr(div4, "class", "form-group");
      attr(input3, "type", "checkbox");
      attr(div5, "class", "form-group");
      attr(div6, "class", "break");
      option0.__value = "yes";
      option0.value = option0.__value;
      option1.__value = "no";
      option1.value = option1.__value;
      option2.__value = "alwaysyes";
      option2.value = option2.__value;
      option3.__value = "alwaysno";
      option3.value = option3.__value;
      set_style(select0, "flex", "4");
      if (ctx[5].displayQuantity === void 0)
        add_render_callback(() => ctx[40].call(select0));
      attr(div7, "class", "form-group");
      attr(input4, "type", "checkbox");
      attr(div8, "class", "form-group");
      attr(input5, "type", "checkbox");
      attr(div9, "class", "form-group");
      attr(input6, "type", "checkbox");
      attr(div10, "class", "form-group");
      set_style(label9, "flex", "3");
      attr(div11, "class", "form-group slider-group");
      set_style(label10, "flex", "3");
      attr(div12, "class", "form-group slider-group");
      set_style(label11, "flex", "3");
      attr(div13, "class", "form-group slider-group");
      attr(button0, "type", "button");
      attr(div14, "class", "item-piles-flexcol");
      attr(div15, "class", "form-group");
      attr(button1, "type", "button");
      attr(div16, "class", "item-piles-flexcol");
      attr(div17, "class", "form-group");
      attr(div18, "class", "break");
      option4.__value = "open";
      option4.value = option4.__value;
      option5.__value = "closed";
      option5.value = option5.__value;
      set_style(select1, "flex", "4");
      if (ctx[5].openTimes.status === void 0)
        add_render_callback(() => ctx[48].call(select1));
      attr(div19, "class", "form-group");
      attr(input7, "type", "checkbox");
      attr(div20, "class", "form-group");
      attr(label16, "class", "item-piles-text-center");
      attr(input8, "type", "number");
      set_style(input8, "text-align", "right");
      input8.disabled = input8_disabled_value = !ctx[5].openTimes.enabled;
      set_style(span16, "flex", "0");
      set_style(span16, "line-height", "1.7");
      set_style(span16, "margin", "0 0.25rem");
      attr(input9, "type", "number");
      input9.disabled = input9_disabled_value = !ctx[5].openTimes.enabled;
      attr(div21, "class", "item-piles-flexrow");
      attr(div22, "class", "item-piles-flexcol");
      set_style(div22, "margin-right", "1rem");
      attr(label17, "class", "item-piles-text-center");
      attr(input10, "type", "number");
      set_style(input10, "text-align", "right");
      input10.disabled = input10_disabled_value = !ctx[5].openTimes.enabled;
      set_style(span17, "flex", "0");
      set_style(span17, "line-height", "1.7");
      set_style(span17, "margin", "0 0.25rem");
      attr(input11, "type", "number");
      input11.disabled = input11_disabled_value = !ctx[5].openTimes.enabled;
      attr(div23, "class", "item-piles-flexrow");
      attr(div24, "class", "item-piles-flexcol");
      attr(div25, "class", "form-group item-piles-open-times-container");
      toggle_class(div25, "item-piles-disabled", !ctx[5].openTimes.enabled);
      attr(div26, "class", "tab flex");
    },
    m(target, anchor) {
      insert(target, div26, anchor);
      append(div26, div0);
      append(div0, label0);
      append(label0, span0);
      append(label0, t1);
      append(label0, p0);
      append(div0, t3);
      append(div0, input0);
      input0.checked = ctx[5].isMerchant;
      append(div26, t4);
      append(div26, div2);
      append(div2, label1);
      append(label1, span1);
      append(label1, t6);
      append(label1, p1);
      append(div2, t8);
      append(div2, div1);
      mount_component(filepicker, div1, null);
      append(div26, t9);
      append(div26, div3);
      append(div3, label2);
      append(label2, span2);
      append(label2, t11);
      append(label2, p2);
      append(div3, t13);
      append(div3, input1);
      input1.checked = ctx[5].infiniteQuantity;
      append(div26, t14);
      append(div26, div4);
      append(div4, label3);
      append(label3, span3);
      append(label3, t16);
      append(label3, p3);
      append(div4, t18);
      append(div4, input2);
      input2.checked = ctx[5].infiniteCurrencies;
      append(div26, t19);
      append(div26, div5);
      append(div5, label4);
      append(label4, span4);
      append(label4, t21);
      append(label4, p4);
      append(div5, t23);
      append(div5, input3);
      input3.checked = ctx[5].keepZeroQuantity;
      append(div26, t24);
      append(div26, div7);
      append(div7, label5);
      append(label5, span5);
      append(label5, t26);
      append(label5, p5);
      append(div7, t28);
      append(div7, div6);
      append(div7, t29);
      append(div7, select0);
      append(select0, option0);
      append(select0, option1);
      append(select0, option2);
      append(select0, option3);
      select_option(select0, ctx[5].displayQuantity);
      append(div26, t37);
      append(div26, div8);
      append(div8, label6);
      append(label6, span6);
      append(label6, t39);
      append(label6, p6);
      append(div8, t41);
      append(div8, input4);
      input4.checked = ctx[5].purchaseOnly;
      append(div26, t42);
      append(div26, div9);
      append(div9, label7);
      append(label7, span7);
      append(label7, t44);
      append(label7, p7);
      append(div9, t46);
      append(div9, input5);
      input5.checked = ctx[5].hideNewItems;
      append(div26, t47);
      append(div26, div10);
      append(div10, label8);
      append(label8, span8);
      append(label8, t49);
      append(label8, p8);
      append(div10, t51);
      append(div10, input6);
      input6.checked = ctx[5].onlyAcceptBasePrice;
      append(div26, t52);
      append(div26, div11);
      append(div11, label9);
      append(label9, span9);
      append(label9, t54);
      append(label9, p9);
      append(div26, t56);
      append(div26, div12);
      append(div12, label10);
      append(label10, span10);
      append(div12, t58);
      mount_component(sliderinput0, div12, null);
      append(div26, t59);
      append(div26, div13);
      append(div13, label11);
      append(label11, span11);
      append(div13, t61);
      mount_component(sliderinput1, div13, null);
      append(div26, t62);
      append(div26, div15);
      append(div15, div14);
      append(div14, label12);
      append(label12, span12);
      append(label12, t64);
      append(label12, p10);
      append(div14, t66);
      append(div14, button0);
      append(div26, t68);
      append(div26, div17);
      append(div17, div16);
      append(div16, label13);
      append(label13, span13);
      append(label13, t70);
      append(label13, p11);
      append(div16, t72);
      append(div16, button1);
      append(div26, t74);
      append(div26, div19);
      append(div19, label14);
      append(label14, span14);
      append(label14, t76);
      append(label14, p12);
      append(div19, t78);
      append(div19, div18);
      append(div19, t79);
      append(div19, select1);
      append(select1, option4);
      append(select1, option5);
      if (if_block)
        if_block.m(select1, null);
      select_option(select1, ctx[5].openTimes.status);
      append(div26, t84);
      append(div26, div20);
      append(div20, label15);
      append(label15, span15);
      append(label15, t86);
      append(label15, p13);
      append(div20, t88);
      append(div20, input7);
      input7.checked = ctx[5].openTimes.enabled;
      append(div26, t89);
      append(div26, div25);
      append(div25, div22);
      append(div22, label16);
      append(div22, t91);
      append(div22, div21);
      append(div21, input8);
      set_input_value(input8, ctx[5].openTimes.open.hour);
      append(div21, t92);
      append(div21, span16);
      append(div21, t94);
      append(div21, input9);
      set_input_value(input9, ctx[5].openTimes.open.minute);
      append(div25, t95);
      append(div25, div24);
      append(div24, label17);
      append(div24, t97);
      append(div24, div23);
      append(div23, input10);
      set_input_value(input10, ctx[5].openTimes.close.hour);
      append(div23, t98);
      append(div23, span17);
      append(div23, t100);
      append(div23, input11);
      set_input_value(input11, ctx[5].openTimes.close.minute);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[35]),
          listen(input1, "change", ctx[37]),
          listen(input2, "change", ctx[38]),
          listen(input3, "change", ctx[39]),
          listen(select0, "change", ctx[40]),
          listen(input4, "change", ctx[41]),
          listen(input5, "change", ctx[42]),
          listen(input6, "change", ctx[43]),
          listen(button0, "click", ctx[46]),
          listen(button1, "click", ctx[47]),
          listen(select1, "change", ctx[48]),
          listen(input7, "change", ctx[49]),
          listen(input8, "input", ctx[50]),
          listen(input9, "input", ctx[51]),
          listen(input10, "input", ctx[52]),
          listen(input11, "input", ctx[53])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32) {
        input0.checked = ctx2[5].isMerchant;
      }
      const filepicker_changes = {};
      if (!updating_value && dirty[0] & 32) {
        updating_value = true;
        filepicker_changes.value = ctx2[5].merchantImage;
        add_flush_callback(() => updating_value = false);
      }
      filepicker.$set(filepicker_changes);
      if (dirty[0] & 32) {
        input1.checked = ctx2[5].infiniteQuantity;
      }
      if (dirty[0] & 32) {
        input2.checked = ctx2[5].infiniteCurrencies;
      }
      if (dirty[0] & 32) {
        input3.checked = ctx2[5].keepZeroQuantity;
      }
      if (dirty[0] & 32) {
        select_option(select0, ctx2[5].displayQuantity);
      }
      if (dirty[0] & 32) {
        input4.checked = ctx2[5].purchaseOnly;
      }
      if (dirty[0] & 32) {
        input5.checked = ctx2[5].hideNewItems;
      }
      if (dirty[0] & 32) {
        input6.checked = ctx2[5].onlyAcceptBasePrice;
      }
      const sliderinput0_changes = {};
      if (!updating_value_1 && dirty[0] & 32) {
        updating_value_1 = true;
        sliderinput0_changes.value = ctx2[5].buyPriceModifier;
        add_flush_callback(() => updating_value_1 = false);
      }
      sliderinput0.$set(sliderinput0_changes);
      const sliderinput1_changes = {};
      if (!updating_value_2 && dirty[0] & 32) {
        updating_value_2 = true;
        sliderinput1_changes.value = ctx2[5].sellPriceModifier;
        add_flush_callback(() => updating_value_2 = false);
      }
      sliderinput1.$set(sliderinput1_changes);
      if (ctx2[12] && ctx2[5].openTimes.enabled) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1();
          if_block.c();
          if_block.m(select1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 32) {
        select_option(select1, ctx2[5].openTimes.status);
      }
      if (dirty[0] & 32) {
        input7.checked = ctx2[5].openTimes.enabled;
      }
      if (!current || dirty[0] & 32 && input8_disabled_value !== (input8_disabled_value = !ctx2[5].openTimes.enabled)) {
        input8.disabled = input8_disabled_value;
      }
      if (dirty[0] & 32 && to_number(input8.value) !== ctx2[5].openTimes.open.hour) {
        set_input_value(input8, ctx2[5].openTimes.open.hour);
      }
      if (!current || dirty[0] & 32 && input9_disabled_value !== (input9_disabled_value = !ctx2[5].openTimes.enabled)) {
        input9.disabled = input9_disabled_value;
      }
      if (dirty[0] & 32 && to_number(input9.value) !== ctx2[5].openTimes.open.minute) {
        set_input_value(input9, ctx2[5].openTimes.open.minute);
      }
      if (!current || dirty[0] & 32 && input10_disabled_value !== (input10_disabled_value = !ctx2[5].openTimes.enabled)) {
        input10.disabled = input10_disabled_value;
      }
      if (dirty[0] & 32 && to_number(input10.value) !== ctx2[5].openTimes.close.hour) {
        set_input_value(input10, ctx2[5].openTimes.close.hour);
      }
      if (!current || dirty[0] & 32 && input11_disabled_value !== (input11_disabled_value = !ctx2[5].openTimes.enabled)) {
        input11.disabled = input11_disabled_value;
      }
      if (dirty[0] & 32 && to_number(input11.value) !== ctx2[5].openTimes.close.minute) {
        set_input_value(input11, ctx2[5].openTimes.close.minute);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div25, "item-piles-disabled", !ctx2[5].openTimes.enabled);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      transition_in(sliderinput0.$$.fragment, local);
      transition_in(sliderinput1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      transition_out(sliderinput0.$$.fragment, local);
      transition_out(sliderinput1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div26);
      destroy_component(filepicker);
      destroy_component(sliderinput0);
      destroy_component(sliderinput1);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block_1$1, "create_if_block_1$1");
function create_if_block_2$1(ctx) {
  let option;
  return {
    c() {
      option = element("option");
      option.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Merchant.OpenStatusAuto")}`;
      option.__value = "auto";
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_if_block_2$1, "create_if_block_2$1");
function create_if_block$3(ctx) {
  let div29;
  let details0;
  let summary0;
  let t1;
  let strong;
  let t3;
  let div0;
  let label0;
  let span0;
  let t5;
  let p0;
  let t7;
  let input0;
  let t8;
  let div4;
  let div1;
  let label1;
  let span1;
  let t10;
  let p1;
  let t12;
  let input1;
  let t13;
  let div2;
  let label2;
  let span2;
  let t15;
  let input2;
  let t16;
  let div3;
  let label3;
  let span3;
  let t18;
  let input3;
  let input3_disabled_value;
  let t19;
  let input4;
  let input4_disabled_value;
  let t20;
  let details1;
  let summary1;
  let t22;
  let div5;
  let label4;
  let t24;
  let input5;
  let t25;
  let div6;
  let label5;
  let t27;
  let input6;
  let t28;
  let div7;
  let label6;
  let t30;
  let input7;
  let t31;
  let div9;
  let label7;
  let t33;
  let div8;
  let filepicker0;
  let updating_value;
  let t34;
  let div11;
  let label8;
  let t36;
  let div10;
  let filepicker1;
  let updating_value_1;
  let t37;
  let div13;
  let label9;
  let t39;
  let div12;
  let filepicker2;
  let updating_value_2;
  let t40;
  let div15;
  let label10;
  let t42;
  let div14;
  let filepicker3;
  let updating_value_3;
  let t43;
  let div17;
  let label11;
  let t45;
  let div16;
  let filepicker4;
  let updating_value_4;
  let t46;
  let div19;
  let label12;
  let t48;
  let div18;
  let filepicker5;
  let updating_value_5;
  let t49;
  let div21;
  let label13;
  let t51;
  let div20;
  let filepicker6;
  let updating_value_6;
  let t52;
  let details2;
  let summary2;
  let t54;
  let div22;
  let label14;
  let span4;
  let t56;
  let p2;
  let t58;
  let input8;
  let t59;
  let div23;
  let label15;
  let span5;
  let t61;
  let p3;
  let t63;
  let input9;
  let t64;
  let div24;
  let label16;
  let span6;
  let t66;
  let p4;
  let t68;
  let input10;
  let t69;
  let div25;
  let label17;
  let span7;
  let t71;
  let p5;
  let t73;
  let input11;
  let t74;
  let div26;
  let label18;
  let span8;
  let t76;
  let p6;
  let t78;
  let input12;
  let t79;
  let div27;
  let label19;
  let span9;
  let t81;
  let p7;
  let t83;
  let div28;
  let button;
  let current;
  let mounted;
  let dispose;
  function filepicker0_value_binding(value) {
    ctx[62](value);
  }
  __name(filepicker0_value_binding, "filepicker0_value_binding");
  let filepicker0_props = {
    type: "imagevideo",
    placeholder: "path/image.png"
  };
  if (ctx[5].closedImage !== void 0) {
    filepicker0_props.value = ctx[5].closedImage;
  }
  filepicker0 = new FilePicker_1({ props: filepicker0_props });
  binding_callbacks.push(() => bind$1(filepicker0, "value", filepicker0_value_binding));
  function filepicker1_value_binding(value) {
    ctx[63](value);
  }
  __name(filepicker1_value_binding, "filepicker1_value_binding");
  let filepicker1_props = {
    type: "imagevideo",
    placeholder: "path/image.png"
  };
  if (ctx[5].openedImage !== void 0) {
    filepicker1_props.value = ctx[5].openedImage;
  }
  filepicker1 = new FilePicker_1({ props: filepicker1_props });
  binding_callbacks.push(() => bind$1(filepicker1, "value", filepicker1_value_binding));
  function filepicker2_value_binding(value) {
    ctx[64](value);
  }
  __name(filepicker2_value_binding, "filepicker2_value_binding");
  let filepicker2_props = {
    type: "imagevideo",
    placeholder: "path/image.png"
  };
  if (ctx[5].emptyImage !== void 0) {
    filepicker2_props.value = ctx[5].emptyImage;
  }
  filepicker2 = new FilePicker_1({ props: filepicker2_props });
  binding_callbacks.push(() => bind$1(filepicker2, "value", filepicker2_value_binding));
  function filepicker3_value_binding(value) {
    ctx[65](value);
  }
  __name(filepicker3_value_binding, "filepicker3_value_binding");
  let filepicker3_props = {
    type: "imagevideo",
    placeholder: "path/image.png"
  };
  if (ctx[5].lockedImage !== void 0) {
    filepicker3_props.value = ctx[5].lockedImage;
  }
  filepicker3 = new FilePicker_1({ props: filepicker3_props });
  binding_callbacks.push(() => bind$1(filepicker3, "value", filepicker3_value_binding));
  function filepicker4_value_binding(value) {
    ctx[66](value);
  }
  __name(filepicker4_value_binding, "filepicker4_value_binding");
  let filepicker4_props = {
    type: "audio",
    placeholder: "path/sound.wav"
  };
  if (ctx[5].closeSound !== void 0) {
    filepicker4_props.value = ctx[5].closeSound;
  }
  filepicker4 = new FilePicker_1({ props: filepicker4_props });
  binding_callbacks.push(() => bind$1(filepicker4, "value", filepicker4_value_binding));
  function filepicker5_value_binding(value) {
    ctx[67](value);
  }
  __name(filepicker5_value_binding, "filepicker5_value_binding");
  let filepicker5_props = {
    type: "audio",
    placeholder: "path/sound.wav"
  };
  if (ctx[5].openSound !== void 0) {
    filepicker5_props.value = ctx[5].openSound;
  }
  filepicker5 = new FilePicker_1({ props: filepicker5_props });
  binding_callbacks.push(() => bind$1(filepicker5, "value", filepicker5_value_binding));
  function filepicker6_value_binding(value) {
    ctx[68](value);
  }
  __name(filepicker6_value_binding, "filepicker6_value_binding");
  let filepicker6_props = {
    type: "audio",
    placeholder: "path/sound.wav"
  };
  if (ctx[5].lockedSound !== void 0) {
    filepicker6_props.value = ctx[5].lockedSound;
  }
  filepicker6 = new FilePicker_1({ props: filepicker6_props });
  binding_callbacks.push(() => bind$1(filepicker6, "value", filepicker6_value_binding));
  return {
    c() {
      div29 = element("div");
      details0 = element("details");
      summary0 = element("summary");
      summary0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.Title")}`;
      t1 = space();
      strong = element("strong");
      strong.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.DisplayOneContainerWarning")}`;
      t3 = space();
      div0 = element("div");
      label0 = element("label");
      span0 = element("span");
      span0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.DisplayOne")}`;
      t5 = space();
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.DisplayOneExplanation")}`;
      t7 = space();
      input0 = element("input");
      t8 = space();
      div4 = element("div");
      div1 = element("div");
      label1 = element("label");
      span1 = element("span");
      span1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.ItemName")}`;
      t10 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.ItemNameExplanation")}`;
      t12 = space();
      input1 = element("input");
      t13 = space();
      div2 = element("div");
      label2 = element("label");
      span2 = element("span");
      span2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.OverrideScale")}`;
      t15 = space();
      input2 = element("input");
      t16 = space();
      div3 = element("div");
      label3 = element("label");
      span3 = element("span");
      span3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.SingleItem.Scale")}`;
      t18 = space();
      input3 = element("input");
      t19 = space();
      input4 = element("input");
      t20 = space();
      details1 = element("details");
      summary1 = element("summary");
      summary1.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.Title")}`;
      t22 = space();
      div5 = element("div");
      label4 = element("label");
      label4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.IsContainer")}`;
      t24 = space();
      input5 = element("input");
      t25 = space();
      div6 = element("div");
      label5 = element("label");
      label5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.Closed")}`;
      t27 = space();
      input6 = element("input");
      t28 = space();
      div7 = element("div");
      label6 = element("label");
      label6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.Locked")}`;
      t30 = space();
      input7 = element("input");
      t31 = space();
      div9 = element("div");
      label7 = element("label");
      label7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.ClosedImagePath")}`;
      t33 = space();
      div8 = element("div");
      create_component(filepicker0.$$.fragment);
      t34 = space();
      div11 = element("div");
      label8 = element("label");
      label8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.OpenedImagePath")}`;
      t36 = space();
      div10 = element("div");
      create_component(filepicker1.$$.fragment);
      t37 = space();
      div13 = element("div");
      label9 = element("label");
      label9.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.EmptyImagePath")}`;
      t39 = space();
      div12 = element("div");
      create_component(filepicker2.$$.fragment);
      t40 = space();
      div15 = element("div");
      label10 = element("label");
      label10.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.LockedImagePath")}`;
      t42 = space();
      div14 = element("div");
      create_component(filepicker3.$$.fragment);
      t43 = space();
      div17 = element("div");
      label11 = element("label");
      label11.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.CloseSoundPath")}`;
      t45 = space();
      div16 = element("div");
      create_component(filepicker4.$$.fragment);
      t46 = space();
      div19 = element("div");
      label12 = element("label");
      label12.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.OpenSoundPath")}`;
      t48 = space();
      div18 = element("div");
      create_component(filepicker5.$$.fragment);
      t49 = space();
      div21 = element("div");
      label13 = element("label");
      label13.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Container.LockedSoundPath")}`;
      t51 = space();
      div20 = element("div");
      create_component(filepicker6.$$.fragment);
      t52 = space();
      details2 = element("details");
      summary2 = element("summary");
      summary2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.Title")}`;
      t54 = space();
      div22 = element("div");
      label14 = element("label");
      span4 = element("span");
      span4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ShareItemsEnabled")}`;
      t56 = space();
      p2 = element("p");
      p2.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ShareItemsEnabledExplanation")}`;
      t58 = space();
      input8 = element("input");
      t59 = space();
      div23 = element("div");
      label15 = element("label");
      span5 = element("span");
      span5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ShareCurrenciesEnabled")}`;
      t61 = space();
      p3 = element("p");
      p3.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ShareCurrenciesEnabledExplanation")}`;
      t63 = space();
      input9 = element("input");
      t64 = space();
      div24 = element("div");
      label16 = element("label");
      span6 = element("span");
      span6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.TakeAllEnabled")}`;
      t66 = space();
      p4 = element("p");
      p4.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.TakeAllEnabledExplanation")}`;
      t68 = space();
      input10 = element("input");
      t69 = space();
      div25 = element("div");
      label17 = element("label");
      span7 = element("span");
      span7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.SplitAllEnabled")}`;
      t71 = space();
      p5 = element("p");
      p5.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.SplitAllEnabledExplanation")}`;
      t73 = space();
      input11 = element("input");
      t74 = space();
      div26 = element("div");
      label18 = element("label");
      span8 = element("span");
      span8.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.InactivePlayers")}`;
      t76 = space();
      p6 = element("p");
      p6.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.InactivePlayersExplanation")}`;
      t78 = space();
      input12 = element("input");
      t79 = space();
      div27 = element("div");
      label19 = element("label");
      span9 = element("span");
      span9.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ResetSharingData")}`;
      t81 = space();
      p7 = element("p");
      p7.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ResetSharingDataExplanation")}`;
      t83 = space();
      div28 = element("div");
      button = element("button");
      button.textContent = `${localize("ITEM-PILES.Applications.ItemPileConfig.Sharing.ResetSharingData")}`;
      attr(strong, "class", "display-one-warning");
      set_style(strong, "display", "none");
      attr(input0, "type", "checkbox");
      attr(div0, "class", "form-group");
      attr(input1, "type", "checkbox");
      attr(div1, "class", "form-group");
      attr(input2, "type", "checkbox");
      attr(div2, "class", "form-group");
      set_style(label3, "flex", "3");
      set_style(input3, "flex", "3");
      attr(input3, "type", "range");
      attr(input3, "min", "0.2");
      attr(input3, "step", "0.01");
      attr(input3, "max", "3");
      attr(input3, "class", "item-piles-scaleRange");
      input3.disabled = input3_disabled_value = !ctx[5].overrideSingleItemScale;
      set_style(input4, "flex", "0.5");
      set_style(input4, "margin-left", "1rem");
      attr(input4, "type", "number");
      attr(input4, "step", "0.01");
      attr(input4, "class", "item-piles-scaleInput");
      input4.disabled = input4_disabled_value = !ctx[5].overrideSingleItemScale;
      attr(div3, "class", "form-group");
      toggle_class(div3, "item-piles-disabled", !ctx[5].overrideSingleItemScale);
      attr(div4, "class", "item-pile-display-one-settings");
      attr(details0, "class", "item-piles-collapsible item-piles-clickable");
      attr(input5, "type", "checkbox");
      attr(div5, "class", "form-group");
      attr(input6, "type", "checkbox");
      attr(div6, "class", "form-group");
      attr(input7, "type", "checkbox");
      attr(div7, "class", "form-group");
      attr(div8, "class", "form-fields");
      attr(div9, "class", "form-group");
      attr(div10, "class", "form-fields");
      attr(div11, "class", "form-group");
      attr(div12, "class", "form-fields");
      attr(div13, "class", "form-group");
      attr(div14, "class", "form-fields");
      attr(div15, "class", "form-group");
      attr(div16, "class", "form-fields");
      attr(div17, "class", "form-group");
      attr(div18, "class", "form-fields");
      attr(div19, "class", "form-group");
      attr(div20, "class", "form-fields");
      attr(div21, "class", "form-group");
      attr(details1, "class", "item-piles-collapsible item-piles-clickable");
      attr(input8, "type", "checkbox");
      attr(div22, "class", "form-group");
      attr(input9, "type", "checkbox");
      attr(div23, "class", "form-group");
      attr(input10, "type", "checkbox");
      attr(div24, "class", "form-group");
      attr(input11, "type", "checkbox");
      attr(div25, "class", "form-group");
      attr(input12, "type", "checkbox");
      attr(div26, "class", "form-group");
      set_style(label19, "flex", "4");
      attr(div27, "class", "form-group");
      attr(button, "type", "button");
      attr(button, "class", "item-piles-config-reset-sharing-data");
      set_style(button, "flex", "4");
      attr(div28, "class", "form-group");
      attr(details2, "class", "item-piles-collapsible item-piles-clickable");
      attr(div29, "class", "tab othersettings flex item-piles-grow");
      attr(div29, "data-group", "primary");
      attr(div29, "data-tab", "othersettings");
      toggle_class(div29, "active", ctx[7] === "othersettings");
    },
    m(target, anchor) {
      insert(target, div29, anchor);
      append(div29, details0);
      append(details0, summary0);
      append(details0, t1);
      append(details0, strong);
      append(details0, t3);
      append(details0, div0);
      append(div0, label0);
      append(label0, span0);
      append(label0, t5);
      append(label0, p0);
      append(div0, t7);
      append(div0, input0);
      input0.checked = ctx[5].displayOne;
      append(details0, t8);
      append(details0, div4);
      append(div4, div1);
      append(div1, label1);
      append(label1, span1);
      append(label1, t10);
      append(label1, p1);
      append(div1, t12);
      append(div1, input1);
      input1.checked = ctx[5].showItemName;
      append(div4, t13);
      append(div4, div2);
      append(div2, label2);
      append(label2, span2);
      append(div2, t15);
      append(div2, input2);
      input2.checked = ctx[5].overrideSingleItemScale;
      append(div4, t16);
      append(div4, div3);
      append(div3, label3);
      append(label3, span3);
      append(div3, t18);
      append(div3, input3);
      set_input_value(input3, ctx[5].singleItemScale);
      append(div3, t19);
      append(div3, input4);
      set_input_value(input4, ctx[5].singleItemScale);
      append(div29, t20);
      append(div29, details1);
      append(details1, summary1);
      append(details1, t22);
      append(details1, div5);
      append(div5, label4);
      append(div5, t24);
      append(div5, input5);
      input5.checked = ctx[5].isContainer;
      append(details1, t25);
      append(details1, div6);
      append(div6, label5);
      append(div6, t27);
      append(div6, input6);
      input6.checked = ctx[5].closed;
      append(details1, t28);
      append(details1, div7);
      append(div7, label6);
      append(div7, t30);
      append(div7, input7);
      input7.checked = ctx[5].locked;
      append(details1, t31);
      append(details1, div9);
      append(div9, label7);
      append(div9, t33);
      append(div9, div8);
      mount_component(filepicker0, div8, null);
      append(details1, t34);
      append(details1, div11);
      append(div11, label8);
      append(div11, t36);
      append(div11, div10);
      mount_component(filepicker1, div10, null);
      append(details1, t37);
      append(details1, div13);
      append(div13, label9);
      append(div13, t39);
      append(div13, div12);
      mount_component(filepicker2, div12, null);
      append(details1, t40);
      append(details1, div15);
      append(div15, label10);
      append(div15, t42);
      append(div15, div14);
      mount_component(filepicker3, div14, null);
      append(details1, t43);
      append(details1, div17);
      append(div17, label11);
      append(div17, t45);
      append(div17, div16);
      mount_component(filepicker4, div16, null);
      append(details1, t46);
      append(details1, div19);
      append(div19, label12);
      append(div19, t48);
      append(div19, div18);
      mount_component(filepicker5, div18, null);
      append(details1, t49);
      append(details1, div21);
      append(div21, label13);
      append(div21, t51);
      append(div21, div20);
      mount_component(filepicker6, div20, null);
      append(div29, t52);
      append(div29, details2);
      append(details2, summary2);
      append(details2, t54);
      append(details2, div22);
      append(div22, label14);
      append(label14, span4);
      append(label14, t56);
      append(label14, p2);
      append(div22, t58);
      append(div22, input8);
      input8.checked = ctx[5].shareItemsEnabled;
      append(details2, t59);
      append(details2, div23);
      append(div23, label15);
      append(label15, span5);
      append(label15, t61);
      append(label15, p3);
      append(div23, t63);
      append(div23, input9);
      input9.checked = ctx[5].shareCurrenciesEnabled;
      append(details2, t64);
      append(details2, div24);
      append(div24, label16);
      append(label16, span6);
      append(label16, t66);
      append(label16, p4);
      append(div24, t68);
      append(div24, input10);
      input10.checked = ctx[5].takeAllEnabled;
      append(details2, t69);
      append(details2, div25);
      append(div25, label17);
      append(label17, span7);
      append(label17, t71);
      append(label17, p5);
      append(div25, t73);
      append(div25, input11);
      input11.checked = ctx[5].splitAllEnabled;
      append(details2, t74);
      append(details2, div26);
      append(div26, label18);
      append(label18, span8);
      append(label18, t76);
      append(label18, p6);
      append(div26, t78);
      append(div26, input12);
      input12.checked = ctx[5].activePlayers;
      append(details2, t79);
      append(details2, div27);
      append(div27, label19);
      append(label19, span9);
      append(label19, t81);
      append(label19, p7);
      append(details2, t83);
      append(details2, div28);
      append(div28, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[54]),
          listen(input1, "change", ctx[55]),
          listen(input2, "change", ctx[56]),
          listen(input3, "change", ctx[57]),
          listen(input3, "input", ctx[57]),
          listen(input4, "input", ctx[58]),
          listen(input5, "change", ctx[59]),
          listen(input6, "change", ctx[60]),
          listen(input7, "change", ctx[61]),
          listen(input8, "change", ctx[69]),
          listen(input9, "change", ctx[70]),
          listen(input10, "change", ctx[71]),
          listen(input11, "change", ctx[72]),
          listen(input12, "change", ctx[73]),
          listen(button, "click", ctx[74])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32) {
        input0.checked = ctx2[5].displayOne;
      }
      if (dirty[0] & 32) {
        input1.checked = ctx2[5].showItemName;
      }
      if (dirty[0] & 32) {
        input2.checked = ctx2[5].overrideSingleItemScale;
      }
      if (!current || dirty[0] & 32 && input3_disabled_value !== (input3_disabled_value = !ctx2[5].overrideSingleItemScale)) {
        input3.disabled = input3_disabled_value;
      }
      if (dirty[0] & 32) {
        set_input_value(input3, ctx2[5].singleItemScale);
      }
      if (!current || dirty[0] & 32 && input4_disabled_value !== (input4_disabled_value = !ctx2[5].overrideSingleItemScale)) {
        input4.disabled = input4_disabled_value;
      }
      if (dirty[0] & 32 && to_number(input4.value) !== ctx2[5].singleItemScale) {
        set_input_value(input4, ctx2[5].singleItemScale);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div3, "item-piles-disabled", !ctx2[5].overrideSingleItemScale);
      }
      if (dirty[0] & 32) {
        input5.checked = ctx2[5].isContainer;
      }
      if (dirty[0] & 32) {
        input6.checked = ctx2[5].closed;
      }
      if (dirty[0] & 32) {
        input7.checked = ctx2[5].locked;
      }
      const filepicker0_changes = {};
      if (!updating_value && dirty[0] & 32) {
        updating_value = true;
        filepicker0_changes.value = ctx2[5].closedImage;
        add_flush_callback(() => updating_value = false);
      }
      filepicker0.$set(filepicker0_changes);
      const filepicker1_changes = {};
      if (!updating_value_1 && dirty[0] & 32) {
        updating_value_1 = true;
        filepicker1_changes.value = ctx2[5].openedImage;
        add_flush_callback(() => updating_value_1 = false);
      }
      filepicker1.$set(filepicker1_changes);
      const filepicker2_changes = {};
      if (!updating_value_2 && dirty[0] & 32) {
        updating_value_2 = true;
        filepicker2_changes.value = ctx2[5].emptyImage;
        add_flush_callback(() => updating_value_2 = false);
      }
      filepicker2.$set(filepicker2_changes);
      const filepicker3_changes = {};
      if (!updating_value_3 && dirty[0] & 32) {
        updating_value_3 = true;
        filepicker3_changes.value = ctx2[5].lockedImage;
        add_flush_callback(() => updating_value_3 = false);
      }
      filepicker3.$set(filepicker3_changes);
      const filepicker4_changes = {};
      if (!updating_value_4 && dirty[0] & 32) {
        updating_value_4 = true;
        filepicker4_changes.value = ctx2[5].closeSound;
        add_flush_callback(() => updating_value_4 = false);
      }
      filepicker4.$set(filepicker4_changes);
      const filepicker5_changes = {};
      if (!updating_value_5 && dirty[0] & 32) {
        updating_value_5 = true;
        filepicker5_changes.value = ctx2[5].openSound;
        add_flush_callback(() => updating_value_5 = false);
      }
      filepicker5.$set(filepicker5_changes);
      const filepicker6_changes = {};
      if (!updating_value_6 && dirty[0] & 32) {
        updating_value_6 = true;
        filepicker6_changes.value = ctx2[5].lockedSound;
        add_flush_callback(() => updating_value_6 = false);
      }
      filepicker6.$set(filepicker6_changes);
      if (dirty[0] & 32) {
        input8.checked = ctx2[5].shareItemsEnabled;
      }
      if (dirty[0] & 32) {
        input9.checked = ctx2[5].shareCurrenciesEnabled;
      }
      if (dirty[0] & 32) {
        input10.checked = ctx2[5].takeAllEnabled;
      }
      if (dirty[0] & 32) {
        input11.checked = ctx2[5].splitAllEnabled;
      }
      if (dirty[0] & 32) {
        input12.checked = ctx2[5].activePlayers;
      }
      if (!current || dirty[0] & 128) {
        toggle_class(div29, "active", ctx2[7] === "othersettings");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker0.$$.fragment, local);
      transition_in(filepicker1.$$.fragment, local);
      transition_in(filepicker2.$$.fragment, local);
      transition_in(filepicker3.$$.fragment, local);
      transition_in(filepicker4.$$.fragment, local);
      transition_in(filepicker5.$$.fragment, local);
      transition_in(filepicker6.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker0.$$.fragment, local);
      transition_out(filepicker1.$$.fragment, local);
      transition_out(filepicker2.$$.fragment, local);
      transition_out(filepicker3.$$.fragment, local);
      transition_out(filepicker4.$$.fragment, local);
      transition_out(filepicker5.$$.fragment, local);
      transition_out(filepicker6.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div29);
      destroy_component(filepicker0);
      destroy_component(filepicker1);
      destroy_component(filepicker2);
      destroy_component(filepicker3);
      destroy_component(filepicker4);
      destroy_component(filepicker5);
      destroy_component(filepicker6);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_if_block$3, "create_if_block$3");
function create_default_slot$3(ctx) {
  let form_1;
  let tabs_1;
  let updating_activeTab;
  let updating_tabs;
  let t0;
  let section;
  let t1;
  let t2;
  let t3;
  let footer;
  let button;
  let i;
  let t4;
  let t5_value = localize("ITEM-PILES.Applications.ItemPileConfig.Update") + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  function tabs_1_activeTab_binding(value) {
    ctx[22](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  function tabs_1_tabs_binding(value) {
    ctx[23](value);
  }
  __name(tabs_1_tabs_binding, "tabs_1_tabs_binding");
  let tabs_1_props = {};
  if (ctx[7] !== void 0) {
    tabs_1_props.activeTab = ctx[7];
  }
  if (ctx[6] !== void 0) {
    tabs_1_props.tabs = ctx[6];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind$1(tabs_1, "activeTab", tabs_1_activeTab_binding));
  binding_callbacks.push(() => bind$1(tabs_1, "tabs", tabs_1_tabs_binding));
  let if_block0 = ctx[7] === "mainsettings" && create_if_block_3$1(ctx);
  let if_block1 = ctx[7] === "merchant" && create_if_block_1$1(ctx);
  let if_block2 = ctx[7] === "othersettings" && create_if_block$3(ctx);
  return {
    c() {
      form_1 = element("form");
      create_component(tabs_1.$$.fragment);
      t0 = space();
      section = element("section");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      footer = element("footer");
      button = element("button");
      i = element("i");
      t4 = space();
      t5 = text(t5_value);
      attr(section, "class", "tab-body");
      attr(i, "class", "far fa-save");
      attr(button, "type", "button");
      attr(form_1, "autocomplete", "off");
      attr(form_1, "class", "item-piles-config-container");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      mount_component(tabs_1, form_1, null);
      append(form_1, t0);
      append(form_1, section);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t1);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t2);
      if (if_block2)
        if_block2.m(section, null);
      append(form_1, t3);
      append(form_1, footer);
      append(footer, button);
      append(button, i);
      append(button, t4);
      append(button, t5);
      ctx[75](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[20], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[13]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty[0] & 128) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = ctx2[7];
        add_flush_callback(() => updating_activeTab = false);
      }
      if (!updating_tabs && dirty[0] & 64) {
        updating_tabs = true;
        tabs_1_changes.tabs = ctx2[6];
        add_flush_callback(() => updating_tabs = false);
      }
      tabs_1.$set(tabs_1_changes);
      if (ctx2[7] === "mainsettings") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[7] === "merchant") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[7] === "othersettings") {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(section, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(tabs_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[75](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$3, "create_default_slot$3");
function create_fragment$5(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[76](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$3] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 254 | dirty[2] & 65536) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$5, "create_fragment$5");
function instance$5($$self, $$props, $$invalidate) {
  let $pileEnabled;
  let $hasOverrideItemFilters;
  let $hasOverrideCurrencies;
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let { pileActor } = $$props;
  let form;
  let pileData = getActorFlagData(pileActor);
  let deleteWhenEmptySetting = localize(getSetting(SETTINGS.DELETE_EMPTY_PILES) ? "Yes" : "No");
  if (typeof pileData?.deleteWhenEmpty === "boolean") {
    pileData.deleteWhenEmpty = !!pileData?.deleteWhenEmpty;
  }
  let pileEnabled = writable(pileData.enabled);
  component_subscribe($$self, pileEnabled, (value) => $$invalidate(1, $pileEnabled = value));
  let hasOverrideCurrencies = writable(typeof pileData?.overrideCurrencies === "object");
  component_subscribe($$self, hasOverrideCurrencies, (value) => $$invalidate(3, $hasOverrideCurrencies = value));
  let hasOverrideItemFilters = writable(typeof pileData?.overrideItemFilters === "object");
  component_subscribe($$self, hasOverrideItemFilters, (value) => $$invalidate(2, $hasOverrideItemFilters = value));
  let simpleCalendarActive = game.modules.get("foundryvtt-simple-calendar")?.active;
  async function updateSettings() {
    let defaults = foundry.utils.duplicate(CONSTANTS.PILE_DEFAULTS);
    const types = [
      "closedImage",
      "emptyImage",
      "openedImage",
      "lockedImage",
      "closeSound",
      "openSound",
      "lockedSound",
      "unlockedSound"
    ];
    for (let type of types) {
      if (pileData[type].includes("*")) {
        $$invalidate(5, pileData[type + "s"] = await getFiles(pileData[type], { applyWildCard: true, softFail: true }), pileData);
        $$invalidate(5, pileData[type + "s"] = pileData[type + "s"] || [], pileData);
      }
    }
    const data = foundry.utils.mergeObject(defaults, pileData);
    data.deleteWhenEmpty = {
      "default": "default",
      "true": true,
      "false": false
    }[data.deleteWhenEmpty];
    const currentData = getActorFlagData(pileActor);
    const diff = Object.keys(foundry.utils.diffObject(currentData, foundry.utils.deepClone(data)));
    API.updateItemPile(pileActor, data).then(() => {
      if (diff.includes("enabled") || diff.includes("isMerchant")) {
        let closedApps = false;
        if (currentData.isMerchant) {
          if (MerchantApp.getActiveApp(pileActor.id)) {
            closedApps = true;
            MerchantApp.getActiveApp(pileActor.id).close();
          }
          if (MerchantApp.getActiveApp(pileActor?.token?.id)) {
            closedApps = true;
            MerchantApp.getActiveApp(pileActor?.token?.id).close();
          }
        } else {
          const apps = ItemPileInventoryApp.getActiveApps(pileActor.id).concat(ItemPileInventoryApp.getActiveApps(pileActor?.token?.id));
          for (let app of apps) {
            closedApps = true;
            app.close();
          }
        }
        if (closedApps || pileActor?.sheet.rendered) {
          if (data.enabled) {
            pileActor?.sheet.close();
            game.itempiles.API.renderItemPileInterface(pileActor);
          } else if (!data.enabled) {
            pileActor?.sheet.render(true);
          }
        }
      }
    });
    application.close();
  }
  __name(updateSettings, "updateSettings");
  async function showCurrenciesEditor() {
    $$invalidate(5, pileData.overrideCurrencies = pileData?.overrideCurrencies || game.itempiles.API.CURRENCIES, pileData);
    return CurrenciesEditor.show(
      pileData.overrideCurrencies,
      {
        id: `currencies-item-pile-config-${pileActor.id}`
      },
      {
        title: game.i18n.format("ITEM-PILES.Applications.CurrenciesEditor.TitleActor", { actor_name: pileActor.name })
      }
    ).then((result) => {
      $$invalidate(5, pileData.overrideCurrencies = result, pileData);
    });
  }
  __name(showCurrenciesEditor, "showCurrenciesEditor");
  async function showItemFiltersEditor() {
    $$invalidate(5, pileData.overrideItemFilters = pileData?.overrideItemFilters || game.itempiles.API.ITEM_FILTERS, pileData);
    return ItemFiltersEditor.show(
      pileData.overrideItemFilters,
      {
        id: `item-filters-item-pile-config-${pileActor.id}`
      },
      {
        title: game.i18n.format("ITEM-PILES.Applications.FilterEditor.TitleActor", { actor_name: pileActor.name })
      }
    ).then((result) => {
      $$invalidate(5, pileData.overrideItemFilters = result, pileData);
    });
  }
  __name(showItemFiltersEditor, "showItemFiltersEditor");
  async function showItemTypePriceModifiers() {
    const data = pileData.itemTypePriceModifiers || [];
    return ItemTypePriceModifiersEditor.show(
      data,
      {
        id: `item-type-price-modifier-item-pile-config-${pileActor.id}`
      },
      {
        title: game.i18n.format("ITEM-PILES.Applications.ItemTypePriceModifiersEditor.TitleActor", { actor_name: pileActor.name })
      }
    ).then((result) => {
      $$invalidate(5, pileData.itemTypePriceModifiers = result || [], pileData);
    });
  }
  __name(showItemTypePriceModifiers, "showItemTypePriceModifiers");
  async function showActorPriceModifiers() {
    const data = pileData.actorPriceModifiers || [];
    return PriceModifiersEditor.show(
      data,
      {
        id: `price-modifier-item-pile-config-${pileActor.id}`
      },
      {
        title: game.i18n.format("ITEM-PILES.Applications.PriceModifiersEditor.TitleActor", { actor_name: pileActor.name })
      }
    ).then((result) => {
      $$invalidate(5, pileData.actorPriceModifiers = result || [], pileData);
    });
  }
  __name(showActorPriceModifiers, "showActorPriceModifiers");
  async function resetSharingData() {
    const doThing = await TJSDialog.confirm({
      id: `sharing-dialog-item-pile-config-${pileActor.id}`,
      title: game.i18n.localize("ITEM-PILES.Dialogs.ResetSharingData.Title"),
      content: {
        class: CustomDialog,
        props: {
          header: "Item Piles - " + game.i18n.localize("ITEM-PILES.Dialogs.ResetSharingData.Title"),
          content: game.i18n.localize("ITEM-PILES.Dialogs.ResetSharingData.Content")
        }
      },
      buttons: {
        yes: {
          icon: '<i class="fas fa-check"></i>',
          label: game.i18n.localize("ITEM-PILES.Dialogs.ResetSharingData.Confirm")
        }
      },
      modal: true
    });
    if (!doThing)
      return;
    return clearItemPileSharingData(pileActor);
  }
  __name(resetSharingData, "resetSharingData");
  async function showDescriptionDialog() {
    return TextEditorDialog.show(pileData.description, {
      id: "item-pile-text-editor-" + pileActor.id
    }).then((result) => {
      $$invalidate(5, pileData.description = result || "", pileData);
    });
  }
  __name(showDescriptionDialog, "showDescriptionDialog");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  let tabs = [];
  let activeTab = "mainsettings";
  function tabs_1_activeTab_binding(value) {
    activeTab = value;
    $$invalidate(7, activeTab);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  function tabs_1_tabs_binding(value) {
    tabs = value;
    $$invalidate(6, tabs), $$invalidate(1, $pileEnabled);
  }
  __name(tabs_1_tabs_binding, "tabs_1_tabs_binding");
  function input0_change_handler() {
    $pileEnabled = this.checked;
    pileEnabled.set($pileEnabled);
  }
  __name(input0_change_handler, "input0_change_handler");
  function input1_input_handler() {
    pileData.distance = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input1_input_handler, "input1_input_handler");
  function input2_change_handler() {
    pileData.canInspectItems = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input2_change_handler, "input2_change_handler");
  function input3_change_handler() {
    pileData.displayItemTypes = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input3_change_handler, "input3_change_handler");
  function macroselector_macro_binding(value) {
    if ($$self.$$.not_equal(pileData.macro, value)) {
      pileData.macro = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(macroselector_macro_binding, "macroselector_macro_binding");
  function select_change_handler() {
    pileData.deleteWhenEmpty = select_value(this);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(select_change_handler, "select_change_handler");
  const click_handler = /* @__PURE__ */ __name(() => {
    showDescriptionDialog();
  }, "click_handler");
  function input4_change_handler() {
    $hasOverrideCurrencies = this.checked;
    hasOverrideCurrencies.set($hasOverrideCurrencies);
  }
  __name(input4_change_handler, "input4_change_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    showCurrenciesEditor();
  }, "click_handler_1");
  function input5_change_handler() {
    $hasOverrideItemFilters = this.checked;
    hasOverrideItemFilters.set($hasOverrideItemFilters);
  }
  __name(input5_change_handler, "input5_change_handler");
  const click_handler_22 = /* @__PURE__ */ __name(() => {
    showItemFiltersEditor();
  }, "click_handler_2");
  function input0_change_handler_1() {
    pileData.isMerchant = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input0_change_handler_1, "input0_change_handler_1");
  function filepicker_value_binding(value) {
    if ($$self.$$.not_equal(pileData.merchantImage, value)) {
      pileData.merchantImage = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker_value_binding, "filepicker_value_binding");
  function input1_change_handler() {
    pileData.infiniteQuantity = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input1_change_handler, "input1_change_handler");
  function input2_change_handler_1() {
    pileData.infiniteCurrencies = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input2_change_handler_1, "input2_change_handler_1");
  function input3_change_handler_1() {
    pileData.keepZeroQuantity = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input3_change_handler_1, "input3_change_handler_1");
  function select0_change_handler() {
    pileData.displayQuantity = select_value(this);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(select0_change_handler, "select0_change_handler");
  function input4_change_handler_1() {
    pileData.purchaseOnly = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input4_change_handler_1, "input4_change_handler_1");
  function input5_change_handler_1() {
    pileData.hideNewItems = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input5_change_handler_1, "input5_change_handler_1");
  function input6_change_handler() {
    pileData.onlyAcceptBasePrice = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input6_change_handler, "input6_change_handler");
  function sliderinput0_value_binding(value) {
    if ($$self.$$.not_equal(pileData.buyPriceModifier, value)) {
      pileData.buyPriceModifier = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(sliderinput0_value_binding, "sliderinput0_value_binding");
  function sliderinput1_value_binding(value) {
    if ($$self.$$.not_equal(pileData.sellPriceModifier, value)) {
      pileData.sellPriceModifier = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(sliderinput1_value_binding, "sliderinput1_value_binding");
  const click_handler_32 = /* @__PURE__ */ __name(() => {
    showItemTypePriceModifiers();
  }, "click_handler_3");
  const click_handler_4 = /* @__PURE__ */ __name(() => {
    showActorPriceModifiers();
  }, "click_handler_4");
  function select1_change_handler() {
    pileData.openTimes.status = select_value(this);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(select1_change_handler, "select1_change_handler");
  function input7_change_handler() {
    pileData.openTimes.enabled = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input7_change_handler, "input7_change_handler");
  function input8_input_handler() {
    pileData.openTimes.open.hour = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input8_input_handler, "input8_input_handler");
  function input9_input_handler() {
    pileData.openTimes.open.minute = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input9_input_handler, "input9_input_handler");
  function input10_input_handler() {
    pileData.openTimes.close.hour = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input10_input_handler, "input10_input_handler");
  function input11_input_handler() {
    pileData.openTimes.close.minute = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input11_input_handler, "input11_input_handler");
  function input0_change_handler_2() {
    pileData.displayOne = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input0_change_handler_2, "input0_change_handler_2");
  function input1_change_handler_1() {
    pileData.showItemName = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input1_change_handler_1, "input1_change_handler_1");
  function input2_change_handler_2() {
    pileData.overrideSingleItemScale = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input2_change_handler_2, "input2_change_handler_2");
  function input3_change_input_handler() {
    pileData.singleItemScale = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input3_change_input_handler, "input3_change_input_handler");
  function input4_input_handler() {
    pileData.singleItemScale = to_number(this.value);
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input4_input_handler, "input4_input_handler");
  function input5_change_handler_2() {
    pileData.isContainer = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input5_change_handler_2, "input5_change_handler_2");
  function input6_change_handler_1() {
    pileData.closed = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input6_change_handler_1, "input6_change_handler_1");
  function input7_change_handler_1() {
    pileData.locked = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input7_change_handler_1, "input7_change_handler_1");
  function filepicker0_value_binding(value) {
    if ($$self.$$.not_equal(pileData.closedImage, value)) {
      pileData.closedImage = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker0_value_binding, "filepicker0_value_binding");
  function filepicker1_value_binding(value) {
    if ($$self.$$.not_equal(pileData.openedImage, value)) {
      pileData.openedImage = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker1_value_binding, "filepicker1_value_binding");
  function filepicker2_value_binding(value) {
    if ($$self.$$.not_equal(pileData.emptyImage, value)) {
      pileData.emptyImage = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker2_value_binding, "filepicker2_value_binding");
  function filepicker3_value_binding(value) {
    if ($$self.$$.not_equal(pileData.lockedImage, value)) {
      pileData.lockedImage = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker3_value_binding, "filepicker3_value_binding");
  function filepicker4_value_binding(value) {
    if ($$self.$$.not_equal(pileData.closeSound, value)) {
      pileData.closeSound = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker4_value_binding, "filepicker4_value_binding");
  function filepicker5_value_binding(value) {
    if ($$self.$$.not_equal(pileData.openSound, value)) {
      pileData.openSound = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker5_value_binding, "filepicker5_value_binding");
  function filepicker6_value_binding(value) {
    if ($$self.$$.not_equal(pileData.lockedSound, value)) {
      pileData.lockedSound = value;
      $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
    }
  }
  __name(filepicker6_value_binding, "filepicker6_value_binding");
  function input8_change_handler() {
    pileData.shareItemsEnabled = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input8_change_handler, "input8_change_handler");
  function input9_change_handler() {
    pileData.shareCurrenciesEnabled = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input9_change_handler, "input9_change_handler");
  function input10_change_handler() {
    pileData.takeAllEnabled = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input10_change_handler, "input10_change_handler");
  function input11_change_handler() {
    pileData.splitAllEnabled = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input11_change_handler, "input11_change_handler");
  function input12_change_handler() {
    pileData.activePlayers = this.checked;
    $$invalidate(5, pileData), $$invalidate(1, $pileEnabled), $$invalidate(3, $hasOverrideCurrencies), $$invalidate(2, $hasOverrideItemFilters);
  }
  __name(input12_change_handler, "input12_change_handler");
  const click_handler_5 = /* @__PURE__ */ __name(() => {
    resetSharingData();
  }, "click_handler_5");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(4, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("pileActor" in $$props2)
      $$invalidate(21, pileActor = $$props2.pileActor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(5, pileData.enabled = $pileEnabled, pileData);
    }
    if ($$self.$$.dirty[0] & 8) {
      {
        if (!$hasOverrideCurrencies) {
          $$invalidate(5, pileData.overrideCurrencies = false, pileData);
        }
      }
    }
    if ($$self.$$.dirty[0] & 4) {
      {
        if (!$hasOverrideItemFilters) {
          $$invalidate(5, pileData.overrideItemFilters = false, pileData);
        }
      }
    }
    if ($$self.$$.dirty[0] & 2) {
      {
        $$invalidate(6, tabs = [
          {
            value: "mainsettings",
            label: "ITEM-PILES.Applications.ItemPileConfig.Main.Title",
            highlight: !$pileEnabled
          },
          {
            value: "merchant",
            label: "ITEM-PILES.Applications.ItemPileConfig.Merchant.Title"
          },
          {
            value: "othersettings",
            label: "ITEM-PILES.Applications.ItemPileConfig.Other.Title"
          }
        ]);
      }
    }
  };
  return [
    elementRoot,
    $pileEnabled,
    $hasOverrideItemFilters,
    $hasOverrideCurrencies,
    form,
    pileData,
    tabs,
    activeTab,
    deleteWhenEmptySetting,
    pileEnabled,
    hasOverrideCurrencies,
    hasOverrideItemFilters,
    simpleCalendarActive,
    updateSettings,
    showCurrenciesEditor,
    showItemFiltersEditor,
    showItemTypePriceModifiers,
    showActorPriceModifiers,
    resetSharingData,
    showDescriptionDialog,
    requestSubmit,
    pileActor,
    tabs_1_activeTab_binding,
    tabs_1_tabs_binding,
    input0_change_handler,
    input1_input_handler,
    input2_change_handler,
    input3_change_handler,
    macroselector_macro_binding,
    select_change_handler,
    click_handler,
    input4_change_handler,
    click_handler_1,
    input5_change_handler,
    click_handler_22,
    input0_change_handler_1,
    filepicker_value_binding,
    input1_change_handler,
    input2_change_handler_1,
    input3_change_handler_1,
    select0_change_handler,
    input4_change_handler_1,
    input5_change_handler_1,
    input6_change_handler,
    sliderinput0_value_binding,
    sliderinput1_value_binding,
    click_handler_32,
    click_handler_4,
    select1_change_handler,
    input7_change_handler,
    input8_input_handler,
    input9_input_handler,
    input10_input_handler,
    input11_input_handler,
    input0_change_handler_2,
    input1_change_handler_1,
    input2_change_handler_2,
    input3_change_input_handler,
    input4_input_handler,
    input5_change_handler_2,
    input6_change_handler_1,
    input7_change_handler_1,
    filepicker0_value_binding,
    filepicker1_value_binding,
    filepicker2_value_binding,
    filepicker3_value_binding,
    filepicker4_value_binding,
    filepicker5_value_binding,
    filepicker6_value_binding,
    input8_change_handler,
    input9_change_handler,
    input10_change_handler,
    input11_change_handler,
    input12_change_handler,
    click_handler_5,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$5, "instance$5");
class Item_pile_config extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { elementRoot: 0, pileActor: 21 }, null, [-1, -1, -1]);
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get pileActor() {
    return this.$$.ctx[21];
  }
  set pileActor(pileActor) {
    this.$$set({ pileActor });
    flush();
  }
}
__name(Item_pile_config, "Item_pile_config");
class ItemPileConfig extends SvelteApplication {
  constructor(pileActor, options = {}) {
    super({
      id: `item-pile-config-${pileActor.id}`,
      title: game.i18n.format("ITEM-PILES.Applications.ItemPileConfig.Title", { actor_name: pileActor.name }),
      svelte: {
        class: Item_pile_config,
        target: document.body,
        props: {
          pileActor
        }
      },
      close: () => this.options.resolve?.(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 430,
      height: 627,
      classes: ["item-piles-config"],
      resizable: true
    });
  }
  static getActiveApp(id) {
    return Object.values(ui.windows).find((app) => app.id === `item-pile-config-${id}`);
  }
  static async show(target, options = {}, dialogData = {}) {
    const targetActor = getActor(target);
    const app = this.getActiveApp(targetActor.id);
    if (app)
      return app.render(false, { focus: true });
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(targetActor, options, dialogData).render(true);
    });
  }
  async close(options) {
    Object.values(ui.windows).forEach((app) => {
      if (app !== this && app.rendered && app.options?.parentApp === this) {
        app.close();
      }
    });
    return super.close(options);
  }
}
__name(ItemPileConfig, "ItemPileConfig");
class ItemPileInventoryApp extends SvelteApplication {
  constructor(actor, recipient, options = {}, dialogData = {}) {
    super({
      id: `item-pile-inventory-${actor?.token?.id ?? actor.id}`,
      title: actor.name,
      svelte: {
        class: Item_pile_inventory_shell,
        target: document.body,
        props: {
          actor,
          recipient
        }
      },
      zIndex: 100,
      ...options
    }, dialogData);
    this.actor = actor;
    this.recipient = recipient;
    hooks.callAll(HOOKS.OPEN_INTERFACE, this, actor, recipient, options, dialogData);
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      closeOnSubmit: false,
      classes: ["app window-app sheet item-pile-inventory item-piles"],
      width: 550,
      height: "auto"
    });
  }
  static getActiveApps(id) {
    return Object.values(ui.windows).filter((app) => app.id === `item-pile-inventory-${id}`);
  }
  static async show(source, recipient = false, options = {}, dialogData = {}) {
    source = getActor(source);
    recipient = getActor(recipient);
    const result = hooks.call(HOOKS.PRE_OPEN_INTERFACE, source, recipient, options, dialogData);
    if (result === false)
      return;
    const apps = this.getActiveApps(source?.token?.id ?? source.id);
    if (apps.length) {
      for (let app of apps) {
        app.render(false, { focus: true });
      }
      return;
    }
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(source, recipient, options, dialogData).render(true, { focus: true });
    });
  }
  async close(options) {
    const result = hooks.call(HOOKS.PRE_CLOSE_INTERFACE, this, this.actor, this.recipient, options);
    if (result === false)
      return;
    hooks.callAll(HOOKS.CLOSE_INTERFACE, this, this.actor, this.recipient, options);
    return super.close(options);
  }
  _getHeaderButtons() {
    let buttons = super._getHeaderButtons();
    const canConfigure = game.user.isGM;
    if (canConfigure) {
      buttons = [
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.Inspect.OpenSheet" : "",
          class: "item-piles-open-actor-sheet",
          icon: "fas fa-user",
          onclick: () => {
            this.actor.sheet.render(true, { focus: true });
          }
        },
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.ContextMenu.ShowToPlayers" : "",
          class: "item-piles-show-to-players",
          icon: "fas fa-eye",
          onclick: async (event) => {
            const activeUsers = Array.from(game.users).filter((u) => u.active && u !== game.user).map((u) => u.id);
            if (!activeUsers.length) {
              return custom_warning(game.i18n.localize("ITEM-PILES.Warnings.NoPlayersActive"), true);
            }
            const users = event.altKey ? activeUsers : await UserSelectDialog.show({ excludeSelf: true });
            if (!users || !users.length)
              return;
            custom_notify(game.i18n.format("ITEM-PILES.Notifications.ShownToPlayers", { actor_name: this.actor.name }));
            return game.itempiles.API.renderItemPileInterface(this.actor, {
              userIds: users,
              useDefaultCharacter: true
            });
          }
        },
        {
          label: !getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "ITEM-PILES.HUD.Configure" : "",
          class: "item-piles-configure-pile",
          icon: "fas fa-box-open",
          onclick: () => {
            ItemPileConfig.show(this.actor);
          }
        }
      ].concat(buttons);
    }
    return buttons;
  }
}
__name(ItemPileInventoryApp, "ItemPileInventoryApp");
const preloadedFiles = /* @__PURE__ */ new Set();
class PrivateAPI {
  static initialize() {
    hooks.on("canvasReady", this._onCanvasReady.bind(this));
    hooks.on("createItem", this._onCreateItem.bind(this));
    hooks.on("updateItem", this._onUpdateItem.bind(this));
    hooks.on("deleteItem", this._onDeleteItem.bind(this));
    hooks.on("updateActor", this._onUpdateActor.bind(this));
    hooks.on("deleteToken", this._onDeleteToken.bind(this));
    hooks.on("deleteActor", this._onDeleteActor.bind(this));
    hooks.on("preCreateToken", this._onPreCreateToken.bind(this));
    hooks.on("createToken", this._onCreateToken.bind(this));
    hooks.on("dropCanvasData", this._dropData.bind(this));
  }
  static async _onCanvasReady(canvas2) {
    const tokens = [...canvas2.tokens.placeables].map((token) => token.document);
    for (const doc of tokens) {
      await this._preloadItemPileFiles(doc);
    }
  }
  static _onCreateItem(doc) {
    if (!doc.parent)
      return;
    ItemPileStore.notifyChanges("createItem", doc.parent, doc);
    if (!isValidItemPile(doc.parent))
      return;
    this._evaluateItemPileChange(doc.parent, {}, true);
  }
  static _onUpdateItem(doc) {
    if (!doc.parent)
      return;
    if (!isValidItemPile(doc.parent))
      return;
    this._evaluateItemPileChange(doc.parent, {}, true);
  }
  static _onDeleteItem(doc) {
    if (!doc.parent)
      return;
    ItemPileStore.notifyChanges("deleteItem", doc.parent, doc);
    if (!isValidItemPile(doc.parent))
      return;
    this._evaluateItemPileChange(doc.parent, {}, true);
  }
  static _onUpdateActor(doc, changes) {
    if (!isValidItemPile(doc))
      return;
    this._evaluateItemPileChange(doc, changes);
  }
  static _onDeleteToken(doc) {
    ItemPileStore.notifyChanges("delete", doc.actor);
    if (!isValidItemPile(doc))
      return;
    hooks.callAll(HOOKS.PILE.DELETE, doc);
  }
  static _onDeleteActor(doc) {
    ItemPileStore.notifyChanges("delete", doc);
  }
  static _onPreCreateToken(doc, data) {
    let itemPileConfig = foundry.utils.deepClone(getProperty(data, CONSTANTS.FLAGS.PILE));
    itemPileConfig = foundry.utils.mergeObject(
      foundry.utils.deepClone(CONSTANTS.PILE_DEFAULTS),
      itemPileConfig
    );
    if (!itemPileConfig?.enabled)
      return;
    if (!doc.isLinked) {
      doc.updateSource({
        [`actorData.flags.${CONSTANTS.MODULE_NAME}.-=sharing`]: null
      });
    }
    if (itemPileConfig.closedImage.includes("*")) {
      itemPileConfig.closedImage = random_array_element(itemPileConfig.closedImages);
      itemPileConfig.closedImages = [];
    }
    if (itemPileConfig.emptyImage.includes("*")) {
      itemPileConfig.emptyImage = random_array_element(itemPileConfig.emptyImages);
      itemPileConfig.emptyImages = [];
    }
    if (itemPileConfig.openedImage.includes("*")) {
      itemPileConfig.openedImage = random_array_element(itemPileConfig.openedImages);
      itemPileConfig.openedImages = [];
    }
    if (itemPileConfig.lockedImage.includes("*")) {
      itemPileConfig.lockedImage = random_array_element(itemPileConfig.lockedImages);
      itemPileConfig.lockedImages = [];
    }
    doc.updateSource({
      [CONSTANTS.FLAGS.PILE]: itemPileConfig,
      ["actorData." + CONSTANTS.FLAGS.PILE]: itemPileConfig
    });
    const targetItems = getActorItems(doc.actor);
    const targetCurrencies = getActorCurrencies(doc.actor);
    const pileData = { data: itemPileConfig, items: targetItems, currencies: targetCurrencies };
    doc.updateSource({
      "img": getItemPileTokenImage(doc, pileData),
      "scale": getItemPileTokenScale(doc, pileData),
      "name": getItemPileName(doc, pileData)
    });
  }
  static _onCreateToken(doc) {
    if (!isValidItemPile(doc))
      return;
    const itemPileConfig = getActorFlagData(doc.actor);
    hooks.callAll(HOOKS.PILE.CREATE, doc, itemPileConfig);
    return this._preloadItemPileFiles(doc);
  }
  static async _addItems(targetUuid, items, userId, {
    removeExistingActorItems = false,
    interactionId = false
  } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    if (removeExistingActorItems) {
      const existingItems = getActorItems(targetActor);
      await transaction.appendItemChanges(existingItems, { remove: true });
    }
    await transaction.appendItemChanges(items);
    const { itemsToUpdate, itemsToCreate } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.ITEM.PRE_ADD, targetActor, itemsToCreate, itemsToUpdate, interactionId);
    if (hookResult === false)
      return false;
    const { itemDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.ITEM.ADD, targetUuid, itemDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "addItems",
      target: targetUuid,
      items: itemDeltas,
      userId,
      interactionId
    });
    return itemDeltas;
  }
  static async _removeItems(targetUuid, items, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    await transaction.appendItemChanges(items, { remove: true });
    const { itemsToUpdate, itemsToDelete } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.ITEM.PRE_REMOVE, targetActor, itemsToUpdate, itemsToDelete, interactionId);
    if (hookResult === false)
      return false;
    const { itemDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.ITEM.REMOVE, targetUuid, itemDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "removeItems",
      target: targetUuid,
      items: itemDeltas,
      userId,
      interactionId
    });
    const shouldBeDeleted = shouldItemPileBeDeleted(targetUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(targetUuid);
    }
    return itemDeltas;
  }
  static async _transferItems(sourceUuid, targetUuid, items, userId, { interactionId = false } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendItemChanges(items, { remove: true });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendItemChanges(sourceUpdates.itemDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.ITEM.PRE_TRANSFER, sourceActor, sourceUpdates, targetActor, targetUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { itemDeltas } = await targetTransaction.commit();
    await ItemPileSocket.callHook(HOOKS.ITEM.TRANSFER, sourceUuid, targetUuid, itemDeltas, userId, interactionId);
    const macroData = {
      action: "transferItems",
      source: sourceUuid,
      target: targetUuid,
      items: itemDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const itemPile = getToken(sourceUuid);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    } else if (isItemPileEmpty(itemPile)) {
      await clearItemPileSharingData(itemPile);
    } else {
      await setItemPileSharingData(sourceUuid, targetUuid, {
        items: itemDeltas
      });
    }
    return itemDeltas;
  }
  static async _transferAllItems(sourceUuid, targetUuid, userId, {
    itemFilters = false,
    interactionId = false
  } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const itemsToTransfer = getActorItems(sourceActor, { itemFilters }).map((item) => item.toObject());
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendItemChanges(itemsToTransfer, { remove: true });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendItemChanges(sourceUpdates.itemDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.ITEM.PRE_TRANSFER_ALL, sourceActor, sourceUpdates, targetActor, targetUpdates, userId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { itemDeltas } = await targetTransaction.commit();
    await ItemPileSocket.callHook(HOOKS.ITEM.TRANSFER_ALL, sourceUuid, targetUuid, itemDeltas, userId, interactionId);
    const macroData = {
      action: "transferAllItems",
      source: sourceUuid,
      target: targetUuid,
      items: itemDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    }
    return itemDeltas;
  }
  static async _addCurrencies(targetUuid, currencies, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    const currenciesToAdd = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    const itemsToAdd = currenciesToAdd.filter((currency) => currency.type === "item").map((currency) => ({ item: currency.data.item, quantity: currency.quantity }));
    const attributesToAdd = currenciesToAdd.filter((currency) => currency.type === "attribute").map((currency) => ({ path: currency.data.path, quantity: currency.quantity }));
    await transaction.appendItemChanges(itemsToAdd, { type: "currency" });
    await transaction.appendActorChanges(attributesToAdd, { type: "currency" });
    const { actorUpdates, itemsToCreate, itemsToUpdate } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.CURRENCY.PRE_ADD, targetActor, actorUpdates, itemsToCreate, itemsToUpdate, interactionId);
    if (hookResult === false)
      return false;
    const { itemDeltas, attributeDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.CURRENCY.ADD, targetUuid, itemDeltas, attributeDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "addCurrencies",
      target: targetUuid,
      items: itemDeltas,
      attributes: attributeDeltas,
      userId,
      interactionId
    });
    return { itemDeltas, attributeDeltas };
  }
  static async _removeCurrencies(targetUuid, currencies, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    const currenciesToAdd = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    const itemsToRemove = currenciesToAdd.filter((currency) => currency.type === "item").map((currency) => ({ item: currency.data.item, quantity: currency.quantity }));
    const attributesToRemove = currenciesToAdd.filter((currency) => currency.type === "attribute").map((currency) => ({ path: currency.data.path, quantity: currency.quantity }));
    await transaction.appendItemChanges(itemsToRemove, { remove: true, type: "currency" });
    await transaction.appendActorChanges(attributesToRemove, { remove: true, type: "currency" });
    const { actorUpdates, itemsToUpdate } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.CURRENCY.PRE_REMOVE, targetActor, actorUpdates, itemsToUpdate, interactionId);
    if (hookResult === false)
      return false;
    const { itemDeltas, attributeDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.CURRENCY.REMOVE, targetUuid, itemDeltas, attributeDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "removeCurrencies",
      target: targetUuid,
      items: itemDeltas,
      attributes,
      attributeDeltas,
      userId,
      interactionId
    });
    const shouldBeDeleted = shouldItemPileBeDeleted(targetUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(targetUuid);
    }
    return { itemDeltas, attributeDeltas };
  }
  static async _transferCurrencies(sourceUuid, targetUuid, currencies, userId, { interactionId = false } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const currenciesToTransfer = getPriceFromString(currencies).currencies.filter((currency) => currency.quantity);
    const itemsToTransfer = currenciesToTransfer.filter((currency) => currency.type === "item").map((currency) => ({ item: currency.data.item, quantity: currency.quantity }));
    const attributesToTransfer = currenciesToTransfer.filter((currency) => currency.type === "attribute").map((currency) => ({ path: currency.data.path, quantity: currency.quantity }));
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendItemChanges(itemsToTransfer, { remove: true, type: "currency" });
    await sourceTransaction.appendActorChanges(attributesToTransfer, { remove: true, type: "currency" });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendItemChanges(sourceUpdates.itemDeltas, { type: "currency" });
    await targetTransaction.appendActorChanges(sourceUpdates.attributeDeltas, { type: "currency" });
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.CURRENCY.PRE_TRANSFER, sourceActor, sourceUpdates, targetActor, targetUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { itemDeltas, attributeDeltas } = await targetTransaction.commit();
    await ItemPileSocket.callHook(HOOKS.CURRENCY.TRANSFER, sourceUuid, targetUuid, itemDeltas, attributeDeltas, userId, interactionId);
    const macroData = {
      action: "transferCurrencies",
      source: sourceUuid,
      target: targetUuid,
      items: itemDeltas,
      attributes: attributeDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const itemPile = getToken(sourceUuid);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    } else if (isItemPileEmpty(itemPile)) {
      await clearItemPileSharingData(itemPile);
    } else {
      await setItemPileSharingData(sourceUuid, targetUuid, {
        items: itemDeltas,
        attributes: attributeDeltas
      });
    }
    return { itemDeltas, attributeDeltas };
  }
  static async _transferAllCurrencies(sourceUuid, targetUuid, userId, { interactionId = false } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const currencyList = getCurrencyList();
    const sourceCurrencyList = getActorCurrencies(sourceActor, { currencyList });
    const itemsToTransfer = sourceCurrencyList.filter((currency) => currency.type === "item").map((currency) => ({ item: currency.data.item, quantity: currency.quantity }));
    const attributesToTransfer = sourceCurrencyList.filter((currency) => currency.type === "attribute").map((currency) => ({ path: currency.data.path, quantity: currency.quantity }));
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendItemChanges(itemsToTransfer, { remove: true, type: "currency" });
    await sourceTransaction.appendActorChanges(attributesToTransfer, { remove: true, type: "currency" });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendItemChanges(sourceUpdates.itemDeltas);
    await targetTransaction.appendActorChanges(sourceUpdates.attributeDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.CURRENCY.PRE_TRANSFER_ALL, sourceActor, sourceUpdates, targetActor, targetUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { itemDeltas, attributeDeltas } = await targetTransaction.commit();
    await ItemPileSocket.callHook(HOOKS.CURRENCY.TRANSFER_ALL, sourceUuid, targetUuid, itemDeltas, attributeDeltas, userId, interactionId);
    const macroData = {
      action: "transferAllCurrencies",
      source: sourceUuid,
      target: targetUuid,
      items: itemDeltas,
      attributes: attributeDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    }
    return { itemDeltas, attributeDeltas };
  }
  static async _setAttributes(targetUuid, attributes2, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    await transaction.appendActorChanges(attributes2);
    const { actorUpdates } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.ATTRIBUTE.PRE_SET, targetActor, actorUpdates, interactionId);
    if (hookResult === false)
      return false;
    const { attributeDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.ATTRIBUTE.SET, targetUuid, attributeDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "setAttributes",
      target: targetUuid,
      attributes: attributeDeltas,
      userId,
      interactionId
    });
    return attributeDeltas;
  }
  static async _addAttributes(targetUuid, attributes2, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    await transaction.appendActorChanges(attributes2);
    const { actorUpdates } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.ATTRIBUTE.PRE_ADD, targetActor, actorUpdates, interactionId);
    if (hookResult === false)
      return false;
    const { attributeDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.ATTRIBUTE.ADD, targetUuid, attributeDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "addAttributes",
      target: targetUuid,
      attributes: attributeDeltas,
      userId,
      interactionId
    });
    return attributeDeltas;
  }
  static async _removeAttributes(targetUuid, attributes2, userId, { interactionId = false } = {}) {
    const targetActor = getActor(targetUuid);
    const transaction = new Transaction(targetActor);
    await transaction.appendActorChanges(attributes2, { remove: true });
    const { actorUpdates } = transaction.prepare();
    const hookResult = hooks.call(HOOKS.ATTRIBUTE.PRE_REMOVE, targetActor, actorUpdates, interactionId);
    if (hookResult === false)
      return false;
    const { attributeDeltas } = await transaction.commit();
    await ItemPileSocket.callHook(HOOKS.ATTRIBUTE.REMOVE, targetUuid, attributeDeltas, userId, interactionId);
    await this._executeItemPileMacro(targetUuid, {
      action: "removeAttributes",
      target: targetUuid,
      attributes: attributeDeltas,
      userId,
      interactionId
    });
    const shouldBeDeleted = shouldItemPileBeDeleted(targetUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(targetUuid);
    }
    return attributeDeltas;
  }
  static async _transferAttributes(sourceUuid, targetUuid, attributes2, userId, { interactionId = false } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendActorChanges(attributes2, { remove: true });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendActorChanges(sourceUpdates.attributeDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.ATTRIBUTE.PRE_TRANSFER, sourceActor, sourceUpdates.actorUpdates, targetActor, targetUpdates.actorUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { attributeDeltas } = await targetTransaction.commit();
    await ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.CALL_HOOK, HOOKS.ATTRIBUTE.TRANSFER, sourceUuid, targetUuid, attributeDeltas, userId, interactionId);
    const macroData = {
      action: "transferAttributes",
      source: sourceUuid,
      target: targetUuid,
      attributes: attributeDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    const itemPile = await fromUuid(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    } else if (isItemPileEmpty(itemPile)) {
      await clearItemPileSharingData(itemPile);
    } else {
      await setItemPileSharingData(sourceUuid, targetUuid, {
        attributes: attributeDeltas
      });
    }
    return attributeDeltas;
  }
  static async _transferAllAttributes(sourceUuid, targetUuid, userId, { interactionId = false } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const sourceAttributes = getActorCurrencies(sourceActor).filter((entry) => entry.type === "attribute");
    const attributesToTransfer = sourceAttributes.filter((attribute) => {
      return hasProperty(targetActor, attribute.data.path);
    }).map((attribute) => attribute.data.path);
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendActorChanges(attributesToTransfer, { remove: true });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendActorChanges(sourceUpdates.attributeDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.ATTRIBUTE.PRE_TRANSFER_ALL, sourceActor, sourceUpdates.actorUpdates, targetActor, targetUpdates.actorUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { attributeDeltas } = await targetTransaction.commit();
    await ItemPileSocket.callHook(HOOKS.ATTRIBUTE.TRANSFER_ALL, sourceUuid, targetUuid, attributeDeltas, userId, interactionId);
    const macroData = {
      action: "transferAllAttributes",
      source: sourceUuid,
      target: targetUuid,
      attributes: attributeDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    }
    return attributeDeltas;
  }
  static async _transferEverything(sourceUuid, targetUuid, userId, { itemFilters = false, interactionId } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const itemsToTransfer = getActorItems(sourceActor, { itemFilters }).map((item) => item.toObject());
    const sourceCurrencies = getActorCurrencies(sourceActor);
    const itemCurrenciesToTransfer = sourceCurrencies.filter((currency) => currency.type === "item").map((currency) => ({ id: currency.id, quantity: currency.quantity }));
    const attributesToTransfer = sourceCurrencies.filter((entry) => entry.type === "attribute").map((currency) => ({ path: currency.data.path, quantity: currency.quantity }));
    const sourceTransaction = new Transaction(sourceActor);
    await sourceTransaction.appendItemChanges(itemsToTransfer, { remove: true });
    await sourceTransaction.appendItemChanges(itemCurrenciesToTransfer, {
      remove: true,
      type: "currency"
    });
    await sourceTransaction.appendActorChanges(attributesToTransfer, { remove: true, type: "currency" });
    const sourceUpdates = sourceTransaction.prepare();
    const targetTransaction = new Transaction(targetActor);
    await targetTransaction.appendItemChanges(sourceUpdates.itemDeltas);
    await targetTransaction.appendActorChanges(sourceUpdates.attributeDeltas);
    const targetUpdates = targetTransaction.prepare();
    const hookResult = hooks.call(HOOKS.PRE_TRANSFER_EVERYTHING, sourceActor, sourceUpdates, targetActor, targetUpdates, interactionId);
    if (hookResult === false)
      return false;
    await sourceTransaction.commit();
    const { itemDeltas, attributeDeltas } = await targetTransaction.commit();
    await ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.CALL_HOOK, HOOKS.TRANSFER_EVERYTHING, sourceUuid, targetUuid, itemDeltas, attributeDeltas, userId, interactionId);
    const macroData = {
      action: "transferEverything",
      source: sourceUuid,
      target: targetUuid,
      items: itemDeltas,
      attributes: attributeDeltas,
      userId,
      interactionId
    };
    await this._executeItemPileMacro(sourceUuid, macroData);
    await this._executeItemPileMacro(targetUuid, macroData);
    const shouldBeDeleted = shouldItemPileBeDeleted(sourceUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(sourceUuid);
    }
    return {
      itemsTransferred: itemDeltas,
      attributesTransferred: attributeDeltas
    };
  }
  static async _commitActorChanges(actorUuid, actorUpdates, itemsToUpdate, itemsToDelete, itemsToCreate) {
    const actor = getActor(actorUuid);
    await actor.update(actorUpdates);
    await actor.updateEmbeddedDocuments("Item", itemsToUpdate);
    await actor.deleteEmbeddedDocuments("Item", itemsToDelete);
    const createdItems = await actor.createEmbeddedDocuments("Item", itemsToCreate);
    return createdItems.map((item) => item.toObject());
  }
  static async _dropItems({
    userId,
    sceneId,
    sourceUuid = false,
    targetUuid = false,
    itemData = false,
    position = false
  } = {}) {
    let itemsDropped;
    if (sourceUuid) {
      const itemsToTransfer = [{ _id: itemData.item._id, quantity: itemData.quantity }];
      if (targetUuid) {
        itemsDropped = await this._transferItems(sourceUuid, targetUuid, itemsToTransfer, userId);
      } else {
        itemsDropped = (await this._removeItems(sourceUuid, itemsToTransfer, userId)).map((item) => {
          item.quantity = Math.abs(item.quantity);
          setItemQuantity(item.item, Math.abs(item.quantity), true);
          return item;
        });
        targetUuid = await this._createItemPile({ sceneId, position, items: itemsDropped });
      }
    } else {
      if (targetUuid) {
        itemsDropped = await this._addItems(targetUuid, [itemData], userId);
      } else {
        targetUuid = await this._createItemPile({ sceneId, position, items: [itemData] });
      }
    }
    await ItemPileSocket.callHook(HOOKS.ITEM.DROP, sourceUuid, targetUuid, itemsDropped, position);
    return { sourceUuid, targetUuid, position, itemsDropped };
  }
  static async _createItemPile({
    sceneId = null,
    position = false,
    actor = false,
    createActor = false,
    items = false,
    tokenOverrides = {},
    actorOverrides = {},
    itemPileFlags = {}
  } = {}) {
    let returns = {};
    let pileActor;
    if (createActor) {
      let pileDataDefaults = foundry.utils.duplicate(CONSTANTS.PILE_DEFAULTS);
      pileDataDefaults.enabled = true;
      pileDataDefaults.deleteWhenEmpty = true;
      pileDataDefaults.displayOne = true;
      pileDataDefaults.showItemName = true;
      pileDataDefaults.overrideSingleItemScale = true;
      pileDataDefaults.singleItemScale = 0.75;
      pileActor = await Actor.create({
        name: actor || "New Item Pile",
        type: getSetting("actorClassType"),
        img: "icons/svg/item-bag.svg"
      });
      await pileActor.update({
        [CONSTANTS.FLAGS.PILE]: pileDataDefaults,
        prototypeToken: {
          name: "Item Pile",
          actorLink: false,
          bar1: { attribute: "" },
          vision: false,
          displayName: 50,
          [CONSTANTS.FLAGS.PILE]: pileDataDefaults,
          ...tokenOverrides
        },
        ...actorOverrides
      });
    } else if (!actor) {
      pileActor = game.actors.get(getSetting(SETTINGS.DEFAULT_ITEM_PILE_ACTOR_ID));
      if (!pileActor) {
        custom_notify("A Default Item Pile has been added to your Actors list. You can configure the default look and behavior on it, or duplicate it to create different styles.");
        let pileDataDefaults = foundry.utils.duplicate(CONSTANTS.PILE_DEFAULTS);
        pileDataDefaults.enabled = true;
        pileDataDefaults.deleteWhenEmpty = true;
        pileDataDefaults.displayOne = true;
        pileDataDefaults.showItemName = true;
        pileDataDefaults.overrideSingleItemScale = true;
        pileDataDefaults.singleItemScale = 0.75;
        pileActor = await Actor.create({
          name: "Default Item Pile",
          type: getSetting("actorClassType"),
          img: "icons/svg/item-bag.svg"
        });
        await pileActor.update({
          [CONSTANTS.FLAGS.PILE]: pileDataDefaults,
          prototypeToken: {
            name: "Item Pile",
            actorLink: false,
            bar1: { attribute: "" },
            vision: false,
            displayName: 50,
            [CONSTANTS.FLAGS.PILE]: pileDataDefaults
          }
        });
        await game.settings.set(CONSTANTS.MODULE_NAME, "defaultItemPileActorID", pileActor.id);
      }
    } else {
      pileActor = await fromUuid(actor);
      if (!pileActor) {
        throw custom_error("Could not find actor with UUID " + actor);
      }
    }
    if (position && sceneId) {
      let overrideData = { ...position, ...tokenOverrides };
      let pileData = getActorFlagData(pileActor);
      pileData.enabled = true;
      pileData = foundry.utils.mergeObject(pileData, itemPileFlags);
      if (!pileActor.prototypeToken.actorLink) {
        if (items) {
          for (let i = 0; i < items.length; i++) {
            const itemData = items[i]?.item ?? items[i];
            if (SYSTEMS.DATA.ITEM_TRANSFORMER) {
              items[i] = await SYSTEMS.DATA.ITEM_TRANSFORMER(itemData);
            }
          }
        } else {
          items = [];
        }
        items = items ? items.map((item) => {
          return item.item ?? item;
        }) : [];
        overrideData["actorData"] = {
          items,
          ...actorOverrides
        };
        const data = { data: pileData, items };
        overrideData = foundry.utils.mergeObject(overrideData, {
          "img": getItemPileTokenImage(pileActor, data, overrideData?.img),
          "scale": getItemPileTokenScale(pileActor, data, overrideData?.scale),
          "name": getItemPileName(pileActor, data, overrideData?.name)
        });
      }
      const tokenData = await pileActor.getTokenDocument(overrideData);
      const scene = game.scenes.get(sceneId);
      const hookResult = hooks.call(HOOKS.PILE.PRE_CREATE, tokenData);
      if (hookResult === false)
        return false;
      const [tokenDocument] = await scene.createEmbeddedDocuments("Token", [tokenData]);
      returns["tokenUuid"] = getUuid(tokenDocument);
    }
    returns["actorUuid"] = pileActor.uuid;
    return returns;
  }
  static async _turnTokensIntoItemPiles(targetUuids, pileSettings = {}, tokenSettings = {}) {
    const tokenUpdateGroups = {};
    const actorUpdateGroups = {};
    for (const targetUuid of targetUuids) {
      const target = fromUuidSync(targetUuid);
      let specificPileSettings = foundry.utils.mergeObject(
        getActorFlagData(target),
        pileSettings
      );
      specificPileSettings.enabled = true;
      const targetItems = getActorItems(target, { itemFilters: specificPileSettings.overrideItemFilters });
      const targetCurrencies = getActorCurrencies(target, { currencyList: specificPileSettings.overrideCurrencies });
      const data = { data: specificPileSettings, items: targetItems, currencies: targetCurrencies };
      let specificTokenSettings = isFunction(tokenSettings) ? await tokenSettings(target) : foundry.utils.deepClone(tokenSettings);
      specificTokenSettings = foundry.utils.mergeObject(specificTokenSettings, {
        "img": getItemPileTokenImage(target, data, specificTokenSettings?.img),
        "scale": getItemPileTokenScale(target, data, specificTokenSettings?.scale),
        "name": getItemPileName(target, data, specificTokenSettings?.name)
      });
      const sceneId = targetUuid.split(".")[1];
      const tokenId = targetUuid.split(".")[3];
      if (!tokenUpdateGroups[sceneId]) {
        tokenUpdateGroups[sceneId] = [];
      }
      tokenUpdateGroups[sceneId].push({
        "_id": tokenId,
        ...specificTokenSettings,
        [CONSTANTS.FLAGS.PILE]: specificPileSettings,
        [`actorData.${CONSTANTS.FLAGS.PILE}`]: specificPileSettings
      });
      if (target.isLinked) {
        if (actorUpdateGroups[target.actor.id])
          continue;
        actorUpdateGroups[target.actor.id] = {
          "_id": target.actor.id,
          [CONSTANTS.FLAGS.PILE]: specificPileSettings
        };
      }
    }
    const hookResult = hooks.call(HOOKS.PILE.PRE_TURN_INTO, tokenUpdateGroups, actorUpdateGroups);
    if (hookResult === false)
      return false;
    await Actor.updateDocuments(Object.values(actorUpdateGroups));
    for (const [sceneId, updateData] of Object.entries(tokenUpdateGroups)) {
      const scene = game.scenes.get(sceneId);
      await scene.updateEmbeddedDocuments("Token", updateData);
    }
    await ItemPileSocket.callHook(HOOKS.PILE.TURN_INTO, tokenUpdateGroups, actorUpdateGroups);
    return targetUuids;
  }
  static async _revertTokensFromItemPiles(targetUuids, tokenSettings) {
    const actorUpdateGroups = {};
    const tokenUpdateGroups = {};
    for (const targetUuid of targetUuids) {
      let target = fromUuidSync(targetUuid);
      let specificPileSettings = getActorFlagData(target);
      specificPileSettings.enabled = false;
      const sceneId = targetUuid.split(".")[1];
      const tokenId = targetUuid.split(".")[3];
      if (!tokenUpdateGroups[sceneId]) {
        tokenUpdateGroups[sceneId] = [];
      }
      const specificTokenSettings = isFunction(tokenSettings) ? await tokenSettings(target) : foundry.utils.deepClone(tokenSettings);
      tokenUpdateGroups[sceneId].push({
        "_id": tokenId,
        ...specificTokenSettings,
        [CONSTANTS.FLAGS.PILE]: specificPileSettings,
        [`actorData.${CONSTANTS.FLAGS.PILE}`]: specificPileSettings
      });
      if (target.isLinked) {
        if (actorUpdateGroups[target.actor.id])
          continue;
        actorUpdateGroups[target.actor.id] = {
          "_id": target.actor.id,
          [CONSTANTS.FLAGS.PILE]: specificPileSettings
        };
      }
    }
    const hookResult = hooks.call(HOOKS.PILE.PRE_REVERT_FROM, tokenUpdateGroups, actorUpdateGroups);
    if (hookResult === false)
      return false;
    await Actor.updateDocuments(Object.values(actorUpdateGroups));
    for (const [sceneId, updateData] of Object.entries(tokenUpdateGroups)) {
      const scene = game.scenes.get(sceneId);
      await scene.updateEmbeddedDocuments("Token", updateData);
    }
    await ItemPileSocket.callHook(HOOKS.PILE.REVERT_FROM, tokenUpdateGroups, actorUpdateGroups);
    return targetUuids;
  }
  static async _updateItemPile(targetUuid, newData, { interactingTokenUuid = false, tokenSettings = false } = {}) {
    const targetActor = getActor(targetUuid);
    const interactingToken = interactingTokenUuid ? getToken(interactingTokenUuid) : false;
    const oldData = getActorFlagData(targetActor);
    const data = foundry.utils.mergeObject(foundry.utils.duplicate(oldData), foundry.utils.duplicate(newData));
    const diff = foundry.utils.diffObject(oldData, data);
    const hookResult = hooks.call(HOOKS.PILE.PRE_UPDATE, targetActor, data, interactingToken, tokenSettings);
    if (hookResult === false)
      return false;
    await wait$1(15);
    await updateItemPileData(targetActor, data, tokenSettings);
    if (data.enabled && data.isContainer) {
      if (diff?.closed === true) {
        await this._executeItemPileMacro(targetUuid, {
          action: "closeItemPile",
          source: interactingTokenUuid,
          target: targetUuid
        });
      }
      if (diff?.locked === true) {
        await this._executeItemPileMacro(targetUuid, {
          action: "lockItemPile",
          source: interactingTokenUuid,
          target: targetUuid
        });
      }
      if (diff?.locked === false) {
        await this._executeItemPileMacro(targetUuid, {
          action: "unlockItemPile",
          source: interactingTokenUuid,
          target: targetUuid
        });
      }
      if (diff?.closed === false) {
        await this._executeItemPileMacro(targetUuid, {
          action: "openItemPile",
          source: interactingTokenUuid,
          target: targetUuid
        });
      }
    }
    return ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.UPDATED_PILE, targetUuid, diff, interactingTokenUuid);
  }
  static _updatedItemPile(targetUuid, diffData, interactingTokenUuid) {
    const target = getToken(targetUuid);
    const interactingToken = interactingTokenUuid ? fromUuidSync(interactingTokenUuid) : false;
    if (foundry.utils.isEmpty(diffData))
      return false;
    const data = getActorFlagData(target);
    hooks.callAll(HOOKS.PILE.UPDATE, target, diffData, interactingToken);
    if (data.enabled && data.isContainer) {
      if (diffData?.closed === true) {
        hooks.callAll(HOOKS.PILE.CLOSE, target, interactingToken);
      }
      if (diffData?.locked === true) {
        hooks.callAll(HOOKS.PILE.LOCK, target, interactingToken);
      }
      if (diffData?.locked === false) {
        hooks.callAll(HOOKS.PILE.UNLOCK, target, interactingToken);
      }
      if (diffData?.closed === false) {
        hooks.callAll(HOOKS.PILE.OPEN, target, interactingToken);
      }
    }
  }
  static async _deleteItemPile(targetUuid) {
    const target = getToken(targetUuid);
    if (!target)
      return false;
    const hookResult = hooks.call(HOOKS.PILE.PRE_DELETE, target);
    if (hookResult === false)
      return false;
    return target.document.delete();
  }
  static _evaluateItemPileChange(doc, changes = {}, force = false) {
    const duplicatedChanges = foundry.utils.deepClone(changes);
    const target = doc?.token ?? doc;
    if (!isResponsibleGM())
      return;
    if (!force && !shouldEvaluateChange(target, duplicatedChanges))
      return;
    const targetUuid = target.uuid;
    return debounceManager.setDebounce(targetUuid, async (uuid) => {
      if (!getDocument(uuid))
        return;
      const deleted = shouldItemPileBeDeleted(uuid);
      if (deleted)
        return;
      await hooks.runWithout(async () => {
        await updateItemPileData(uuid);
      });
    })(targetUuid);
  }
  static async _preloadItemPileFiles(tokenDocument) {
    if (!isValidItemPile(tokenDocument))
      return false;
    const pileData = getActorFlagData(tokenDocument);
    if (getSetting("preloadFiles")) {
      await Promise.allSettled(Object.entries(pileData).map((entry) => {
        return new Promise(async (resolve) => {
          const [property, filePath] = entry;
          if (Array.isArray(filePath)) {
            return resolve();
          }
          const isImage = property.toLowerCase().includes("image");
          const isSound = property.toLowerCase().includes("sound");
          if (!isImage && !isSound || (!filePath || preloadedFiles.has(filePath)))
            return resolve();
          preloadedFiles.add(filePath);
          if (isImage) {
            await loadTexture(filePath);
            debug(`Preloaded image: ${filePath}`);
          } else if (isSound) {
            debug(`Preloaded sound: ${filePath}`);
            await AudioHelper.preloadSound(filePath);
          }
          resolve();
        });
      }));
    }
    debug(`Initialized item pile with uuid ${tokenDocument.uuid}`);
  }
  static async _executeItemPileMacro(targetUuid, macroData) {
    const target = getToken(targetUuid);
    if (!isValidItemPile(target))
      return false;
    const pileData = getActorFlagData(target);
    if (!pileData.macro)
      return false;
    if (macroData.source) {
      macroData.source = fromUuidSync(macroData.source);
    }
    if (Array.isArray(macroData.target)) {
      macroData.target = macroData.target.map((target2) => fromUuidSync(target2));
    } else {
      if (macroData.target) {
        macroData.target = fromUuidSync(macroData.target);
      }
      const targetActor = macroData.target instanceof TokenDocument ? macroData.target.actor : macroData.target;
      if (macroData.items) {
        macroData.items = macroData.items.map((item) => targetActor.items.get(item._id));
      }
    }
    return runMacro(pileData.macro, macroData);
  }
  static async _dropData(canvas2, data, { target = false } = {}) {
    if (data.type !== "Item")
      return false;
    let item = await Item.implementation.fromDropData(data);
    let itemData = item.toObject();
    if (!itemData) {
      console.error(data);
      throw custom_error("Something went wrong when dropping this item!");
    }
    const dropData = {
      source: false,
      target,
      itemData: {
        item: itemData,
        quantity: 1
      },
      position: false
    };
    dropData.source = item.parent;
    if (!dropData.source && !game.user.isGM) {
      return custom_warning(game.i18n.localize("ITEM-PILES.Errors.NoSourceDrop"), true);
    }
    const pre_drop_determined_hook = hooks.call(HOOKS.ITEM.PRE_DROP_DETERMINED, dropData.source, dropData.target, dropData.itemData, dropData.position);
    if (pre_drop_determined_hook === false)
      return false;
    let droppableDocuments = [];
    let x;
    let y;
    if (dropData.target) {
      droppableDocuments.push(dropData.target);
    } else {
      const position = canvas2.grid.getTopLeft(data.x, data.y);
      x = position[0];
      y = position[1];
      droppableDocuments = getTokensAtLocation({ x, y }).map((token) => getDocument(token));
      if (droppableDocuments.length && game.modules.get("midi-qol")?.active && game.settings.get("midi-qol", "DragDropTarget")) {
        custom_warning("You have Drag & Drop Targetting enabled in MidiQOL, which disables drag & drop items");
        return false;
      }
      if (!droppableDocuments.length) {
        dropData.position = { x, y };
      }
    }
    const canGiveItems = getSetting(SETTINGS.ENABLE_GIVING_ITEMS) || game.user.isGM;
    const canDropItems = getSetting(SETTINGS.ENABLE_DROPPING_ITEMS) || game.user.isGM;
    const droppableItemPiles = droppableDocuments.filter((token) => isValidItemPile(token));
    const droppableNormalTokens = droppableDocuments.filter((token) => !isValidItemPile(token));
    const droppingItem = canDropItems && (droppableItemPiles.length || dropData.position && !droppableNormalTokens.length);
    const givingItem = canGiveItems && droppableNormalTokens.length && !droppableItemPiles.length;
    if (droppingItem) {
      dropData.target = droppableItemPiles[0];
      return this._dropItem(dropData);
    } else if (givingItem) {
      dropData.target = droppableNormalTokens[0];
      return this._giveItem(dropData);
    }
    return false;
  }
  static async _giveItem(dropData) {
    if (dropData.source === dropData.target)
      return;
    const validItem = await checkItemType(dropData.target, dropData.itemData.item);
    if (!validItem)
      return;
    dropData.itemData.item = validItem;
    const user = Array.from(game.users).find((user2) => user2?.character === dropData.target.actor);
    if (user && !user?.active && !game.user.isGM) {
      return TJSDialog.prompt({
        title: game.i18n.localize("ITEM-PILES.Dialogs.GiveItemUserNotActive.Title"),
        content: {
          class: CustomDialog,
          props: {
            content: game.i18n.format("ITEM-PILES.Dialogs.GiveItemUserNotActive.Content", {
              actor_name: dropData.target.actor.name,
              user_name: user.name
            })
          }
        }
      });
    }
    const gms = getActiveGMs().map((user2) => user2.id);
    if (user?.active || gms.length || game.user.isGM) {
      const item = await Item.implementation.create(dropData.itemData.item, { temporary: true });
      if (canItemStack(dropData.itemData.item)) {
        const quantity = await DropItemDialog.show(item, dropData.target.actor, { giving: true });
        setItemQuantity(dropData.itemData.item, quantity);
        dropData.itemData.quantity = quantity;
      } else {
        dropData.itemData.quantity = 1;
      }
      const sourceUuid = getUuid(dropData.source);
      const targetUuid = getUuid(dropData.target);
      if ((!user || !user?.active) && game.user.isGM) {
        custom_notify(game.i18n.format("ITEM-PILES.Notifications.ItemTransferred", {
          source_actor_name: dropData.source.name,
          target_actor_name: dropData.target.name,
          item_name: item.name
        }));
        return this._transferItems(sourceUuid, targetUuid, [dropData.itemData.item], game.user.id);
      }
      return ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.GIVE_ITEMS, [user ? user.id : gms[0]], {
        userId: game.user.id,
        sourceUuid,
        targetUuid,
        itemData: dropData.itemData
      });
    }
  }
  static async _dropItem(dropData) {
    if (dropData.source === dropData.target)
      return;
    if (dropData.target && isItemPileMerchant(dropData.target))
      return;
    const validItem = await checkItemType(dropData.target, dropData.itemData.item);
    if (!validItem)
      return;
    dropData.itemData.item = validItem;
    if (dropData.target && !dropData.position && !game.user.isGM) {
      if (!(dropData.target instanceof Actor && dropData.source instanceof Actor)) {
        const sourceToken = canvas.tokens.placeables.find((token) => token.actor === dropData.source);
        if (sourceToken) {
          const distance = Math.floor(distance_between_rect(sourceToken, dropData.target.object) / canvas.grid.size) + 1;
          const pileData = getActorFlagData(dropData.target);
          const maxDistance = pileData?.distance ? pileData?.distance : Infinity;
          if (distance > maxDistance) {
            custom_warning(game.i18n.localize("ITEM-PILES.Errors.PileTooFar"), true);
            return false;
          }
        }
      }
      if (game.itempiles.API.isItemPileLocked(dropData.target)) {
        custom_warning(game.i18n.localize("ITEM-PILES.Errors.PileLocked"), true);
        return false;
      }
    }
    if (canItemStack(dropData.itemData.item)) {
      if (hotkeyState.altDown) {
        setItemQuantity(dropData.itemData.item, 1);
        dropData.itemData.quantity = 1;
      } else {
        let quantity = getItemQuantity(dropData.itemData.item);
        if (quantity > 1) {
          const item = await Item.implementation.create(dropData.itemData.item, { temporary: true });
          quantity = await DropItemDialog.show(item, dropData.target);
          if (!quantity)
            return;
        }
        setItemQuantity(dropData.itemData.item, Number(quantity));
        dropData.itemData.quantity = Number(quantity);
      }
    }
    const hookResult = hooks.call(HOOKS.ITEM.PRE_DROP, dropData.source, dropData.target, dropData.position, dropData.itemData);
    if (hookResult === false)
      return false;
    return ItemPileSocket.executeAsGM(ItemPileSocket.HANDLERS.DROP_ITEMS, {
      userId: game.user.id,
      sceneId: canvas?.scene?.id ?? "",
      sourceUuid: getUuid(dropData.source),
      targetUuid: getUuid(dropData.target),
      position: dropData.position,
      itemData: dropData.itemData
    });
  }
  static async _giveItems({ userId, sourceUuid, targetUuid, itemData } = {}) {
    const sourceActor = getActor(sourceUuid);
    const targetActor = getActor(targetUuid);
    const contentString = "ITEM-PILES.Dialogs.ReceiveItem." + (itemData.quantity > 1 ? "ContentMany" : "ContentOne");
    const item = await Item.implementation.create(itemData.item, { temporary: true });
    const accepted = await TJSDialog.confirm({
      title: game.i18n.localize("ITEM-PILES.Dialogs.ReceiveItem.Title"),
      content: {
        class: CustomDialog,
        props: {
          content: game.i18n.format(contentString, {
            source_actor_name: sourceActor.name,
            target_actor_name: targetActor.name,
            quantity: itemData.quantity,
            item_name: item.name
          }),
          icon: "fas fa-handshake",
          header: game.i18n.localize("ITEM-PILES.Dialogs.ReceiveItem.Header")
        }
      }
    });
    if (accepted) {
      await PrivateAPI._addItems(targetUuid, [itemData], game.user.id);
    }
    return ItemPileSocket.executeForUsers(ItemPileSocket.HANDLERS.GIVE_ITEMS_RESPONSE, [userId], {
      userId: game.user.id,
      accepted,
      sourceUuid,
      itemData
    });
  }
  static async _giveItemsResponse({ userId, accepted, sourceUuid, itemData } = {}) {
    const user = game.users.get(userId);
    if (accepted) {
      await PrivateAPI._removeItems(sourceUuid, [itemData], game.user.id);
      return custom_notify(game.i18n.format("ITEM-PILES.Notifications.GiveItemAccepted", { user_name: user.name }));
    }
    return custom_warning(game.i18n.format("ITEM-PILES.Warnings.GiveItemDeclined", { user_name: user.name }), true);
  }
  static async _itemPileClicked(pileDocument) {
    if (!isValidItemPile(pileDocument))
      return false;
    const pileToken = pileDocument.object;
    if (!isGMConnected()) {
      custom_warning(`Item Piles requires a GM to be connected for players to be able to loot item piles.`, true);
      return false;
    }
    debug(`Clicked: ${pileDocument.uuid}`);
    const pileData = getActorFlagData(pileDocument);
    const maxDistance = pileData.distance ? pileData.distance : Infinity;
    let validTokens = [];
    let playerToken = false;
    if (game.user.character) {
      playerToken = canvas.tokens.placeables.find((token) => token.actor === game.user.character && tokens_close_enough(pileToken, token, maxDistance));
    }
    if (canvas.tokens.controlled.length > 0) {
      validTokens = [...canvas.tokens.controlled];
      validTokens = validTokens.filter((token) => token.document !== pileDocument);
    } else if (game.user.character) {
      if (playerToken) {
        validTokens.push(playerToken);
      }
    }
    if (!validTokens.length && !game.user.isGM) {
      validTokens.push(...canvas.tokens.placeables);
      if (_token) {
        validTokens.unshift(_token);
      }
    }
    validTokens = validTokens.filter((token) => token.owner && token.document !== pileDocument).filter((token) => {
      return tokens_close_enough(pileToken, token, maxDistance) || game.user.isGM;
    });
    let interactingActor;
    if (!validTokens.length && !game.user.isGM) {
      if (maxDistance === Infinity) {
        interactingActor = getUserCharacter();
      }
      if (!interactingActor) {
        custom_warning(game.i18n.localize(
          maxDistance === Infinity ? "ITEM-PILES.Errors.PileTooFar" : "ITEM-PILES.Errors.NoTokenFound"
        ), true);
        return false;
      }
    }
    if (!interactingActor && validTokens.length) {
      if (validTokens.includes(_token)) {
        interactingActor = _token.actor;
      } else if (validTokens.includes(playerToken)) {
        interactingActor = playerToken.actor;
      } else {
        validTokens.sort((potentialTargetA, potentialTargetB) => {
          return grids_between_tokens(pileToken, potentialTargetA) - grids_between_tokens(pileToken, potentialTargetB);
        });
        interactingActor = validTokens[0].actor;
      }
    }
    if (pileData.isContainer && interactingActor) {
      if (pileData.locked && !game.user.isGM) {
        debug(`Attempted to open locked item pile with UUID ${pileDocument.uuid}`);
        return game.itempiles.API.rattleItemPile(pileDocument, interactingActor);
      }
      if (pileData.closed) {
        debug(`Opened item pile with UUID ${pileDocument.uuid}`);
        await game.itempiles.API.openItemPile(pileDocument, interactingActor);
      }
    }
    return this._renderItemPileInterface(pileDocument.uuid, { inspectingTargetUuid: interactingActor?.uuid });
  }
  static async _splitItemPileContents(itemPileUuid, actorUuids, userId, instigator) {
    const itemPileActor = getActor(itemPileUuid);
    const items = getActorItems(itemPileActor);
    const currencies = getActorCurrencies(itemPileActor);
    const pileData = getActorFlagData(itemPileActor);
    const shareData = getItemPileSharingData(itemPileActor);
    const tempPileTransaction = new Transaction(itemPileActor);
    const numPlayers = actorUuids.length;
    if (pileData.shareItemsEnabled) {
      const itemsToRemove = items.map((item) => {
        const itemData = item.toObject();
        const quantity = Math.floor(getItemQuantity(itemData) / numPlayers) * numPlayers;
        return {
          item: itemData,
          quantity
        };
      }).filter((entry) => entry.quantity);
      await tempPileTransaction.appendItemChanges(itemsToRemove, { remove: true });
    }
    const currencyItems = currencies.filter((entry) => entry.type === "item").map((entry) => {
      const itemData = entry.item.toObject();
      const quantity = Math.floor(getItemQuantity(itemData) / numPlayers) * numPlayers;
      return {
        item: itemData,
        quantity
      };
    }).filter((entry) => entry.quantity);
    await tempPileTransaction.appendItemChanges(currencyItems, { remove: true, type: "currency" });
    const attributes2 = currencies.filter((entry) => entry.type === "attribute").map((attribute) => {
      return {
        ...attribute,
        quantity: Math.floor(attribute.quantity / numPlayers) * numPlayers
      };
    });
    await tempPileTransaction.appendActorChanges(attributes2, { remove: true, type: "currency" });
    const preparedData = tempPileTransaction.prepare();
    const transactionMap = actorUuids.map((uuid) => {
      return [uuid, new Transaction(getActor(uuid))];
    });
    for (const [uuid, transaction] of transactionMap) {
      if (pileData.shareItemsEnabled) {
        await transaction.appendItemChanges(deepClone(preparedData).itemDeltas.filter((delta) => delta.type === "item").map((delta) => {
          delta.quantity = getItemSharesLeftForActor(itemPileActor, delta.item, transaction.actor, {
            players: numPlayers,
            shareData,
            floor: true
          });
          return delta;
        }));
      }
      if (pileData.shareCurrenciesEnabled) {
        await transaction.appendItemChanges(deepClone(preparedData).itemDeltas.filter((delta) => delta.type === "currency").map((delta) => {
          delta.quantity = getItemSharesLeftForActor(itemPileActor, delta.item, transaction.actor, {
            players: numPlayers,
            shareData,
            floor: true
          });
          return delta;
        }), { type: "currency" });
        await transaction.appendActorChanges(Object.entries(deepClone(preparedData).attributeDeltas).map((entry) => {
          let [path] = entry;
          const quantity = getAttributeSharesLeftForActor(itemPileActor, path, transaction.actor, {
            players: numPlayers,
            shareData,
            floor: true
          });
          return { path, quantity };
        }));
      }
    }
    const actorPreparedData = Object.fromEntries(transactionMap.map((entry) => [entry[0], entry[1].prepare()]));
    const hookResult = hooks.call(HOOKS.PILE.PRE_SPLIT_INVENTORY, itemPileActor, preparedData, actorPreparedData, userId, instigator);
    if (hookResult === false)
      return false;
    const pileDeltas = await tempPileTransaction.commit();
    const actorDeltas = {};
    for (const [uuid, transaction] of transactionMap) {
      actorDeltas[uuid] = await transaction.commit();
    }
    await clearItemPileSharingData(itemPileActor);
    await ItemPileSocket.callHook(HOOKS.PILE.SPLIT_INVENTORY, itemPileUuid, pileDeltas, actorDeltas, userId, instigator);
    await this._executeItemPileMacro(itemPileUuid, {
      action: "splitInventory",
      source: itemPileUuid,
      target: actorUuids,
      transfers: {
        pileDeltas,
        actorDeltas
      },
      userId,
      instigator
    });
    const shouldBeDeleted = shouldItemPileBeDeleted(itemPileUuid);
    if (shouldBeDeleted) {
      await this._deleteItemPile(itemPileUuid);
    }
    return {
      pileDeltas,
      actorDeltas
    };
  }
  static async _updateTokenHud() {
    if (!canvas.tokens.hud.rendered)
      return;
    return canvas.tokens.hud.render(true);
  }
  static async _renderItemPileInterface(targetUuid, {
    inspectingTargetUuid = false,
    useDefaultCharacter = false,
    remote = false
  } = {}) {
    const target = getActor(targetUuid);
    let inspectingTarget;
    if (useDefaultCharacter) {
      inspectingTarget = getUserCharacter();
    } else {
      inspectingTarget = inspectingTargetUuid ? fromUuidSync(inspectingTargetUuid) : false;
    }
    const merchant = isItemPileMerchant(target);
    if (merchant) {
      return MerchantApp.show(target, inspectingTarget);
    }
    return ItemPileInventoryApp.show(target, inspectingTarget, { remote });
  }
  static async _tradeItems(sellerUuid, buyerUuid, items, userId, {
    interactionId = false
  } = {}) {
    const sellingActor = getActor(sellerUuid);
    const buyingActor = getActor(buyerUuid);
    const itemPrices = getPricesForItems(items.map((data) => {
      const item = sellingActor.items.get(data.id);
      return {
        ...data,
        item
      };
    }), { seller: sellingActor, buyer: buyingActor });
    const preCalcHookResult = hooks.call(HOOKS.ITEM.PRE_CALC_TRADE, sellingActor, buyingActor, itemPrices, userId, interactionId);
    if (preCalcHookResult === false)
      return false;
    const sellerTransaction = new Transaction(sellingActor);
    const sellerFlagData = getActorFlagData(sellerTransaction);
    const sellerIsMerchant = sellerFlagData.enabled && sellerFlagData.isMerchant;
    const sellerInfiniteQuantity = sellerIsMerchant && sellerFlagData.infiniteQuantity;
    const sellerInfiniteCurrencies = sellerIsMerchant && sellerFlagData.infiniteCurrencies;
    const sellerKeepZeroQuantity = sellerIsMerchant && sellerFlagData.keepZeroQuantity;
    for (const payment of itemPrices.sellerReceive) {
      if (!payment.quantity)
        continue;
      if (payment.type === "attribute") {
        await sellerTransaction.appendActorChanges([{
          path: payment.data.path,
          quantity: payment.quantity
        }], { type: payment.isCurrency ? "currency" : payment.type });
      } else {
        await sellerTransaction.appendItemChanges([{
          item: payment.data.item,
          quantity: payment.quantity
        }], { type: payment.isCurrency ? "currency" : payment.type });
      }
    }
    for (const entry of itemPrices.buyerReceive) {
      if (!entry.quantity || sellerInfiniteCurrencies && entry.isCurrency || sellerInfiniteQuantity && !entry.isCurrency) {
        continue;
      }
      if (entry.type === "attribute") {
        await sellerTransaction.appendActorChanges([{
          path: entry.data.path,
          quantity: entry.quantity
        }], {
          remove: true,
          type: entry.isCurrency ? "currency" : entry.type
        });
      } else {
        const itemFlagData = getItemFlagData(entry.item);
        if (sellerIsMerchant && itemFlagData.infiniteQuantity)
          continue;
        await sellerTransaction.appendItemChanges([{
          item: entry.item,
          quantity: entry.quantity
        }], {
          remove: true,
          type: entry.isCurrency ? "currency" : entry.type,
          keepIfZero: itemFlagData.isService || sellerKeepZeroQuantity || itemFlagData.keepZeroQuantity
        });
      }
    }
    const buyerTransaction = new Transaction(buyingActor);
    const buyerFlagData = getActorFlagData(buyingActor);
    const buyerIsMerchant = buyerFlagData.enabled && buyerFlagData.isMerchant;
    const buyerInfiniteCurrencies = buyerIsMerchant && buyerFlagData.infiniteCurrencies;
    const buyerInfiniteQuantity = buyerIsMerchant && buyerFlagData.infiniteQuantity;
    const buyerHidesNewItems = buyerIsMerchant && buyerFlagData.hideNewItems;
    for (const price of itemPrices.finalPrices) {
      if (!price.quantity || buyerInfiniteCurrencies && price.isCurrency || buyerInfiniteQuantity && !price.isCurrency) {
        continue;
      }
      if (price.type === "attribute") {
        await buyerTransaction.appendActorChanges([{
          path: price.data.path,
          quantity: price.quantity
        }], { remove: true, type: price.isCurrency ? "currency" : price.type });
      } else {
        await buyerTransaction.appendItemChanges([{
          item: price.data.item,
          quantity: price.quantity
        }], { remove: true, type: price.isCurrency ? "currency" : price.type });
      }
    }
    for (const entry of itemPrices.buyerReceive) {
      if (!entry.quantity)
        continue;
      if (entry.type === "attribute") {
        await buyerTransaction.appendActorChanges([{
          path: entry.data.path,
          quantity: entry.quantity
        }], { type: entry.type });
      } else {
        const itemFlagData = getItemFlagData(entry.item);
        if (itemFlagData.isService)
          continue;
        const item = entry.item.toObject();
        if (buyerHidesNewItems) {
          setProperty(item, CONSTANTS.FLAGS.ITEM + ".hidden", true);
        }
        await buyerTransaction.appendItemChanges([{
          item,
          quantity: entry.quantity
        }], { type: entry.type });
      }
    }
    for (const change of itemPrices.buyerChange) {
      if (!change.quantity)
        continue;
      if (change.type === "attribute") {
        await buyerTransaction.appendActorChanges([{
          path: change.data.path,
          quantity: change.quantity
        }], { type: "currency" });
      } else {
        await buyerTransaction.appendItemChanges([{
          item: change.item,
          quantity: change.quantity
        }], { type: "currency" });
      }
    }
    const sellerUpdates = sellerTransaction.prepare();
    const buyerUpdates = buyerTransaction.prepare();
    const hookResult = hooks.call(HOOKS.ITEM.PRE_TRADE, sellingActor, sellerUpdates, buyingActor, buyerUpdates, userId, interactionId);
    if (hookResult === false)
      return false;
    const sellerTransactionData = await sellerTransaction.commit();
    const buyerTransactionData = await buyerTransaction.commit();
    await this._executeItemPileMacro(sellerUuid, {
      action: "tradeItems",
      source: sellerUuid,
      target: buyerUuid,
      items: sellerTransactionData.itemDeltas,
      attributes: sellerTransactionData.attributeDeltas,
      userId,
      interactionId
    });
    await this._executeItemPileMacro(buyerUuid, {
      action: "tradeItems",
      source: sellerUuid,
      target: buyerUuid,
      items: buyerTransactionData.itemDeltas,
      attributes: buyerTransactionData.attributeDeltas,
      userId,
      interactionId
    });
    if (sellerIsMerchant) {
      for (let entry of itemPrices.buyerReceive) {
        const itemFlagData = getItemFlagData(entry.item);
        if (!itemFlagData.macro)
          continue;
        await runMacro(itemFlagData.macro, {
          seller: sellingActor,
          buyer: buyingActor,
          item: entry.item,
          quantity: entry.quantity
        });
      }
    }
    await ItemPileSocket.executeForEveryone(ItemPileSocket.HANDLERS.CALL_HOOK, HOOKS.ITEM.TRADE, sellerUuid, buyerUuid, itemPrices, userId, interactionId);
    return {
      itemDeltas: buyerTransactionData.itemDeltas,
      attributeDeltas: buyerTransactionData.attributeDeltas,
      itemPrices
    };
  }
  static async _rollItemTable({
    table = "",
    timesToRoll = "1",
    resetTable = true,
    displayChat = false,
    rollData = {},
    targetActor = false,
    removeExistingActorItems = false,
    userId = false
  } = {}) {
    const rollTable = await fromUuid(table);
    if (!table.startsWith("Compendium")) {
      if (resetTable) {
        await rollTable.reset();
      }
      await rollTable.normalize();
    }
    const roll = new Roll(timesToRoll.toString(), rollData).evaluate({ async: false });
    if (roll.total <= 0) {
      return [];
    }
    let items = [];
    const tableDraw = await rollTable.drawMany(roll.total, { displayChat, recursive: true });
    for (const rollData2 of tableDraw.results) {
      const existingItem = items.find((item) => item.documentId === rollData2.documentId);
      if (existingItem) {
        existingItem.quantity++;
      } else {
        let item;
        if (rollData2.documentCollection === "Item") {
          item = game.items.get(rollData2.documentId);
        } else {
          const compendium = game.packs.get(rollData2.documentCollection);
          if (compendium) {
            item = await compendium.getDocument(rollData2.documentId);
          }
        }
        if (item instanceof Item) {
          items.push({
            ...rollData2,
            item: item.toObject(),
            quantity: 1
          });
        }
      }
    }
    if (targetActor) {
      items = await this._addItems(targetActor, items, userId, { removeExistingActorItems });
    }
    return items;
  }
}
__name(PrivateAPI, "PrivateAPI");
const hotkeyActionState = {
  get openPileInventory() {
    return !hotkeyState.ctrlDown && !game.settings.get(CONSTANTS.MODULE_NAME, "invertSheetOpen") || hotkeyState.ctrlDown && game.settings.get(CONSTANTS.MODULE_NAME, "invertSheetOpen");
  }
};
const hotkeyState = {
  ctrlDown: false,
  altDown: false,
  shiftDown: false
};
function registerHotkeysPre() {
  game.keybindings.register(CONSTANTS.MODULE_NAME, "force-open-item-pile-inventory", {
    name: "Force open inventory",
    uneditable: [
      { key: "ControlLeft" }
    ],
    onDown: () => {
      hotkeyState.ctrlDown = true;
    },
    onUp: () => {
      hotkeyState.ctrlDown = false;
    },
    reservedModifiers: ["SHIFT", "ALT"]
  });
  game.keybindings.register(CONSTANTS.MODULE_NAME, "force-drop-item", {
    name: "Force drop item (GM only)",
    uneditable: [
      { key: "ShiftLeft" }
    ],
    onDown: () => {
      hotkeyState.shiftDown = true;
    },
    onUp: () => {
      hotkeyState.shiftDown = false;
    },
    reservedModifiers: ["ALT", "CONTROL"]
  });
  game.keybindings.register(CONSTANTS.MODULE_NAME, "force-drop-one-item", {
    name: "Force drop one item",
    uneditable: [
      { key: "AltLeft" }
    ],
    onDown: () => {
      hotkeyState.altDown = true;
    },
    onUp: () => {
      hotkeyState.altDown = false;
    },
    reservedModifiers: ["SHIFT", "CONTROL"]
  });
}
__name(registerHotkeysPre, "registerHotkeysPre");
function registerHotkeysPost() {
  if (!game.user.isGM) {
    let clicked = false;
    window.addEventListener("mousedown", (event) => {
      if (!canvas.ready)
        return;
      if (!(canvas.activeLayer instanceof TokenLayer))
        return;
      if (game.activeTool !== "select")
        return;
      const hover = document.elementFromPoint(event.clientX, event.clientY);
      if (!hover || hover.id !== "board")
        return;
      if (event.button !== 0)
        return;
      const pos = canvas.app.renderer.plugins.interaction.mouse.getLocalPosition(canvas.app.stage);
      const tokens = getTokensAtLocation(pos).filter((token2) => {
        const canView = token2._canView(game.user);
        const canSee = token2.visible || game.user.isGM;
        return !canView && canSee;
      });
      if (!tokens.length)
        return;
      tokens.sort((a, b) => b.zIndex - a.zIndex);
      const token = getDocument(tokens[0]);
      if (clicked === token) {
        clicked = false;
        return PrivateAPI._itemPileClicked(token);
      }
      clicked = token;
      setTimeout(() => {
        clicked = false;
      }, 500);
    });
  }
}
__name(registerHotkeysPost, "registerHotkeysPost");
function getFlagData(inDocument, flag, defaults, existing = false) {
  const defaultFlags = foundry.utils.duplicate(defaults);
  const flags = existing || (getProperty(inDocument, flag) ?? {});
  const data = foundry.utils.duplicate(flags);
  return foundry.utils.mergeObject(defaultFlags, data);
}
__name(getFlagData, "getFlagData");
function getItemFlagData(item, data = false) {
  return getFlagData(getDocument(item), CONSTANTS.FLAGS.ITEM, foundry.utils.deepClone(CONSTANTS.ITEM_DEFAULTS), data);
}
__name(getItemFlagData, "getItemFlagData");
function getActorFlagData(target, data = false) {
  return getFlagData(getActor(target), CONSTANTS.FLAGS.PILE, foundry.utils.deepClone(CONSTANTS.PILE_DEFAULTS), data);
}
__name(getActorFlagData, "getActorFlagData");
function isValidItemPile(target, data = false) {
  const targetActor = getActor(target);
  const pileData = getActorFlagData(targetActor, data);
  return targetActor && pileData?.enabled;
}
__name(isValidItemPile, "isValidItemPile");
function isItemPileContainer(target, data = false) {
  const targetActor = getActor(target);
  const pileData = getActorFlagData(targetActor, data);
  return pileData?.enabled && pileData?.isContainer;
}
__name(isItemPileContainer, "isItemPileContainer");
function isItemPileMerchant(target, data = false) {
  const targetActor = getActor(target);
  const pileData = getActorFlagData(targetActor, data);
  return pileData?.enabled && pileData?.isMerchant;
}
__name(isItemPileMerchant, "isItemPileMerchant");
function isItemPileClosed(target, data = false) {
  const targetActor = getActor(target);
  const pileData = getActorFlagData(targetActor, data);
  if (!pileData?.enabled || !pileData?.isContainer)
    return false;
  return pileData.closed;
}
__name(isItemPileClosed, "isItemPileClosed");
function isItemPileLocked(target, data = false) {
  const targetActor = getActor(target);
  const pileData = getActorFlagData(targetActor, data);
  if (!pileData?.enabled || !pileData?.isContainer)
    return false;
  return pileData.locked;
}
__name(isItemPileLocked, "isItemPileLocked");
function isItemPileEmpty(target) {
  const targetActor = getActor(target);
  if (!targetActor)
    return false;
  const validItemPile = isValidItemPile(targetActor);
  if (!validItemPile)
    return false;
  const hasNoItems = getActorItems(targetActor).length === 0;
  const hasNoAttributes = getActorCurrencies(targetActor).length === 0;
  return validItemPile && hasNoItems && hasNoAttributes;
}
__name(isItemPileEmpty, "isItemPileEmpty");
function shouldItemPileBeDeleted(targetUuid) {
  const target = fromUuidSync(targetUuid);
  if (!(target instanceof TokenDocument))
    return false;
  if (!isItemPileEmpty(target))
    return false;
  const pileData = getActorFlagData(target);
  if (isItemPileMerchant(target, pileData)) {
    return false;
  }
  if (typeof pileData?.deleteWhenEmpty === "boolean") {
    return pileData?.deleteWhenEmpty;
  }
  return {
    "default": getSetting("deleteEmptyPiles"),
    "true": true,
    "false": false
  }[pileData?.deleteWhenEmpty ?? "default"];
}
__name(shouldItemPileBeDeleted, "shouldItemPileBeDeleted");
function getActorItems(target, { itemFilters = false, getItemCurrencies = false } = {}) {
  const actor = getActor(target);
  const actorItemFilters = itemFilters ? cleanItemFilters(itemFilters) : getActorItemFilters(actor);
  const currencies = getActorCurrencies(actor, { getAll: true }).map((entry) => entry.id);
  return actor.items.filter((item) => (getItemCurrencies || currencies.indexOf(item.id) === -1) && !isItemInvalid(actor, item, actorItemFilters));
}
__name(getActorItems, "getActorItems");
function getActorCurrencies(target, { forActor = false, currencyList = false, getAll = false } = {}) {
  const actor = getActor(target);
  const actorItems = Array.from(actor.items);
  currencyList = currencyList || getCurrencyList(forActor || actor);
  let currencies = currencyList.map((currency, index) => {
    if (currency.type === "attribute") {
      return {
        ...currency,
        quantity: getProperty(actor, currency.data.path) ?? 0,
        path: currency.data.path,
        id: currency.data.path,
        index
      };
    }
    const item = findSimilarItem(actorItems, currency.data.item);
    return {
      ...currency,
      quantity: item ? getItemQuantity(item) : 0,
      id: item?.id || null,
      item,
      index
    };
  });
  if (!getAll) {
    currencies = currencies.filter((currency) => currency.quantity);
  }
  return currencies;
}
__name(getActorCurrencies, "getActorCurrencies");
function getActorPrimaryCurrency(target) {
  const actor = getActor(target);
  return getActorCurrencies(actor).find((currency) => currency.primary);
}
__name(getActorPrimaryCurrency, "getActorPrimaryCurrency");
function getCurrencyList(target = false, pileData = false) {
  if (target) {
    const targetActor = getActor(target);
    pileData = getActorFlagData(targetActor, pileData);
  }
  return (pileData.overrideCurrencies || game.itempiles.API.CURRENCIES).map((currency) => {
    currency.name = game.i18n.localize(currency.name);
    return currency;
  });
}
__name(getCurrencyList, "getCurrencyList");
function getActorItemFilters(target, pileData = false) {
  if (!target)
    return cleanItemFilters(game.itempiles.API.ITEM_FILTERS);
  const targetActor = getActor(target);
  pileData = getActorFlagData(targetActor, pileData);
  return isValidItemPile(targetActor, pileData) && pileData?.overrideItemFilters ? cleanItemFilters(pileData.overrideItemFilters) : cleanItemFilters(game.itempiles.API.ITEM_FILTERS);
}
__name(getActorItemFilters, "getActorItemFilters");
function cleanItemFilters(itemFilters) {
  return itemFilters ? foundry.utils.duplicate(itemFilters).map((filter) => {
    filter.path = filter.path.trim();
    filter.filters = Array.isArray(filter.filters) ? filter.filters : filter.filters.split(",").map((string) => string.trim());
    filter.filters = new Set(filter.filters);
    return filter;
  }) : [];
}
__name(cleanItemFilters, "cleanItemFilters");
function isItemInvalid(targetActor, item, itemFilters = false) {
  const pileItemFilters = itemFilters ? itemFilters : getActorItemFilters(targetActor);
  const itemData = item instanceof Item ? item.toObject() : item;
  for (const filter of pileItemFilters) {
    if (!hasProperty(itemData, filter.path))
      continue;
    const attributeValue = getProperty(itemData, filter.path);
    if (filter.filters.has(attributeValue)) {
      return attributeValue;
    }
  }
  return false;
}
__name(isItemInvalid, "isItemInvalid");
async function checkItemType(targetActor, item, {
  errorText = "ITEM-PILES.Errors.DisallowedItemDrop",
  warningTitle = "ITEM-PILES.Dialogs.TypeWarning.Title",
  warningContent = "ITEM-PILES.Dialogs.TypeWarning.DropContent",
  runTransformer = true
} = {}) {
  const disallowedType = isItemInvalid(targetActor, item);
  if (disallowedType) {
    if (!game.user.isGM) {
      return custom_warning(game.i18n.format(errorText, { type: disallowedType }), true);
    }
    if (SYSTEMS.DATA.ITEM_TRANSFORMER && runTransformer) {
      item = await SYSTEMS.DATA.ITEM_TRANSFORMER(item);
    }
    const newDisallowedType = isItemInvalid(targetActor, item);
    if (newDisallowedType && !hotkeyState.shiftDown) {
      const force = await Dialog.confirm({
        title: game.i18n.localize(warningTitle),
        content: `<p class="item-piles-dialog">${game.i18n.format(warningContent, { type: newDisallowedType })}</p>`,
        defaultYes: false
      });
      if (!force) {
        return false;
      }
    }
  } else {
    if (SYSTEMS.DATA.ITEM_TRANSFORMER && runTransformer) {
      item = await SYSTEMS.DATA.ITEM_TRANSFORMER(item);
    }
  }
  return item;
}
__name(checkItemType, "checkItemType");
function isItemCurrency(item, { target = false } = {}) {
  const actor = getActor(target ? target : item.parent);
  const currencies = getActorCurrencies(actor, { getAll: true }).filter((currency) => currency.type === "item").map((item2) => item2.data.item);
  return !!findSimilarItem(currencies, item);
}
__name(isItemCurrency, "isItemCurrency");
function getItemPileTokenImage(token, {
  data = false,
  items = false,
  currencies = false
} = {}, overrideImage = null) {
  const pileDocument = getDocument(token);
  const itemPileData = getActorFlagData(pileDocument, data);
  const originalImg = overrideImage ?? (pileDocument instanceof TokenDocument ? pileDocument.texture.src : pileDocument.prototypeToken.texture.src);
  if (!isValidItemPile(pileDocument))
    return originalImg;
  items = items || getActorItems(pileDocument);
  currencies = currencies || getActorCurrencies(pileDocument);
  const numItems = items.length + currencies.length;
  let img = originalImg;
  if (itemPileData.isContainer) {
    img = itemPileData.lockedImage || itemPileData.closedImage || itemPileData.openedImage || itemPileData.emptyImage;
    if (itemPileData.locked && itemPileData.lockedImage) {
      img = itemPileData.lockedImage;
    } else if (itemPileData.closed && itemPileData.closedImage) {
      img = itemPileData.closedImage;
    } else if (itemPileData.emptyImage && isItemPileEmpty(pileDocument)) {
      img = itemPileData.emptyImage;
    } else if (itemPileData.openedImage) {
      img = itemPileData.openedImage;
    }
  } else if (itemPileData.displayOne && numItems === 1) {
    img = items.length > 0 ? items[0].img : currencies[0].img;
  } else if (itemPileData.displayOne && numItems > 1) {
    img = originalImg;
  }
  return img || originalImg;
}
__name(getItemPileTokenImage, "getItemPileTokenImage");
function getItemPileTokenScale(target, {
  data = false,
  items = false,
  currencies = false
} = {}, overrideScale = null) {
  const pileDocument = getDocument(target);
  let itemPileData = getActorFlagData(pileDocument, data);
  const baseScale = overrideScale ?? (pileDocument instanceof TokenDocument ? pileDocument.texture.scaleX : pileDocument.prototypeToken.texture.scaleX);
  if (!isValidItemPile(pileDocument, itemPileData)) {
    return baseScale;
  }
  items = items || getActorItems(pileDocument);
  currencies = currencies || getActorCurrencies(pileDocument);
  const numItems = items.length + currencies.length;
  if (itemPileData.isContainer || !itemPileData.displayOne || !itemPileData.overrideSingleItemScale || numItems > 1 || numItems === 0) {
    return baseScale;
  }
  return itemPileData.singleItemScale;
}
__name(getItemPileTokenScale, "getItemPileTokenScale");
function getItemPileName(target, { data = false, items = false, currencies = false } = {}, overrideName = null) {
  const pileDocument = getDocument(target);
  const itemPileData = getActorFlagData(pileDocument, data);
  let name = overrideName ?? (pileDocument instanceof TokenDocument ? pileDocument.name : pileDocument.prototypeToken.name);
  if (!isValidItemPile(pileDocument, itemPileData)) {
    return name;
  }
  items = items || getActorItems(pileDocument);
  currencies = currencies || getActorCurrencies(pileDocument);
  const numItems = items.length + currencies.length;
  if (itemPileData.isContainer || !itemPileData.displayOne || !itemPileData.showItemName || numItems > 1 || numItems === 0) {
    return name;
  }
  const item = items.length > 0 ? items[0] : currencies[0];
  return item.name;
}
__name(getItemPileName, "getItemPileName");
function shouldEvaluateChange(target, changes) {
  const flags = getActorFlagData(target, getProperty(changes, CONSTANTS.FLAGS.PILE) ?? {});
  if (!isValidItemPile(target, flags))
    return false;
  return flags.isContainer && (flags.closedImage || flags.emptyImage || flags.openedImage || flags.lockedImage) || flags.displayOne || flags.showItemName || flags.overrideSingleItemScale;
}
__name(shouldEvaluateChange, "shouldEvaluateChange");
function getRelevantTokensAndActor(target) {
  const relevantDocument = getDocument(target);
  let documentActor;
  let documentTokens = [];
  if (relevantDocument instanceof Actor) {
    documentActor = relevantDocument;
    if (relevantDocument.token) {
      documentTokens.push(relevantDocument?.token);
    } else {
      documentTokens = canvas.tokens.placeables.filter((token) => token.document.actor === documentActor).map((token) => token.document);
    }
  } else {
    documentActor = relevantDocument.actor;
    if (relevantDocument.isLinked) {
      documentTokens = canvas.tokens.placeables.filter((token) => token.document.actor === documentActor).map((token) => token.document);
    } else {
      documentTokens.push(relevantDocument);
    }
  }
  return [documentActor, documentTokens];
}
__name(getRelevantTokensAndActor, "getRelevantTokensAndActor");
async function updateItemPileData(target, flagData, tokenData) {
  if (!target)
    return;
  if (!flagData)
    flagData = getActorFlagData(target);
  if (!tokenData)
    tokenData = {};
  let [documentActor, documentTokens] = getRelevantTokensAndActor(target);
  const items = getActorItems(documentActor, { itemFilters: flagData.overrideItemFilters });
  const currencies = getActorCurrencies(documentActor, { currencyList: flagData.overrideCurrencies });
  const pileData = { data: flagData, items, currencies };
  const updates = documentTokens.map((tokenDocument) => {
    const newTokenData = foundry.utils.mergeObject(tokenData, {
      "img": getItemPileTokenImage(tokenDocument, pileData, tokenData?.img),
      "scale": getItemPileTokenScale(tokenDocument, pileData, tokenData?.scale),
      "name": getItemPileName(tokenDocument, pileData, tokenData?.name)
    });
    const data = {
      "_id": tokenDocument.id,
      ...newTokenData
    };
    if (!foundry.utils.isEmpty(flagData)) {
      data[CONSTANTS.FLAGS.PILE] = flagData;
    }
    if (!tokenDocument.actorLink) {
      data["actorData." + CONSTANTS.FLAGS.PILE] = flagData;
      if (tokenDocument.actor === documentActor) {
        documentActor = false;
      }
    }
    return data;
  });
  if (canvas.scene && !foundry.utils.isEmpty(updates)) {
    await canvas.scene.updateEmbeddedDocuments("Token", updates);
  }
  if (!foundry.utils.isEmpty(flagData) && documentActor) {
    await documentActor.update({
      [CONSTANTS.FLAGS.PILE]: flagData,
      [`token.${CONSTANTS.FLAGS.PILE}`]: flagData
    });
  }
  return true;
}
__name(updateItemPileData, "updateItemPileData");
async function updateItemData(item, update2) {
  const flagData = foundry.utils.mergeObject(getItemFlagData(item), update2.flags ?? {});
  return item.update({
    ...update2?.data ?? {},
    [CONSTANTS.FLAGS.ITEM]: flagData
  });
}
__name(updateItemData, "updateItemData");
function getMerchantModifiersForActor(merchant, {
  item = false,
  actor = false,
  pileFlagData = false,
  itemFlagData = false
} = {}) {
  let {
    buyPriceModifier,
    sellPriceModifier,
    itemTypePriceModifiers,
    actorPriceModifiers
  } = getActorFlagData(merchant, pileFlagData);
  if (item) {
    if (!itemFlagData) {
      itemFlagData = getItemFlagData(item);
    }
    const itemTypePriceModifier = itemTypePriceModifiers.find((priceData) => {
      return priceData.type === "custom" ? priceData.category === itemFlagData.customCategory : priceData.type === item.type;
    });
    if (itemTypePriceModifier) {
      buyPriceModifier = itemTypePriceModifier.override ? itemTypePriceModifier.buyPriceModifier : buyPriceModifier * itemTypePriceModifier.buyPriceModifier;
      sellPriceModifier = itemTypePriceModifier.override ? itemTypePriceModifier.sellPriceModifier : sellPriceModifier * itemTypePriceModifier.sellPriceModifier;
    }
  }
  if (actor && actorPriceModifiers) {
    const actorSpecificModifiers = actorPriceModifiers?.find((data) => data.actorUuid === getUuid(actor) || data.actor === actor.id);
    if (actorSpecificModifiers) {
      buyPriceModifier = actorSpecificModifiers.override ? actorSpecificModifiers.buyPriceModifier : buyPriceModifier * actorSpecificModifiers.buyPriceModifier;
      sellPriceModifier = actorSpecificModifiers.override ? actorSpecificModifiers.sellPriceModifier : sellPriceModifier * actorSpecificModifiers.sellPriceModifier;
    }
  }
  return {
    buyPriceModifier,
    sellPriceModifier
  };
}
__name(getMerchantModifiersForActor, "getMerchantModifiersForActor");
function getSmallestExchangeRate(currencies) {
  return currencies.length > 1 ? Math.min(...currencies.map((currency) => currency.exchangeRate)) : getSetting(SETTINGS.CURRENCY_DECIMAL_DIGITS) ?? 1e-5;
}
__name(getSmallestExchangeRate, "getSmallestExchangeRate");
function getExchangeRateDecimals(smallestExchangeRate) {
  return smallestExchangeRate.toString().includes(".") ? smallestExchangeRate.toString().split(".")[1].length : 0;
}
__name(getExchangeRateDecimals, "getExchangeRateDecimals");
function getPriceArray(totalCost, currencies) {
  const primaryCurrency = currencies.find((currency) => currency.primary);
  if (currencies.length === 1) {
    return [{
      ...primaryCurrency,
      cost: totalCost,
      baseCost: totalCost,
      maxCurrencyCost: totalCost,
      string: primaryCurrency.abbreviation.replace("{#}", totalCost)
    }];
  }
  const smallestExchangeRate = getSmallestExchangeRate(currencies);
  const prices = [];
  if (primaryCurrency.exchangeRate === smallestExchangeRate) {
    let cost2 = totalCost;
    for (const currency of currencies) {
      const numCurrency = Math.floor(cost2 / currency.exchangeRate);
      cost2 = cost2 - numCurrency * currency.exchangeRate;
      prices.push({
        ...currency,
        cost: Math.round(numCurrency),
        baseCost: Math.round(numCurrency),
        maxCurrencyCost: Math.ceil(totalCost / currency.exchangeRate),
        string: currency.abbreviation.replace("{#}", numCurrency)
      });
    }
    return prices;
  }
  const decimals = getExchangeRateDecimals(smallestExchangeRate);
  let fraction = roundToDecimals(totalCost % 1, decimals);
  let cost = Math.round(totalCost - fraction);
  let skipPrimary = false;
  if (cost) {
    skipPrimary = true;
    prices.push({
      ...primaryCurrency,
      cost,
      baseCost: cost,
      maxCurrencyCost: totalCost,
      string: primaryCurrency.abbreviation.replace("{#}", cost)
    });
  }
  for (const currency of currencies) {
    if (currency === primaryCurrency && skipPrimary)
      continue;
    const numCurrency = Math.floor(roundToDecimals(fraction / currency.exchangeRate, decimals));
    fraction = roundToDecimals(fraction - numCurrency * currency.exchangeRate, decimals);
    prices.push({
      ...currency,
      cost: Math.round(numCurrency),
      baseCost: Math.round(numCurrency),
      maxCurrencyCost: Math.ceil(totalCost / currency.exchangeRate),
      string: currency.abbreviation.replace("{#}", numCurrency)
    });
  }
  prices.sort((a, b) => b.exchangeRate - a.exchangeRate);
  return prices;
}
__name(getPriceArray, "getPriceArray");
function getPriceFromString(str, currencyList = false) {
  if (!currencyList) {
    currencyList = getCurrencyList();
  }
  const currencies = foundry.utils.duplicate(currencyList).map((currency) => {
    currency.quantity = 0;
    currency.identifier = currency.abbreviation.toLowerCase().replace("{#}", "");
    return currency;
  });
  const splitBy = new RegExp("(.*?) *(" + currencies.map((currency) => currency.identifier).join("|") + ")", "g");
  const parts = [...str.trim().toLowerCase().matchAll(splitBy)];
  let overallCost = 0;
  for (const part of parts) {
    for (const currency of currencies) {
      if (part[2] !== currency.identifier)
        continue;
      try {
        const roll = new Roll(part[1]).evaluate({ async: false });
        currency.quantity = roll.total;
        if (roll.total !== Number(part[1])) {
          currency.roll = roll;
        }
        overallCost += roll.total * currency.exchangeRate;
      } catch (err) {
      }
    }
  }
  if (overallCost === 0) {
    try {
      const roll = new Roll(str).evaluate({ async: false });
      if (roll.total) {
        const primaryCurrency = currencies.find((currency) => currency.primary);
        primaryCurrency.quantity = roll.total;
        if (roll.total !== Number(str)) {
          primaryCurrency.roll = roll;
        }
        overallCost = roll.total;
      }
    } catch (err) {
    }
  }
  return { currencies, overallCost };
}
__name(getPriceFromString, "getPriceFromString");
function getItemPrices(item, {
  seller = false,
  buyer = false,
  sellerFlagData = false,
  buyerFlagData = false,
  itemFlagData = false,
  quantity = 1
} = {}) {
  let priceData = [];
  buyerFlagData = getActorFlagData(buyer, buyerFlagData);
  if (!buyerFlagData?.enabled || !buyerFlagData?.isMerchant) {
    buyerFlagData = false;
  }
  sellerFlagData = getActorFlagData(seller, sellerFlagData);
  if (!sellerFlagData?.enabled || !sellerFlagData?.isMerchant) {
    sellerFlagData = false;
  }
  itemFlagData = itemFlagData || getItemFlagData(item);
  let merchant = sellerFlagData ? seller : buyer;
  if (merchant === buyer && itemFlagData.cantBeSoldToMerchants) {
    priceData.push({
      free: false,
      basePrices: [],
      basePriceString: "",
      prices: [],
      priceString: "",
      totalCost: 0,
      baseCost: 0,
      primary: true,
      maxQuantity: 0,
      quantity
    });
    return priceData;
  }
  let modifier = 1;
  if (sellerFlagData) {
    modifier = getMerchantModifiersForActor(seller, {
      item,
      actor: buyer,
      pileFlagData: sellerFlagData,
      itemFlagData
    }).buyPriceModifier;
  } else if (buyerFlagData) {
    modifier = getMerchantModifiersForActor(buyer, {
      item,
      actor: seller,
      pileFlagData: buyerFlagData,
      itemFlagData
    }).sellPriceModifier;
  }
  const disableNormalCost = itemFlagData.disableNormalCost && !sellerFlagData.onlyAcceptBasePrice;
  const hasOtherPrices = itemFlagData.prices.filter((priceGroup) => priceGroup.length).length > 0;
  const currencyList = getCurrencyList(merchant);
  const currencies = getActorCurrencies(merchant, { currencyList, getAll: true });
  const smallestExchangeRate = getSmallestExchangeRate(currencyList);
  const decimals = getExchangeRateDecimals(smallestExchangeRate);
  let overallCost = getItemCost(item);
  if (game.system.id === "pf2e") {
    const { copperValue } = new game.pf2e.Coins(overallCost.value);
    overallCost = copperValue / 100 / (overallCost.per ?? 1);
  } else if (typeof overallCost === "string" && isNaN(Number(overallCost))) {
    overallCost = getPriceFromString(overallCost, currencyList).overallCost;
  } else {
    overallCost = Number(overallCost);
  }
  if (itemFlagData?.free || !disableNormalCost && (overallCost === 0 || overallCost < smallestExchangeRate) && !hasOtherPrices || modifier <= 0) {
    priceData.push({
      free: true,
      basePrices: [],
      basePriceString: "",
      prices: [],
      priceString: "",
      totalCost: 0,
      baseCost: 0,
      primary: true,
      maxQuantity: Infinity,
      quantity
    });
    return priceData;
  }
  if (overallCost >= smallestExchangeRate && (!itemFlagData.disableNormalCost || merchant === buyer && buyerFlagData.onlyAcceptBasePrice)) {
    const baseCost = roundToDecimals(overallCost * modifier, decimals);
    const basePrices = getPriceArray(baseCost, currencies);
    let totalCost = roundToDecimals(overallCost * modifier * quantity, decimals);
    let prices = getPriceArray(totalCost, currencies);
    if (baseCost) {
      priceData.push({
        basePrices,
        basePriceString: basePrices.filter((price) => price.cost).map((price) => price.string).join(" "),
        prices,
        priceString: prices.filter((price) => price.cost).map((price) => price.string).join(" "),
        totalCost,
        baseCost,
        primary: true,
        maxQuantity: 0,
        quantity
      });
    }
  }
  if (itemFlagData.prices.length && !(merchant === buyer && buyerFlagData.onlyAcceptBasePrice)) {
    priceData = priceData.concat(itemFlagData.prices.map((priceGroup) => {
      const prices = priceGroup.map((price) => {
        const itemModifier = price.fixed ? 1 : modifier;
        const cost = Math.round(price.quantity * itemModifier * quantity);
        const baseCost = Math.round(price.quantity * itemModifier);
        price.name = game.i18n.localize(price.name);
        return {
          ...price,
          cost,
          baseCost,
          modifier: itemModifier,
          priceString: cost ? price.abbreviation.replace("{#}", cost) : "",
          basePriceString: baseCost ? price.abbreviation.replace("{#}", baseCost) : ""
        };
      });
      return {
        prices,
        priceString: prices.filter((price) => price.priceString).map((price) => price.priceString).join(" "),
        basePriceString: prices.filter((price) => price.basePriceString).map((price) => price.basePriceString).join(" "),
        maxQuantity: 0,
        quantity
      };
    }));
  }
  const buyerInfiniteCurrencies = buyerFlagData?.infiniteCurrencies;
  const buyerInfiniteQuantity = buyerFlagData?.infiniteQuantity;
  if (!buyer)
    return priceData;
  const recipientCurrencies = getActorCurrencies(buyer, { currencyList });
  const totalCurrencies = recipientCurrencies.map((currency) => currency.quantity * currency.exchangeRate).reduce((acc, num) => acc + num, 0);
  for (const priceGroup of priceData) {
    priceGroup.maxQuantity = Infinity;
    if (priceGroup.baseCost !== void 0) {
      if (buyerInfiniteCurrencies)
        continue;
      priceGroup.maxQuantity = Math.floor(totalCurrencies / priceGroup.baseCost);
      priceGroup.prices.forEach((price) => {
        price.maxQuantity = priceGroup.maxQuantity;
      });
    } else {
      if (buyerInfiniteQuantity)
        continue;
      for (const price of priceGroup.prices) {
        if (price.type === "attribute") {
          const attributeQuantity = Number(getProperty(buyer, price.data.path));
          price.buyerQuantity = attributeQuantity;
          if (price.percent) {
            const percent = Math.min(1, price.baseCost / 100);
            const percentQuantity = Math.max(0, Math.floor(attributeQuantity * percent));
            price.maxQuantity = Math.floor(attributeQuantity / percentQuantity);
            price.baseCost = !buyer ? price.baseCost : percentQuantity;
            price.cost = !buyer ? price.cost : percentQuantity * quantity;
            price.quantity = !buyer ? price.quantity : percentQuantity;
          } else {
            price.maxQuantity = Math.floor(attributeQuantity / price.baseCost);
          }
          priceGroup.maxQuantity = Math.min(priceGroup.maxQuantity, price.maxQuantity);
        } else {
          const foundItem = findSimilarItem(buyer.items, price.data.item);
          const itemQuantity = foundItem ? getItemQuantity(foundItem) : 0;
          price.buyerQuantity = itemQuantity;
          if (price.percent) {
            const percent = Math.min(1, price.baseCost / 100);
            const percentQuantity = Math.max(0, Math.floor(itemQuantity * percent));
            price.maxQuantity = Math.floor(itemQuantity / percentQuantity);
            price.baseCost = !buyer ? price.baseCost : percentQuantity;
            price.cost = !buyer ? price.cost : percentQuantity * quantity;
            price.quantity = !buyer ? price.quantity : percentQuantity;
          } else {
            price.maxQuantity = Math.floor(itemQuantity / price.baseCost);
          }
          priceGroup.maxQuantity = Math.min(priceGroup.maxQuantity, price.maxQuantity);
        }
      }
    }
  }
  return priceData;
}
__name(getItemPrices, "getItemPrices");
function getPricesForItems(itemsToBuy, {
  seller = false,
  buyer = false,
  sellerFlagData = false,
  buyerFlagData = false
} = {}) {
  sellerFlagData = getActorFlagData(seller, sellerFlagData);
  if (!sellerFlagData?.enabled || !sellerFlagData?.isMerchant) {
    sellerFlagData = false;
  }
  buyerFlagData = getActorFlagData(buyer, buyerFlagData);
  if (!buyerFlagData?.enabled || !buyerFlagData?.isMerchant) {
    buyerFlagData = false;
  }
  const merchant = sellerFlagData ? seller : buyer;
  const currencyList = getCurrencyList(merchant);
  const currencies = getActorCurrencies(merchant, { currencyList, getAll: true });
  const smallestExchangeRate = getSmallestExchangeRate(currencies);
  const decimals = getExchangeRateDecimals(smallestExchangeRate);
  const recipientCurrencies = getActorCurrencies(buyer, { currencyList, getAll: true });
  const buyerInfiniteCurrencies = buyerFlagData?.infiniteCurrencies;
  const paymentData = itemsToBuy.map((data) => {
    const prices = getItemPrices(data.item, {
      seller,
      buyer,
      sellerFlagData,
      buyerFlagData,
      itemFlagData: data.itemFlagData,
      quantity: data.quantity || 1
    })[data.paymentIndex || 0];
    return {
      ...prices,
      item: data.item
    };
  }).reduce((priceData, priceGroup) => {
    if (!priceGroup.maxQuantity)
      return priceData;
    if (priceGroup.primary) {
      priceData.totalCurrencyCost = roundToDecimals(priceData.totalCurrencyCost + priceGroup.totalCost, decimals);
      priceData.primary = true;
    } else {
      for (const price of priceGroup.prices) {
        let existingPrice = priceData.otherPrices.find((otherPrice) => {
          return otherPrice.id === price.id || otherPrice.name === price.name && otherPrice.img === price.img && otherPrice.type === price.type;
        });
        if (existingPrice) {
          existingPrice.cost += price.cost;
        } else {
          const index = priceData.otherPrices.push(price);
          existingPrice = priceData.otherPrices[index - 1];
          existingPrice.quantity = 0;
        }
        existingPrice.quantity += price.cost;
        existingPrice.buyerQuantity -= price.cost;
        if (existingPrice.buyerQuantity < 0) {
          priceData.canBuy = false;
        }
      }
    }
    priceData.buyerReceive.push({
      type: "item",
      name: priceGroup.item.name,
      img: priceGroup.item.img,
      quantity: priceGroup.quantity,
      item: priceGroup.item
    });
    return priceData;
  }, {
    totalCurrencyCost: 0,
    canBuy: true,
    primary: false,
    finalPrices: [],
    otherPrices: [],
    buyerReceive: [],
    buyerChange: [],
    sellerReceive: []
  });
  if (paymentData.totalCurrencyCost) {
    const prices = getPriceArray(paymentData.totalCurrencyCost, recipientCurrencies);
    let priceLeft = paymentData.totalCurrencyCost;
    for (let i = prices.length - 1; i >= 0; i--) {
      const price = prices[i];
      const buyerPrice = {
        ...price,
        buyerQuantity: buyerInfiniteCurrencies ? Infinity : price.quantity,
        quantity: 0,
        isCurrency: true
      };
      if (price.type === "item") {
        buyerPrice.item = price.data.item;
      }
      if (priceLeft <= 0 || !price.cost || currencies.length === 1) {
        if (currencies.length === 1) {
          buyerPrice.quantity = price.cost;
          priceLeft = 0;
        }
        paymentData.finalPrices.push(buyerPrice);
        continue;
      }
      buyerPrice.quantity = buyerPrice.buyerQuantity < price.cost ? buyerPrice.buyerQuantity : price.cost;
      if (price.primary) {
        const totalCurrencyValue = roundToDecimals(buyerPrice.buyerQuantity * price.exchangeRate, decimals);
        if (totalCurrencyValue > priceLeft) {
          buyerPrice.quantity = Math.ceil(priceLeft);
        }
      }
      paymentData.finalPrices.push(buyerPrice);
      priceLeft = roundToDecimals(priceLeft - buyerPrice.quantity * price.exchangeRate, decimals);
    }
    if (currencies.length > 1) {
      while (priceLeft > 0) {
        for (const buyerPrice of paymentData.finalPrices) {
          let buyerCurrencyQuantity = buyerPrice.buyerQuantity - buyerPrice.quantity;
          if (!buyerCurrencyQuantity)
            continue;
          const newQuantity = Math.ceil(Math.min(buyerCurrencyQuantity, priceLeft / buyerPrice.exchangeRate));
          buyerPrice.quantity += newQuantity;
          priceLeft = roundToDecimals(priceLeft - newQuantity * buyerPrice.exchangeRate, decimals);
          if (priceLeft <= 0)
            break;
        }
        if (priceLeft > 0) {
          paymentData.finalPrices = paymentData.finalPrices.sort((a, b) => b.exchangeRate - a.exchangeRate);
        } else {
          break;
        }
      }
      paymentData.finalPrices = paymentData.finalPrices.sort((a, b) => b.exchangeRate - a.exchangeRate);
      let change = Math.abs(priceLeft);
      for (const currency of currencies) {
        if (!change)
          break;
        let numCurrency = Math.floor(roundToDecimals(change / currency.exchangeRate, decimals));
        change = roundToDecimals(change - numCurrency * currency.exchangeRate, decimals);
        if (numCurrency) {
          const payment = paymentData.finalPrices.find((payment2) => {
            return payment2.id === currency.id || payment2.name === currency.name && payment2.img === currency.img && payment2.type === currency.type;
          });
          if (!payment)
            continue;
          if (payment.quantity - numCurrency >= 0) {
            payment.quantity -= numCurrency;
          } else {
            paymentData.buyerChange.push({
              ...currency,
              isCurrency: true,
              quantity: numCurrency - payment.quantity
            });
            payment.quantity = 0;
          }
        }
      }
    }
    paymentData.sellerReceive = paymentData.finalPrices.map((price) => {
      return { ...price };
    });
    let changeNeeded = paymentData.buyerChange.reduce((acc, change) => {
      const currency = currencies.find((currency2) => {
        return change.id === currency2.id || change.name === currency2.name && change.img === currency2.img && change.type === currency2.type;
      });
      return acc + currency.quantity >= change.quantity ? 0 : (change.quantity - currency.quantity) * change.exchangeRate;
    }, 0);
    if (changeNeeded) {
      const primaryCurrency = paymentData.sellerReceive.find((price) => price.primary && price.quantity * price.exchangeRate > changeNeeded);
      if (primaryCurrency) {
        primaryCurrency.quantity--;
        changeNeeded -= 1 * primaryCurrency.exchangeRate;
      } else {
        const biggestCurrency = paymentData.sellerReceive.find((price) => price.quantity && price.quantity * price.exchangeRate > changeNeeded);
        biggestCurrency.quantity--;
        changeNeeded -= 1 * biggestCurrency.exchangeRate;
      }
      changeNeeded = Math.abs(changeNeeded);
      for (const currency of paymentData.sellerReceive) {
        if (!changeNeeded)
          break;
        let numCurrency = Math.floor(roundToDecimals(changeNeeded / currency.exchangeRate, decimals));
        changeNeeded = roundToDecimals(changeNeeded - numCurrency * currency.exchangeRate, decimals);
        currency.quantity += numCurrency;
      }
    }
  }
  paymentData.finalPrices = paymentData.finalPrices.concat(paymentData.otherPrices);
  paymentData.sellerReceive = paymentData.sellerReceive.concat(paymentData.otherPrices);
  paymentData.basePriceString = paymentData.finalPrices.filter((price) => price.cost).map((price) => {
    let abbreviation = price.abbreviation;
    if (price.percent && abbreviation.includes("%")) {
      abbreviation = abbreviation.replaceAll("%", "");
    }
    return abbreviation.replace("{#}", price.cost);
  }).join(" ");
  delete paymentData.otherPrices;
  return paymentData;
}
__name(getPricesForItems, "getPricesForItems");
function registerUIOverrides() {
  Hooks.on("renderPlayerList", addTradeButton);
  Hooks.on("getActorDirectoryEntryContext", insertActorContextMenuItems);
  Hooks.on("getActorSheetHeaderButtons", insertActorHeaderButtons);
  Hooks.on("getItemSheetHeaderButtons", insertItemHeaderButtons);
  Hooks.on("renderSidebarTab", hideTemporaryItems);
  Hooks.on("renderTokenHUD", renderPileHUD);
}
__name(registerUIOverrides, "registerUIOverrides");
function hideTemporaryItems(sidebar) {
  if (sidebar.tabName !== "items")
    return;
  Array.from(game.items).filter((item) => {
    return getProperty(item.toObject(), CONSTANTS.FLAGS.TEMPORARY_ITEM);
  }).forEach((item) => {
    const element2 = sidebar.element.find(`.directory-item[data-document-id="${item.id}"]`);
    if (!element2.length)
      return;
    if (element2.parent().children().length === 1) {
      return element2.parent().empty();
    }
    element2.find(`.directory-item[data-document-id="${item.id}"]`).remove();
  });
}
__name(hideTemporaryItems, "hideTemporaryItems");
function addTradeButton(app, html) {
  if (!getSetting(SETTINGS.ENABLE_TRADING) || !getSetting(SETTINGS.SHOW_TRADE_BUTTON))
    return;
  const minimalUI = game.modules.get("minimal-ui")?.active;
  const classes = "item-piles-player-list-trade-button" + (minimalUI ? " item-piles-minimal-ui" : "");
  const text2 = !minimalUI ? " Request Trade" : "";
  const button = $(`<button type="button" class="${classes}"><i class="fas fa-handshake"></i>${text2}</button>`);
  button.click(() => {
    game.itempiles.API.requestTrade();
  });
  html.append(button);
}
__name(addTradeButton, "addTradeButton");
function insertActorContextMenuItems(html, menuItems) {
  menuItems.push({
    name: "Item Piles: " + game.i18n.localize("ITEM-PILES.ContextMenu.ShowToPlayers"),
    icon: `<i class="fas fa-eye"></i>`,
    callback: async (html2) => {
      const actorId = html2[0].dataset.documentId;
      const actor = game.actors.get(actorId);
      const activeUsers = Array.from(game.users).filter((u) => u.active && u !== game.user).map((u) => u.id);
      if (!activeUsers.length) {
        return custom_warning(game.i18n.localize("ITEM-PILES.Warnings.NoPlayersActive"), true);
      }
      const users = await UserSelectDialog.show();
      if (!users || !users.length)
        return;
      custom_notify(game.i18n.format("ITEM-PILES.Notifications.ShownToPlayers", { actor_name: actor.name }));
      return game.itempiles.API.renderItemPileInterface(actor, { userIds: users, useDefaultCharacter: true });
    },
    condition: (html2) => {
      const actorId = html2[0].dataset.documentId;
      const actor = game.actors.get(actorId);
      return game.user.isGM && isValidItemPile(actor);
    }
  }, {
    name: "Item Piles: " + game.i18n.localize("ITEM-PILES.ContextMenu.RequestTrade"),
    icon: `<i class="fas fa-handshake"></i>`,
    callback: (html2) => {
      const actorId = html2[0].dataset.documentId;
      const actor = game.actors.get(actorId);
      const user = Array.from(game.users).find((u) => u.character === actor && u.active);
      return game.itempiles.API.requestTrade(user);
    },
    condition: (html2) => {
      const actorId = html2[0].dataset.documentId;
      const actor = game.actors.get(actorId);
      return getSetting(SETTINGS.ENABLE_TRADING) && (game.user?.character !== actor || Array.from(game.users).find((u) => u.character === actor && u.active));
    }
  });
}
__name(insertActorContextMenuItems, "insertActorContextMenuItems");
function insertActorHeaderButtons(actorSheet, buttons) {
  if (!game.user.isGM || getSetting(SETTINGS.HIDE_ACTOR_HEADER_BUTTON))
    return;
  let obj = actorSheet.object;
  buttons.unshift({
    label: getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "" : "Configure",
    icon: "fas fa-box-open",
    class: "item-piles-config-button",
    onclick: () => {
      ItemPileConfig.show(obj);
    }
  });
}
__name(insertActorHeaderButtons, "insertActorHeaderButtons");
function insertItemHeaderButtons(itemSheet, buttons) {
  if (!game.user.isGM || getSetting(SETTINGS.HIDE_ACTOR_HEADER_BUTTON))
    return;
  let obj = itemSheet.object;
  buttons.unshift({
    label: getSetting(SETTINGS.HIDE_ACTOR_HEADER_TEXT) ? "" : "Configure",
    icon: "fas fa-box-open",
    class: "item-piles-config-button",
    onclick: () => {
      ItemEditor.show(obj);
    }
  });
}
__name(insertItemHeaderButtons, "insertItemHeaderButtons");
function renderPileHUD(app, html) {
  const document2 = app?.object?.document;
  if (!document2)
    return;
  if (!isValidItemPile(document2))
    return;
  const pileData = getActorFlagData(document2);
  const container = $(`<div class="col right" style="right:-130px;"></div>`);
  if (pileData.isContainer) {
    const lock_button = $(`<div class="control-icon item-piles" title="${game.i18n.localize("ITEM-PILES.HUD.ToggleLocked")}"><i class="fas fa-lock${pileData.locked ? "" : "-open"}"></i></div>`);
    lock_button.click(async function() {
      $(this).find(".fas").toggleClass("fa-lock").toggleClass("fa-lock-open");
      await game.itempiles.API.toggleItemPileLocked(document2);
    });
    container.append(lock_button);
    const open_button = $(`<div class="control-icon item-piles" title="${game.i18n.localize("ITEM-PILES.HUD.ToggleClosed")}"><i class="fas fa-box${pileData.closed ? "" : "-open"}"></i></div>`);
    open_button.click(async function() {
      $(this).find(".fas").toggleClass("fa-box").toggleClass("fa-box-open");
      await game.itempiles.API.toggleItemPileClosed(document2);
    });
    container.append(open_button);
  }
  const configure_button = $(`<div class="control-icon item-piles" title="${game.i18n.localize("ITEM-PILES.HUD.Configure")}"><i class="fas fa-toolbox"></i></div>`);
  configure_button.click(async function() {
    ItemPileConfig.show(document2);
  });
  container.append(configure_button);
  html.append(container);
}
__name(renderPileHUD, "renderPileHUD");
function registerLibwrappers() {
  libWrapper.register(CONSTANTS.MODULE_NAME, "Token.prototype._onClickLeft2", function(wrapped, ...args) {
    if (isValidItemPile(this.document) && hotkeyActionState.openPileInventory) {
      return PrivateAPI._itemPileClicked(this.document);
    }
    return wrapped(...args);
  }, "MIXED");
  libWrapper.register(CONSTANTS.MODULE_NAME, `SidebarDirectory.prototype._onClickDocumentName`, function(wrapped, event) {
    event.preventDefault();
    const element2 = event.currentTarget;
    const documentId = element2.parentElement.dataset.documentId;
    const document2 = this.constructor.collection.get(documentId);
    if (isValidItemPile(document2) && hotkeyActionState.openPileInventory) {
      return game.itempiles.API.renderItemPileInterface(document2, { useDefaultCharacter: true });
    }
    return wrapped(event);
  }, "MIXED");
}
__name(registerLibwrappers, "registerLibwrappers");
const Setting_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i][0];
  child_ctx[8] = list[i][1];
  child_ctx[10] = i;
  return child_ctx;
}
__name(get_each_context$1, "get_each_context$1");
function create_else_block_1(ctx) {
  let div;
  let input;
  let t;
  let mounted;
  let dispose;
  let if_block = ctx[0].localize && create_if_block_4(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      attr(input, "type", "text");
      input.disabled = ctx[1];
      attr(input, "class", "svelte-1338swc");
      attr(div, "class", "setting-container svelte-1338swc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0].value);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = listen(input, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input.disabled = ctx2[1];
      }
      if (dirty & 1 && input.value !== ctx2[0].value) {
        set_input_value(input, ctx2[0].value);
      }
      if (ctx2[0].localize) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_else_block_1, "create_else_block_1");
function create_if_block_3(ctx) {
  let input;
  let input_step_value;
  let input_min_value;
  let input_max_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
      input.disabled = ctx[1];
      attr(input, "step", input_step_value = ctx[0].step);
      attr(input, "min", input_min_value = ctx[0].min);
      attr(input, "max", input_max_value = ctx[0].max);
      attr(input, "class", "svelte-1338swc");
      toggle_class(input, "invalid", !ctx[0].value && ctx[0].value !== 0);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0].value);
      if (!mounted) {
        dispose = listen(input, "input", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input.disabled = ctx2[1];
      }
      if (dirty & 1 && input_step_value !== (input_step_value = ctx2[0].step)) {
        attr(input, "step", input_step_value);
      }
      if (dirty & 1 && input_min_value !== (input_min_value = ctx2[0].min)) {
        attr(input, "min", input_min_value);
      }
      if (dirty & 1 && input_max_value !== (input_max_value = ctx2[0].max)) {
        attr(input, "max", input_max_value);
      }
      if (dirty & 1 && to_number(input.value) !== ctx2[0].value) {
        set_input_value(input, ctx2[0].value);
      }
      if (dirty & 1) {
        toggle_class(input, "invalid", !ctx2[0].value && ctx2[0].value !== 0);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_3, "create_if_block_3");
function create_if_block_1(ctx) {
  let div;
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let select_name_value;
  let mounted;
  let dispose;
  let each_value = Object.entries(ctx[0].choices);
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[10], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "name", select_name_value = ctx[0].key);
      select.disabled = ctx[1];
      attr(select, "class", "svelte-1338swc");
      if (ctx[0].value === void 0)
        add_render_callback(() => ctx[4].call(select));
      attr(div, "class", "choice-container svelte-1338swc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[0].value);
      if (!mounted) {
        dispose = listen(select, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = Object.entries(ctx2[0].choices);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$1, null, get_each_context$1);
      }
      if (dirty & 1 && select_name_value !== (select_name_value = ctx2[0].key)) {
        attr(select, "name", select_name_value);
      }
      if (dirty & 2) {
        select.disabled = ctx2[1];
      }
      if (dirty & 1) {
        select_option(select, ctx2[0].value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block_1, "create_if_block_1");
function create_if_block$2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      input.disabled = ctx[1];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].value;
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input.disabled = ctx2[1];
      }
      if (dirty & 1) {
        input.checked = ctx2[0].value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$2, "create_if_block$2");
function create_if_block_4(ctx) {
  let input;
  let input_value_value;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      input.disabled = true;
      input.value = input_value_value = localize(ctx[0].value);
      attr(input, "class", "svelte-1338swc");
    },
    m(target, anchor) {
      insert(target, input, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_value_value !== (input_value_value = localize(ctx2[0].value)) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
    }
  };
}
__name(create_if_block_4, "create_if_block_4");
function create_else_block(ctx) {
  let option;
  let t_value = localize(ctx[8]) + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[7];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = localize(ctx2[8]) + ""))
        set_data(t, t_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[7])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_else_block, "create_else_block");
function create_if_block_2(ctx) {
  let option;
  let t_value = localize(ctx[8]) + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[10];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = localize(ctx2[8]) + ""))
        set_data(t, t_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[10])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
__name(create_if_block_2, "create_if_block_2");
function create_each_block$1(key_1, ctx) {
  let first;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].type === Number)
      return create_if_block_2;
    return create_else_block;
  }
  __name(select_block_type_1, "select_block_type_1");
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
__name(create_each_block$1, "create_each_block$1");
function create_fragment$4(ctx) {
  let div2;
  let div0;
  let label;
  let t0_value = localize(ctx[0].name) + "";
  let t0;
  let t1;
  let a;
  let i;
  let t2;
  let p;
  let t3_value = localize(ctx[0].hint) + "";
  let t3;
  let t4;
  let div1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].type === Boolean)
      return create_if_block$2;
    if (ctx2[0].choices)
      return create_if_block_1;
    if (ctx2[0].type === Number)
      return create_if_block_3;
    return create_else_block_1;
  }
  __name(select_block_type, "select_block_type");
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      i = element("i");
      t2 = space();
      p = element("p");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      if_block.c();
      attr(i, "title", "Reset data");
      attr(i, "class", "fas fa-undo reset-setting svelte-1338swc");
      attr(label, "class", "svelte-1338swc");
      attr(p, "class", "notes");
      attr(div0, "class", "label-side svelte-1338swc");
      attr(div1, "class", "form-fields input-side svelte-1338swc");
      attr(div2, "class", "setting form-scope item-piles-flexrow svelte-1338swc");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(label, t0);
      append(label, t1);
      append(label, a);
      append(a, i);
      append(div0, t2);
      append(div0, p);
      append(p, t3);
      append(div2, t4);
      append(div2, div1);
      if_block.m(div1, null);
      if (!mounted) {
        dispose = listen(i, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = localize(ctx2[0].name) + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t3_value !== (t3_value = localize(ctx2[0].hint) + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$4, "create_fragment$4");
function instance$4($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { disabled = false } = $$props;
  const click_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(0, data.value = data.default, data);
  }, "click_handler");
  function input_change_handler() {
    data.value = this.checked;
    $$invalidate(0, data);
  }
  __name(input_change_handler, "input_change_handler");
  function select_change_handler() {
    data.value = select_value(this);
    $$invalidate(0, data);
  }
  __name(select_change_handler, "select_change_handler");
  function input_input_handler() {
    data.value = to_number(this.value);
    $$invalidate(0, data);
  }
  __name(input_input_handler, "input_input_handler");
  function input_input_handler_1() {
    data.value = this.value;
    $$invalidate(0, data);
  }
  __name(input_input_handler_1, "input_input_handler_1");
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  return [
    data,
    disabled,
    click_handler,
    input_change_handler,
    select_change_handler,
    input_input_handler,
    input_input_handler_1
  ];
}
__name(instance$4, "instance$4");
class Setting extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { data: 0, disabled: 1 });
  }
}
__name(Setting, "Setting");
const itemSimilaritiesEditor_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  child_ctx[13] = list;
  child_ctx[14] = i;
  return child_ctx;
}
__name(get_each_context, "get_each_context");
function create_each_block(key_1, ctx) {
  let tr;
  let td0;
  let input;
  let t0;
  let td1;
  let button;
  let t1;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[8].call(input, ctx[13], ctx[14]);
  }
  __name(input_input_handler, "input_input_handler");
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      input = element("input");
      t0 = space();
      td1 = element("td");
      button = element("button");
      button.innerHTML = `<i class="fas fa-times"></i>`;
      t1 = space();
      attr(input, "type", "text");
      input.required = true;
      attr(input, "placeholder", "'type' or 'name' etc");
      attr(button, "type", "button");
      attr(button, "class", "svelte-vd7iuf");
      attr(td1, "class", "small svelte-vd7iuf");
      attr(tr, "class", "svelte-vd7iuf");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, input);
      set_input_value(input, ctx[12]);
      append(tr, t0);
      append(tr, td1);
      append(td1, button);
      append(tr, t1);
      if (!mounted) {
        dispose = [
          listen(input, "input", input_input_handler),
          listen(button, "click", function() {
            if (is_function(ctx[6](ctx[14])))
              ctx[6](ctx[14]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && input.value !== ctx[12]) {
        set_input_value(input, ctx[12]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_each_block, "create_each_block");
function create_default_slot$2(ctx) {
  let form_1;
  let p0;
  let t1;
  let p1;
  let t3;
  let table;
  let tr;
  let th0;
  let t5;
  let th1;
  let a;
  let t6;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t7;
  let footer;
  let button0;
  let i1;
  let t8;
  let t9_value = localize("ITEM-PILES.Applications.SimilaritiesEditor.Submit") + "";
  let t9;
  let t10;
  let button1;
  let i2;
  let t11;
  let t12_value = localize("Cancel") + "";
  let t12;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  const get_key = /* @__PURE__ */ __name((ctx2) => ctx2[14], "get_key");
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      form_1 = element("form");
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.SimilaritiesEditor.Explanation_P1")}`;
      t1 = space();
      p1 = element("p");
      p1.textContent = `${localize("ITEM-PILES.Applications.SimilaritiesEditor.Explanation_P2")}`;
      t3 = space();
      table = element("table");
      tr = element("tr");
      th0 = element("th");
      th0.textContent = `${localize("ITEM-PILES.Applications.SimilaritiesEditor.Path")}`;
      t5 = space();
      th1 = element("th");
      a = element("a");
      a.innerHTML = `<i class="fas fa-plus"></i>`;
      t6 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t7 = space();
      footer = element("footer");
      button0 = element("button");
      i1 = element("i");
      t8 = space();
      t9 = text(t9_value);
      t10 = space();
      button1 = element("button");
      i2 = element("i");
      t11 = space();
      t12 = text(t12_value);
      attr(a, "class", "item-piles-clickable svelte-vd7iuf");
      attr(th1, "class", "small svelte-vd7iuf");
      attr(tr, "class", "svelte-vd7iuf");
      attr(table, "class", "svelte-vd7iuf");
      attr(i1, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i2, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p0);
      append(form_1, t1);
      append(form_1, p1);
      append(form_1, t3);
      append(form_1, table);
      append(table, tr);
      append(tr, th0);
      append(tr, t5);
      append(tr, th1);
      append(th1, a);
      append(table, t6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      append(form_1, t7);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i1);
      append(button0, t8);
      append(button0, t9);
      append(footer, t10);
      append(footer, button1);
      append(button1, i2);
      append(button1, t11);
      append(button1, t12);
      ctx[10](form_1);
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[5]),
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[9], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[7]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 66) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, destroy_block, create_each_block, null, get_each_context);
      }
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$2, "create_default_slot$2");
function create_fragment$3(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[11](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$2] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 32778) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$3, "create_fragment$3");
function instance$3($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let form;
  let { elementRoot } = $$props;
  let { itemSimilarities } = $$props;
  function add() {
    $$invalidate(1, itemSimilarities = [...itemSimilarities, ""]);
    $$invalidate(1, itemSimilarities);
  }
  __name(add, "add");
  function remove(index) {
    itemSimilarities.splice(index, 1);
    $$invalidate(1, itemSimilarities);
  }
  __name(remove, "remove");
  async function updateSettings() {
    application.options.resolve(itemSimilarities);
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function input_input_handler(each_value, index) {
    each_value[index] = this.value;
    $$invalidate(1, itemSimilarities);
  }
  __name(input_input_handler, "input_input_handler");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("itemSimilarities" in $$props2)
      $$invalidate(1, itemSimilarities = $$props2.itemSimilarities);
  };
  return [
    elementRoot,
    itemSimilarities,
    requestSubmit,
    form,
    application,
    add,
    remove,
    updateSettings,
    input_input_handler,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$3, "instance$3");
class Item_similarities_editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {
      elementRoot: 0,
      itemSimilarities: 1,
      requestSubmit: 2
    });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get itemSimilarities() {
    return this.$$.ctx[1];
  }
  set itemSimilarities(itemSimilarities) {
    this.$$set({ itemSimilarities });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Item_similarities_editor, "Item_similarities_editor");
class ItemSimilaritiesEditor extends SvelteApplication {
  constructor(itemSimilarities, options) {
    super({
      svelte: {
        class: Item_similarities_editor,
        target: document.body,
        props: {
          itemSimilarities
        }
      },
      close: () => this.options.resolve(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: game.i18n.localize("ITEM-PILES.Applications.SimilaritiesEditor.Title"),
      width: 400,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static async show(itemSimilarities, options = {}) {
    return new Promise((resolve) => {
      options.resolve = resolve;
      return new this(itemSimilarities, options).render(true, { focus: true });
    });
  }
}
__name(ItemSimilaritiesEditor, "ItemSimilaritiesEditor");
const pricePresetEditorShell_svelte_svelte_type_style_lang = "";
function create_default_slot$1(ctx) {
  let form_1;
  let p;
  let t1;
  let pricelist;
  let updating_prices;
  let t2;
  let footer;
  let button0;
  let i0;
  let t3;
  let t4_value = localize("ITEM-PILES.Applications.PricePresetEditor.Update") + "";
  let t4;
  let t5;
  let button1;
  let i1;
  let t6;
  let t7_value = localize("Cancel") + "";
  let t7;
  let current;
  let mounted;
  let dispose;
  function pricelist_prices_binding(value) {
    ctx[6](value);
  }
  __name(pricelist_prices_binding, "pricelist_prices_binding");
  let pricelist_props = { presets: false };
  if (ctx[0] !== void 0) {
    pricelist_props.prices = ctx[0];
  }
  pricelist = new PriceList({ props: pricelist_props });
  binding_callbacks.push(() => bind$1(pricelist, "prices", pricelist_prices_binding));
  return {
    c() {
      form_1 = element("form");
      p = element("p");
      p.textContent = `${localize("ITEM-PILES.Applications.PricePresetEditor.Explanation")}`;
      t1 = space();
      create_component(pricelist.$$.fragment);
      t2 = space();
      footer = element("footer");
      button0 = element("button");
      i0 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      button1 = element("button");
      i1 = element("i");
      t6 = space();
      t7 = text(t7_value);
      attr(p, "class", "svelte-1vdoydt");
      attr(i0, "class", "far fa-save");
      attr(button0, "type", "button");
      attr(i1, "class", "far fa-times");
      attr(button1, "type", "button");
      attr(form_1, "autocomplete", "off");
      attr(form_1, "class", "item-piles-config-container");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, p);
      append(form_1, t1);
      mount_component(pricelist, form_1, null);
      append(form_1, t2);
      append(form_1, footer);
      append(footer, button0);
      append(button0, i0);
      append(button0, t3);
      append(button0, t4);
      append(footer, t5);
      append(footer, button1);
      append(button1, i1);
      append(button1, t6);
      append(button1, t7);
      ctx[8](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[2], { once: true }),
          listen(button1, "click", ctx[7], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[5]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const pricelist_changes = {};
      if (!updating_prices && dirty & 1) {
        updating_prices = true;
        pricelist_changes.prices = ctx2[0];
        add_flush_callback(() => updating_prices = false);
      }
      pricelist.$set(pricelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pricelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pricelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(pricelist);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot$1, "create_default_slot$1");
function create_fragment$2(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[9](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$1] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    applicationshell_props.elementRoot = ctx[1];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & 1033) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & 2) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[1];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment$2, "create_fragment$2");
function instance$2($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { prices } = $$props;
  let { elementRoot } = $$props;
  let form;
  async function updateSettings() {
    application.options.resolve(prices);
    application.close();
  }
  __name(updateSettings, "updateSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  function pricelist_prices_binding(value) {
    prices = value;
    $$invalidate(0, prices);
  }
  __name(pricelist_prices_binding, "pricelist_prices_binding");
  const click_handler = /* @__PURE__ */ __name(() => {
    application.close();
  }, "click_handler");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(3, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(1, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("prices" in $$props2)
      $$invalidate(0, prices = $$props2.prices);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
  };
  return [
    prices,
    elementRoot,
    requestSubmit,
    form,
    application,
    updateSettings,
    pricelist_prices_binding,
    click_handler,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance$2, "instance$2");
class Price_preset_editor_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
      prices: 0,
      elementRoot: 1,
      requestSubmit: 2
    });
  }
  get prices() {
    return this.$$.ctx[0];
  }
  set prices(prices) {
    this.$$set({ prices });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get requestSubmit() {
    return this.$$.ctx[2];
  }
}
__name(Price_preset_editor_shell, "Price_preset_editor_shell");
class PricePresetEditor extends SvelteApplication {
  constructor(prices, options) {
    super({
      id: `item-pile-price-preset-editor`,
      title: game.i18n.format("ITEM-PILES.Applications.PricePresetEditor.Title"),
      svelte: {
        class: Price_preset_editor_shell,
        target: document.body,
        props: {
          prices
        }
      },
      close: () => this.options.resolve(null),
      ...options
    });
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 500,
      height: "auto",
      classes: ["item-piles-app"]
    });
  }
  static getActiveApp() {
    return Object.values(ui.windows).find((app) => app.id === `item-pile-price-preset-editor`);
  }
  static async show(prices, options = {}, dialogData = {}) {
    const app = this.getActiveApp();
    if (app)
      return app.render(false, { focus: true });
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(prices, options, dialogData).render(true, { focus: true });
    });
  }
}
__name(PricePresetEditor, "PricePresetEditor");
const editors = {
  "currencies": CurrenciesEditor,
  "item-filters": ItemFiltersEditor,
  "item-similarities": ItemSimilaritiesEditor,
  "price-modifiers": PriceModifiersEditor,
  "price-presets": PricePresetEditor
};
const SettingButton_svelte_svelte_type_style_lang = "";
function create_if_block$1(ctx) {
  let a;
  let i;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i = element("i");
      attr(i, "title", "Reset data");
      attr(i, "class", "fas fa-undo reset-setting svelte-19zyr1u");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i);
      if (!mounted) {
        dispose = listen(i, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
__name(create_if_block$1, "create_if_block$1");
function create_fragment$1(ctx) {
  let div3;
  let div0;
  let label;
  let t0_value = localize(ctx[0].name) + "";
  let t0;
  let t1;
  let t2;
  let p;
  let t3_value = localize(ctx[0].hint) + "";
  let t3;
  let t4;
  let div2;
  let div1;
  let button;
  let i;
  let i_class_value;
  let t5;
  let t6_value = localize(ctx[0].label) + "";
  let t6;
  let mounted;
  let dispose;
  let if_block = !ctx[0].hideResetButton && create_if_block$1(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      p = element("p");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      div1 = element("div");
      button = element("button");
      i = element("i");
      t5 = space();
      t6 = text(t6_value);
      attr(label, "class", "svelte-19zyr1u");
      attr(p, "class", "notes");
      attr(div0, "class", "label-side svelte-19zyr1u");
      attr(i, "class", i_class_value = null_to_empty(ctx[0].icon) + " svelte-19zyr1u");
      attr(button, "type", "button");
      attr(button, "class", "svelte-19zyr1u");
      attr(div1, "class", "button-container svelte-19zyr1u");
      attr(div2, "class", "form-fields input-side svelte-19zyr1u");
      attr(div3, "class", "setting form-scope item-piles-flexrow svelte-19zyr1u");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, label);
      append(label, t0);
      append(label, t1);
      if (if_block)
        if_block.m(label, null);
      append(div0, t2);
      append(div0, p);
      append(p, t3);
      append(div3, t4);
      append(div3, div2);
      append(div2, div1);
      append(div1, button);
      append(button, i);
      append(button, t5);
      append(button, t6);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = localize(ctx2[0].name) + ""))
        set_data(t0, t0_value);
      if (!ctx2[0].hideResetButton) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          if_block.m(label, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1 && t3_value !== (t3_value = localize(ctx2[0].hint) + ""))
        set_data(t3, t3_value);
      if (dirty & 1 && i_class_value !== (i_class_value = null_to_empty(ctx2[0].icon) + " svelte-19zyr1u")) {
        attr(i, "class", i_class_value);
      }
      if (dirty & 1 && t6_value !== (t6_value = localize(ctx2[0].label) + ""))
        set_data(t6, t6_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
__name(create_fragment$1, "create_fragment$1");
function instance$1($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { data } = $$props;
  let { callback = false } = $$props;
  let editor = false;
  if (!callback) {
    editor = editors[data.application];
    callback = /* @__PURE__ */ __name(() => {
      showEditor();
    }, "callback");
  }
  function showEditor() {
    if (editor) {
      editor.show(data.value).then((result) => {
        if (result) {
          $$invalidate(0, data.value = result, data);
        }
      });
      application.options.zLevel = 100;
    }
  }
  __name(showEditor, "showEditor");
  const click_handler = /* @__PURE__ */ __name(() => {
    $$invalidate(0, data.value = data.default, data);
  }, "click_handler");
  const click_handler_1 = /* @__PURE__ */ __name(() => {
    callback();
  }, "click_handler_1");
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("callback" in $$props2)
      $$invalidate(1, callback = $$props2.callback);
  };
  return [data, callback, click_handler, click_handler_1];
}
__name(instance$1, "instance$1");
class SettingButton extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { data: 0, callback: 1 });
  }
}
__name(SettingButton, "SettingButton");
const settingsShell_svelte_svelte_type_style_lang = "";
function create_if_block(ctx) {
  let div0;
  let setting0;
  let updating_data;
  let t0;
  let setting1;
  let updating_data_1;
  let t1;
  let setting2;
  let updating_data_2;
  let t2;
  let setting3;
  let updating_data_3;
  let t3;
  let setting4;
  let updating_data_4;
  let t4;
  let setting5;
  let updating_data_5;
  let t5;
  let setting6;
  let updating_data_6;
  let t6;
  let setting7;
  let updating_data_7;
  let t7;
  let settingbutton0;
  let updating_data_8;
  let t8;
  let div1;
  let settingbutton1;
  let t9;
  let setting8;
  let updating_data_9;
  let t10;
  let setting9;
  let updating_data_10;
  let t11;
  let setting10;
  let updating_data_11;
  let t12;
  let settingbutton2;
  let updating_data_12;
  let t13;
  let setting11;
  let updating_data_13;
  let t14;
  let settingbutton3;
  let updating_data_14;
  let t15;
  let settingbutton4;
  let updating_data_15;
  let current;
  function setting0_data_binding_1(value) {
    ctx[17](value);
  }
  __name(setting0_data_binding_1, "setting0_data_binding_1");
  let setting0_props = {};
  if (ctx[2][SETTINGS.ENABLE_DROPPING_ITEMS] !== void 0) {
    setting0_props.data = ctx[2][SETTINGS.ENABLE_DROPPING_ITEMS];
  }
  setting0 = new Setting({ props: setting0_props });
  binding_callbacks.push(() => bind$1(setting0, "data", setting0_data_binding_1));
  function setting1_data_binding_1(value) {
    ctx[18](value);
  }
  __name(setting1_data_binding_1, "setting1_data_binding_1");
  let setting1_props = {};
  if (ctx[2][SETTINGS.ENABLE_GIVING_ITEMS] !== void 0) {
    setting1_props.data = ctx[2][SETTINGS.ENABLE_GIVING_ITEMS];
  }
  setting1 = new Setting({ props: setting1_props });
  binding_callbacks.push(() => bind$1(setting1, "data", setting1_data_binding_1));
  function setting2_data_binding_1(value) {
    ctx[19](value);
  }
  __name(setting2_data_binding_1, "setting2_data_binding_1");
  let setting2_props = {};
  if (ctx[2][SETTINGS.ENABLE_TRADING] !== void 0) {
    setting2_props.data = ctx[2][SETTINGS.ENABLE_TRADING];
  }
  setting2 = new Setting({ props: setting2_props });
  binding_callbacks.push(() => bind$1(setting2, "data", setting2_data_binding_1));
  function setting3_data_binding_1(value) {
    ctx[20](value);
  }
  __name(setting3_data_binding_1, "setting3_data_binding_1");
  let setting3_props = {};
  if (ctx[2][SETTINGS.SHOW_TRADE_BUTTON] !== void 0) {
    setting3_props.data = ctx[2][SETTINGS.SHOW_TRADE_BUTTON];
  }
  setting3 = new Setting({ props: setting3_props });
  binding_callbacks.push(() => bind$1(setting3, "data", setting3_data_binding_1));
  function setting4_data_binding_1(value) {
    ctx[21](value);
  }
  __name(setting4_data_binding_1, "setting4_data_binding_1");
  let setting4_props = {};
  if (ctx[2][SETTINGS.INSPECT_ITEMS_IN_TRADE] !== void 0) {
    setting4_props.data = ctx[2][SETTINGS.INSPECT_ITEMS_IN_TRADE];
  }
  setting4 = new Setting({ props: setting4_props });
  binding_callbacks.push(() => bind$1(setting4, "data", setting4_data_binding_1));
  function setting5_data_binding_1(value) {
    ctx[22](value);
  }
  __name(setting5_data_binding_1, "setting5_data_binding_1");
  let setting5_props = {};
  if (ctx[2][SETTINGS.OUTPUT_TO_CHAT] !== void 0) {
    setting5_props.data = ctx[2][SETTINGS.OUTPUT_TO_CHAT];
  }
  setting5 = new Setting({ props: setting5_props });
  binding_callbacks.push(() => bind$1(setting5, "data", setting5_data_binding_1));
  function setting6_data_binding(value) {
    ctx[23](value);
  }
  __name(setting6_data_binding, "setting6_data_binding");
  let setting6_props = {};
  if (ctx[2][SETTINGS.DELETE_EMPTY_PILES] !== void 0) {
    setting6_props.data = ctx[2][SETTINGS.DELETE_EMPTY_PILES];
  }
  setting6 = new Setting({ props: setting6_props });
  binding_callbacks.push(() => bind$1(setting6, "data", setting6_data_binding));
  function setting7_data_binding(value) {
    ctx[24](value);
  }
  __name(setting7_data_binding, "setting7_data_binding");
  let setting7_props = {};
  if (ctx[2][SETTINGS.POPULATION_TABLES_FOLDER] !== void 0) {
    setting7_props.data = ctx[2][SETTINGS.POPULATION_TABLES_FOLDER];
  }
  setting7 = new Setting({ props: setting7_props });
  binding_callbacks.push(() => bind$1(setting7, "data", setting7_data_binding));
  function settingbutton0_data_binding(value) {
    ctx[25](value);
  }
  __name(settingbutton0_data_binding, "settingbutton0_data_binding");
  let settingbutton0_props = {};
  if (ctx[2][SETTINGS.PRICE_PRESETS] !== void 0) {
    settingbutton0_props.data = ctx[2][SETTINGS.PRICE_PRESETS];
  }
  settingbutton0 = new SettingButton({ props: settingbutton0_props });
  binding_callbacks.push(() => bind$1(settingbutton0, "data", settingbutton0_data_binding));
  settingbutton1 = new SettingButton({
    props: {
      data: {
        name: "ITEM-PILES.Settings.Reset.Title",
        hint: "ITEM-PILES.Settings.Reset.Hint",
        label: "ITEM-PILES.Settings.Reset.Label",
        icon: "fas fa-undo",
        hideResetButton: true
      },
      callback: ctx[26]
    }
  });
  function setting8_data_binding(value) {
    ctx[27](value);
  }
  __name(setting8_data_binding, "setting8_data_binding");
  let setting8_props = {
    options: game.system.template.Actor.types
  };
  if (ctx[2][SETTINGS.ACTOR_CLASS_TYPE] !== void 0) {
    setting8_props.data = ctx[2][SETTINGS.ACTOR_CLASS_TYPE];
  }
  setting8 = new Setting({ props: setting8_props });
  binding_callbacks.push(() => bind$1(setting8, "data", setting8_data_binding));
  function setting9_data_binding(value) {
    ctx[28](value);
  }
  __name(setting9_data_binding, "setting9_data_binding");
  let setting9_props = {};
  if (ctx[2][SETTINGS.ITEM_QUANTITY_ATTRIBUTE] !== void 0) {
    setting9_props.data = ctx[2][SETTINGS.ITEM_QUANTITY_ATTRIBUTE];
  }
  setting9 = new Setting({ props: setting9_props });
  binding_callbacks.push(() => bind$1(setting9, "data", setting9_data_binding));
  function setting10_data_binding(value) {
    ctx[29](value);
  }
  __name(setting10_data_binding, "setting10_data_binding");
  let setting10_props = {};
  if (ctx[2][SETTINGS.ITEM_PRICE_ATTRIBUTE] !== void 0) {
    setting10_props.data = ctx[2][SETTINGS.ITEM_PRICE_ATTRIBUTE];
  }
  setting10 = new Setting({ props: setting10_props });
  binding_callbacks.push(() => bind$1(setting10, "data", setting10_data_binding));
  function settingbutton2_data_binding(value) {
    ctx[30](value);
  }
  __name(settingbutton2_data_binding, "settingbutton2_data_binding");
  let settingbutton2_props = {};
  if (ctx[2][SETTINGS.CURRENCIES] !== void 0) {
    settingbutton2_props.data = ctx[2][SETTINGS.CURRENCIES];
  }
  settingbutton2 = new SettingButton({ props: settingbutton2_props });
  binding_callbacks.push(() => bind$1(settingbutton2, "data", settingbutton2_data_binding));
  function setting11_data_binding(value) {
    ctx[31](value);
  }
  __name(setting11_data_binding, "setting11_data_binding");
  let setting11_props = {
    disabled: ctx[2][SETTINGS.CURRENCIES].value.length !== 1
  };
  if (ctx[2][SETTINGS.CURRENCY_DECIMAL_DIGITS] !== void 0) {
    setting11_props.data = ctx[2][SETTINGS.CURRENCY_DECIMAL_DIGITS];
  }
  setting11 = new Setting({ props: setting11_props });
  binding_callbacks.push(() => bind$1(setting11, "data", setting11_data_binding));
  function settingbutton3_data_binding(value) {
    ctx[32](value);
  }
  __name(settingbutton3_data_binding, "settingbutton3_data_binding");
  let settingbutton3_props = {};
  if (ctx[2][SETTINGS.ITEM_FILTERS] !== void 0) {
    settingbutton3_props.data = ctx[2][SETTINGS.ITEM_FILTERS];
  }
  settingbutton3 = new SettingButton({ props: settingbutton3_props });
  binding_callbacks.push(() => bind$1(settingbutton3, "data", settingbutton3_data_binding));
  function settingbutton4_data_binding(value) {
    ctx[33](value);
  }
  __name(settingbutton4_data_binding, "settingbutton4_data_binding");
  let settingbutton4_props = {};
  if (ctx[2][SETTINGS.ITEM_SIMILARITIES] !== void 0) {
    settingbutton4_props.data = ctx[2][SETTINGS.ITEM_SIMILARITIES];
  }
  settingbutton4 = new SettingButton({ props: settingbutton4_props });
  binding_callbacks.push(() => bind$1(settingbutton4, "data", settingbutton4_data_binding));
  return {
    c() {
      div0 = element("div");
      create_component(setting0.$$.fragment);
      t0 = space();
      create_component(setting1.$$.fragment);
      t1 = space();
      create_component(setting2.$$.fragment);
      t2 = space();
      create_component(setting3.$$.fragment);
      t3 = space();
      create_component(setting4.$$.fragment);
      t4 = space();
      create_component(setting5.$$.fragment);
      t5 = space();
      create_component(setting6.$$.fragment);
      t6 = space();
      create_component(setting7.$$.fragment);
      t7 = space();
      create_component(settingbutton0.$$.fragment);
      t8 = space();
      div1 = element("div");
      create_component(settingbutton1.$$.fragment);
      t9 = space();
      create_component(setting8.$$.fragment);
      t10 = space();
      create_component(setting9.$$.fragment);
      t11 = space();
      create_component(setting10.$$.fragment);
      t12 = space();
      create_component(settingbutton2.$$.fragment);
      t13 = space();
      create_component(setting11.$$.fragment);
      t14 = space();
      create_component(settingbutton3.$$.fragment);
      t15 = space();
      create_component(settingbutton4.$$.fragment);
      attr(div0, "class", "tab flex");
      attr(div0, "data-scope", "primary");
      attr(div0, "data-tab", "module");
      toggle_class(div0, "active", ctx[3] === "module");
      attr(div1, "class", "tab flex");
      attr(div1, "data-scope", "primary");
      attr(div1, "data-tab", "system");
      toggle_class(div1, "active", ctx[3] === "system");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(setting0, div0, null);
      append(div0, t0);
      mount_component(setting1, div0, null);
      append(div0, t1);
      mount_component(setting2, div0, null);
      append(div0, t2);
      mount_component(setting3, div0, null);
      append(div0, t3);
      mount_component(setting4, div0, null);
      append(div0, t4);
      mount_component(setting5, div0, null);
      append(div0, t5);
      mount_component(setting6, div0, null);
      append(div0, t6);
      mount_component(setting7, div0, null);
      append(div0, t7);
      mount_component(settingbutton0, div0, null);
      insert(target, t8, anchor);
      insert(target, div1, anchor);
      mount_component(settingbutton1, div1, null);
      append(div1, t9);
      mount_component(setting8, div1, null);
      append(div1, t10);
      mount_component(setting9, div1, null);
      append(div1, t11);
      mount_component(setting10, div1, null);
      append(div1, t12);
      mount_component(settingbutton2, div1, null);
      append(div1, t13);
      mount_component(setting11, div1, null);
      append(div1, t14);
      mount_component(settingbutton3, div1, null);
      append(div1, t15);
      mount_component(settingbutton4, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const setting0_changes = {};
      if (!updating_data && dirty[0] & 4) {
        updating_data = true;
        setting0_changes.data = ctx2[2][SETTINGS.ENABLE_DROPPING_ITEMS];
        add_flush_callback(() => updating_data = false);
      }
      setting0.$set(setting0_changes);
      const setting1_changes = {};
      if (!updating_data_1 && dirty[0] & 4) {
        updating_data_1 = true;
        setting1_changes.data = ctx2[2][SETTINGS.ENABLE_GIVING_ITEMS];
        add_flush_callback(() => updating_data_1 = false);
      }
      setting1.$set(setting1_changes);
      const setting2_changes = {};
      if (!updating_data_2 && dirty[0] & 4) {
        updating_data_2 = true;
        setting2_changes.data = ctx2[2][SETTINGS.ENABLE_TRADING];
        add_flush_callback(() => updating_data_2 = false);
      }
      setting2.$set(setting2_changes);
      const setting3_changes = {};
      if (!updating_data_3 && dirty[0] & 4) {
        updating_data_3 = true;
        setting3_changes.data = ctx2[2][SETTINGS.SHOW_TRADE_BUTTON];
        add_flush_callback(() => updating_data_3 = false);
      }
      setting3.$set(setting3_changes);
      const setting4_changes = {};
      if (!updating_data_4 && dirty[0] & 4) {
        updating_data_4 = true;
        setting4_changes.data = ctx2[2][SETTINGS.INSPECT_ITEMS_IN_TRADE];
        add_flush_callback(() => updating_data_4 = false);
      }
      setting4.$set(setting4_changes);
      const setting5_changes = {};
      if (!updating_data_5 && dirty[0] & 4) {
        updating_data_5 = true;
        setting5_changes.data = ctx2[2][SETTINGS.OUTPUT_TO_CHAT];
        add_flush_callback(() => updating_data_5 = false);
      }
      setting5.$set(setting5_changes);
      const setting6_changes = {};
      if (!updating_data_6 && dirty[0] & 4) {
        updating_data_6 = true;
        setting6_changes.data = ctx2[2][SETTINGS.DELETE_EMPTY_PILES];
        add_flush_callback(() => updating_data_6 = false);
      }
      setting6.$set(setting6_changes);
      const setting7_changes = {};
      if (!updating_data_7 && dirty[0] & 4) {
        updating_data_7 = true;
        setting7_changes.data = ctx2[2][SETTINGS.POPULATION_TABLES_FOLDER];
        add_flush_callback(() => updating_data_7 = false);
      }
      setting7.$set(setting7_changes);
      const settingbutton0_changes = {};
      if (!updating_data_8 && dirty[0] & 4) {
        updating_data_8 = true;
        settingbutton0_changes.data = ctx2[2][SETTINGS.PRICE_PRESETS];
        add_flush_callback(() => updating_data_8 = false);
      }
      settingbutton0.$set(settingbutton0_changes);
      if (!current || dirty[0] & 8) {
        toggle_class(div0, "active", ctx2[3] === "module");
      }
      const setting8_changes = {};
      if (!updating_data_9 && dirty[0] & 4) {
        updating_data_9 = true;
        setting8_changes.data = ctx2[2][SETTINGS.ACTOR_CLASS_TYPE];
        add_flush_callback(() => updating_data_9 = false);
      }
      setting8.$set(setting8_changes);
      const setting9_changes = {};
      if (!updating_data_10 && dirty[0] & 4) {
        updating_data_10 = true;
        setting9_changes.data = ctx2[2][SETTINGS.ITEM_QUANTITY_ATTRIBUTE];
        add_flush_callback(() => updating_data_10 = false);
      }
      setting9.$set(setting9_changes);
      const setting10_changes = {};
      if (!updating_data_11 && dirty[0] & 4) {
        updating_data_11 = true;
        setting10_changes.data = ctx2[2][SETTINGS.ITEM_PRICE_ATTRIBUTE];
        add_flush_callback(() => updating_data_11 = false);
      }
      setting10.$set(setting10_changes);
      const settingbutton2_changes = {};
      if (!updating_data_12 && dirty[0] & 4) {
        updating_data_12 = true;
        settingbutton2_changes.data = ctx2[2][SETTINGS.CURRENCIES];
        add_flush_callback(() => updating_data_12 = false);
      }
      settingbutton2.$set(settingbutton2_changes);
      const setting11_changes = {};
      if (dirty[0] & 4)
        setting11_changes.disabled = ctx2[2][SETTINGS.CURRENCIES].value.length !== 1;
      if (!updating_data_13 && dirty[0] & 4) {
        updating_data_13 = true;
        setting11_changes.data = ctx2[2][SETTINGS.CURRENCY_DECIMAL_DIGITS];
        add_flush_callback(() => updating_data_13 = false);
      }
      setting11.$set(setting11_changes);
      const settingbutton3_changes = {};
      if (!updating_data_14 && dirty[0] & 4) {
        updating_data_14 = true;
        settingbutton3_changes.data = ctx2[2][SETTINGS.ITEM_FILTERS];
        add_flush_callback(() => updating_data_14 = false);
      }
      settingbutton3.$set(settingbutton3_changes);
      const settingbutton4_changes = {};
      if (!updating_data_15 && dirty[0] & 4) {
        updating_data_15 = true;
        settingbutton4_changes.data = ctx2[2][SETTINGS.ITEM_SIMILARITIES];
        add_flush_callback(() => updating_data_15 = false);
      }
      settingbutton4.$set(settingbutton4_changes);
      if (!current || dirty[0] & 8) {
        toggle_class(div1, "active", ctx2[3] === "system");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(setting0.$$.fragment, local);
      transition_in(setting1.$$.fragment, local);
      transition_in(setting2.$$.fragment, local);
      transition_in(setting3.$$.fragment, local);
      transition_in(setting4.$$.fragment, local);
      transition_in(setting5.$$.fragment, local);
      transition_in(setting6.$$.fragment, local);
      transition_in(setting7.$$.fragment, local);
      transition_in(settingbutton0.$$.fragment, local);
      transition_in(settingbutton1.$$.fragment, local);
      transition_in(setting8.$$.fragment, local);
      transition_in(setting9.$$.fragment, local);
      transition_in(setting10.$$.fragment, local);
      transition_in(settingbutton2.$$.fragment, local);
      transition_in(setting11.$$.fragment, local);
      transition_in(settingbutton3.$$.fragment, local);
      transition_in(settingbutton4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(setting0.$$.fragment, local);
      transition_out(setting1.$$.fragment, local);
      transition_out(setting2.$$.fragment, local);
      transition_out(setting3.$$.fragment, local);
      transition_out(setting4.$$.fragment, local);
      transition_out(setting5.$$.fragment, local);
      transition_out(setting6.$$.fragment, local);
      transition_out(setting7.$$.fragment, local);
      transition_out(settingbutton0.$$.fragment, local);
      transition_out(settingbutton1.$$.fragment, local);
      transition_out(setting8.$$.fragment, local);
      transition_out(setting9.$$.fragment, local);
      transition_out(setting10.$$.fragment, local);
      transition_out(settingbutton2.$$.fragment, local);
      transition_out(setting11.$$.fragment, local);
      transition_out(settingbutton3.$$.fragment, local);
      transition_out(settingbutton4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(setting0);
      destroy_component(setting1);
      destroy_component(setting2);
      destroy_component(setting3);
      destroy_component(setting4);
      destroy_component(setting5);
      destroy_component(setting6);
      destroy_component(setting7);
      destroy_component(settingbutton0);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(div1);
      destroy_component(settingbutton1);
      destroy_component(setting8);
      destroy_component(setting9);
      destroy_component(setting10);
      destroy_component(settingbutton2);
      destroy_component(setting11);
      destroy_component(settingbutton3);
      destroy_component(settingbutton4);
    }
  };
}
__name(create_if_block, "create_if_block");
function create_default_slot(ctx) {
  let form_1;
  let h2;
  let t1;
  let tabs_1;
  let updating_activeTab;
  let t2;
  let section;
  let div1;
  let setting0;
  let updating_data;
  let t3;
  let setting1;
  let updating_data_1;
  let t4;
  let setting2;
  let updating_data_2;
  let t5;
  let setting3;
  let updating_data_3;
  let t6;
  let setting4;
  let updating_data_4;
  let t7;
  let setting5;
  let updating_data_5;
  let t8;
  let div0;
  let p0;
  let p1;
  let p2;
  let a0;
  let t12;
  let p3;
  let t14;
  let p4;
  let t17;
  let t18;
  let footer;
  let button1;
  let i;
  let t19;
  let t20_value = localize("ITEM-PILES.Applications.Settings.Submit") + "";
  let t20;
  let current;
  let mounted;
  let dispose;
  function tabs_1_activeTab_binding(value) {
    ctx[10](value);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  let tabs_1_props = { tabs: ctx[9] };
  if (ctx[3] !== void 0) {
    tabs_1_props.activeTab = ctx[3];
  }
  tabs_1 = new Tabs({ props: tabs_1_props });
  binding_callbacks.push(() => bind$1(tabs_1, "activeTab", tabs_1_activeTab_binding));
  function setting0_data_binding(value) {
    ctx[11](value);
  }
  __name(setting0_data_binding, "setting0_data_binding");
  let setting0_props = {};
  if (ctx[2][SETTINGS.INVERT_SHEET_OPEN] !== void 0) {
    setting0_props.data = ctx[2][SETTINGS.INVERT_SHEET_OPEN];
  }
  setting0 = new Setting({ props: setting0_props });
  binding_callbacks.push(() => bind$1(setting0, "data", setting0_data_binding));
  function setting1_data_binding(value) {
    ctx[12](value);
  }
  __name(setting1_data_binding, "setting1_data_binding");
  let setting1_props = {};
  if (ctx[2][SETTINGS.HIDE_ACTOR_HEADER_TEXT] !== void 0) {
    setting1_props.data = ctx[2][SETTINGS.HIDE_ACTOR_HEADER_TEXT];
  }
  setting1 = new Setting({ props: setting1_props });
  binding_callbacks.push(() => bind$1(setting1, "data", setting1_data_binding));
  function setting2_data_binding(value) {
    ctx[13](value);
  }
  __name(setting2_data_binding, "setting2_data_binding");
  let setting2_props = {};
  if (ctx[2][SETTINGS.HIDE_ACTOR_HEADER_BUTTON] !== void 0) {
    setting2_props.data = ctx[2][SETTINGS.HIDE_ACTOR_HEADER_BUTTON];
  }
  setting2 = new Setting({ props: setting2_props });
  binding_callbacks.push(() => bind$1(setting2, "data", setting2_data_binding));
  function setting3_data_binding(value) {
    ctx[14](value);
  }
  __name(setting3_data_binding, "setting3_data_binding");
  let setting3_props = {};
  if (ctx[2][SETTINGS.PRELOAD_FILES] !== void 0) {
    setting3_props.data = ctx[2][SETTINGS.PRELOAD_FILES];
  }
  setting3 = new Setting({ props: setting3_props });
  binding_callbacks.push(() => bind$1(setting3, "data", setting3_data_binding));
  function setting4_data_binding(value) {
    ctx[15](value);
  }
  __name(setting4_data_binding, "setting4_data_binding");
  let setting4_props = {};
  if (ctx[2][SETTINGS.DEBUG] !== void 0) {
    setting4_props.data = ctx[2][SETTINGS.DEBUG];
  }
  setting4 = new Setting({ props: setting4_props });
  binding_callbacks.push(() => bind$1(setting4, "data", setting4_data_binding));
  function setting5_data_binding(value) {
    ctx[16](value);
  }
  __name(setting5_data_binding, "setting5_data_binding");
  let setting5_props = {};
  if (ctx[2][SETTINGS.DEBUG_HOOKS] !== void 0) {
    setting5_props.data = ctx[2][SETTINGS.DEBUG_HOOKS];
  }
  setting5 = new Setting({ props: setting5_props });
  binding_callbacks.push(() => bind$1(setting5, "data", setting5_data_binding));
  let if_block = ctx[4] && create_if_block(ctx);
  return {
    c() {
      form_1 = element("form");
      h2 = element("h2");
      h2.textContent = `${localize("ITEM-PILES.Applications.Settings.Title")}`;
      t1 = space();
      create_component(tabs_1.$$.fragment);
      t2 = space();
      section = element("section");
      div1 = element("div");
      create_component(setting0.$$.fragment);
      t3 = space();
      create_component(setting1.$$.fragment);
      t4 = space();
      create_component(setting2.$$.fragment);
      t5 = space();
      create_component(setting3.$$.fragment);
      t6 = space();
      create_component(setting4.$$.fragment);
      t7 = space();
      create_component(setting5.$$.fragment);
      t8 = space();
      div0 = element("div");
      p0 = element("p");
      p0.textContent = `${localize("ITEM-PILES.Applications.Settings.MoreToCome")} 
          `;
      p1 = element("p");
      p2 = element("p");
      a0 = element("a");
      a0.textContent = `${localize("ITEM-PILES.Applications.Settings.Request")}`;
      t12 = space();
      p3 = element("p");
      p3.textContent = `${localize("ITEM-PILES.Applications.Settings.Donate")}`;
      t14 = space();
      p4 = element("p");
      p4.innerHTML = `<a href="https://ko-fi.com/fantasycomputerworks" target="_blank" style="text-decoration: none !important;"><button class="donate-button svelte-9gaqsf" type="button"><img src="https://storage.ko-fi.com/cdn/cup-border.png" class="svelte-9gaqsf"/> 
                <span class="svelte-9gaqsf">Donate</span></button></a>`;
      t17 = space();
      if (if_block)
        if_block.c();
      t18 = space();
      footer = element("footer");
      button1 = element("button");
      i = element("i");
      t19 = space();
      t20 = text(t20_value);
      set_style(h2, "text-align", "center");
      set_style(h2, "margin-bottom", "1rem");
      attr(a0, "class", "link-text svelte-9gaqsf");
      attr(a0, "href", "https://github.com/fantasycalendar/FoundryVTT-ItemPiles/issues/new?assignees=&labels=&template=feature_request.md&title=");
      attr(a0, "target", "_blank");
      set_style(p2, "margin-bottom", "1rem");
      set_style(div0, "text-align", "center");
      set_style(div0, "font-size", "1rem");
      set_style(div0, "margin-top", "3rem");
      attr(div1, "class", "tab flex");
      attr(div1, "data-scope", "primary");
      attr(div1, "data-tab", "local");
      toggle_class(div1, "active", ctx[3] === "local");
      attr(section, "class", "tab-body svelte-9gaqsf");
      attr(i, "class", "far fa-save");
      attr(button1, "type", "button");
      attr(footer, "class", "svelte-9gaqsf");
      attr(form_1, "autocomplete", "off");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      append(form_1, h2);
      append(form_1, t1);
      mount_component(tabs_1, form_1, null);
      append(form_1, t2);
      append(form_1, section);
      append(section, div1);
      mount_component(setting0, div1, null);
      append(div1, t3);
      mount_component(setting1, div1, null);
      append(div1, t4);
      mount_component(setting2, div1, null);
      append(div1, t5);
      mount_component(setting3, div1, null);
      append(div1, t6);
      mount_component(setting4, div1, null);
      append(div1, t7);
      mount_component(setting5, div1, null);
      append(div1, t8);
      append(div1, div0);
      append(div0, p0);
      append(div0, p1);
      append(div0, p2);
      append(p2, a0);
      append(div0, t12);
      append(div0, p3);
      append(div0, t14);
      append(div0, p4);
      append(section, t17);
      if (if_block)
        if_block.m(section, null);
      append(form_1, t18);
      append(form_1, footer);
      append(footer, button1);
      append(button1, i);
      append(button1, t19);
      append(button1, t20);
      ctx[34](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button1, "click", ctx[6], { once: true }),
          listen(form_1, "submit", prevent_default(ctx[7]), { once: true })
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeTab && dirty[0] & 8) {
        updating_activeTab = true;
        tabs_1_changes.activeTab = ctx2[3];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs_1.$set(tabs_1_changes);
      const setting0_changes = {};
      if (!updating_data && dirty[0] & 4) {
        updating_data = true;
        setting0_changes.data = ctx2[2][SETTINGS.INVERT_SHEET_OPEN];
        add_flush_callback(() => updating_data = false);
      }
      setting0.$set(setting0_changes);
      const setting1_changes = {};
      if (!updating_data_1 && dirty[0] & 4) {
        updating_data_1 = true;
        setting1_changes.data = ctx2[2][SETTINGS.HIDE_ACTOR_HEADER_TEXT];
        add_flush_callback(() => updating_data_1 = false);
      }
      setting1.$set(setting1_changes);
      const setting2_changes = {};
      if (!updating_data_2 && dirty[0] & 4) {
        updating_data_2 = true;
        setting2_changes.data = ctx2[2][SETTINGS.HIDE_ACTOR_HEADER_BUTTON];
        add_flush_callback(() => updating_data_2 = false);
      }
      setting2.$set(setting2_changes);
      const setting3_changes = {};
      if (!updating_data_3 && dirty[0] & 4) {
        updating_data_3 = true;
        setting3_changes.data = ctx2[2][SETTINGS.PRELOAD_FILES];
        add_flush_callback(() => updating_data_3 = false);
      }
      setting3.$set(setting3_changes);
      const setting4_changes = {};
      if (!updating_data_4 && dirty[0] & 4) {
        updating_data_4 = true;
        setting4_changes.data = ctx2[2][SETTINGS.DEBUG];
        add_flush_callback(() => updating_data_4 = false);
      }
      setting4.$set(setting4_changes);
      const setting5_changes = {};
      if (!updating_data_5 && dirty[0] & 4) {
        updating_data_5 = true;
        setting5_changes.data = ctx2[2][SETTINGS.DEBUG_HOOKS];
        add_flush_callback(() => updating_data_5 = false);
      }
      setting5.$set(setting5_changes);
      if (!current || dirty[0] & 8) {
        toggle_class(div1, "active", ctx2[3] === "local");
      }
      if (ctx2[4])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(setting0.$$.fragment, local);
      transition_in(setting1.$$.fragment, local);
      transition_in(setting2.$$.fragment, local);
      transition_in(setting3.$$.fragment, local);
      transition_in(setting4.$$.fragment, local);
      transition_in(setting5.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(setting0.$$.fragment, local);
      transition_out(setting1.$$.fragment, local);
      transition_out(setting2.$$.fragment, local);
      transition_out(setting3.$$.fragment, local);
      transition_out(setting4.$$.fragment, local);
      transition_out(setting5.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form_1);
      destroy_component(tabs_1);
      destroy_component(setting0);
      destroy_component(setting1);
      destroy_component(setting2);
      destroy_component(setting3);
      destroy_component(setting4);
      destroy_component(setting5);
      if (if_block)
        if_block.d();
      ctx[34](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
__name(create_default_slot, "create_default_slot");
function create_fragment(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[35](value);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  let applicationshell_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    applicationshell_props.elementRoot = ctx[0];
  }
  applicationshell = new ApplicationShell({ props: applicationshell_props });
  binding_callbacks.push(() => bind$1(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = {};
      if (dirty[0] & 14 | dirty[1] & 64) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty[0] & 1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
__name(create_fragment, "create_fragment");
function instance($$self, $$props, $$invalidate) {
  const { application } = getContext("external");
  let { elementRoot } = $$props;
  let form;
  let settings = {};
  let userIsGM = game.user.isGM;
  getSettings();
  function getSettings() {
    $$invalidate(2, settings = Object.fromEntries(Object.entries(SETTINGS.GET_DEFAULT()).map((entry) => {
      entry[1].value = getSetting(entry[0]);
      return entry;
    })));
    $$invalidate(
      2,
      settings[SETTINGS.POPULATION_TABLES_FOLDER].choices = {
        "root": "ITEM-PILES.Settings.PopulationTablesFolder.AllTables",
        ...Object.fromEntries(game.folders.filter((f) => f.type === "RollTable").map((f) => [f.id, f.name]))
      },
      settings
    );
  }
  __name(getSettings, "getSettings");
  function requestSubmit() {
    form.requestSubmit();
  }
  __name(requestSubmit, "requestSubmit");
  async function updateSettings() {
    let settingsToUpdate = Object.entries(settings).filter((entry) => userIsGM || entry[1].scope === "client");
    for (let [key, setting] of settingsToUpdate) {
      await setSetting(key, setting.value);
    }
    application.close();
  }
  __name(updateSettings, "updateSettings");
  async function resetSettings() {
    const doThing = await TJSDialog.confirm({
      title: game.i18n.localize("ITEM-PILES.Dialogs.ResetSettings.Title"),
      content: {
        class: CustomDialog,
        props: {
          content: game.i18n.localize("ITEM-PILES.Dialogs.ResetSettings.Content")
        }
      },
      buttons: {
        yes: {
          icon: '<i class="fas fa-check"></i>',
          label: game.i18n.localize("ITEM-PILES.Dialogs.ResetSettings.Confirm")
        },
        no: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("No")
        }
      },
      modal: true,
      draggable: false,
      rejectClose: false,
      defaultYes: true,
      options: { height: "auto" }
    });
    if (!doThing)
      return;
    return applyDefaultSettings();
  }
  __name(resetSettings, "resetSettings");
  let tabs = [
    {
      value: "local",
      label: localize("ITEM-PILES.Applications.Settings.Local")
    },
    {
      value: "module",
      label: localize("ITEM-PILES.Applications.Settings.Module"),
      hidden: !userIsGM
    },
    {
      value: "system",
      label: localize("ITEM-PILES.Applications.Settings.System"),
      hidden: !userIsGM
    }
  ];
  let activeTab = tabs[0].value;
  function tabs_1_activeTab_binding(value) {
    activeTab = value;
    $$invalidate(3, activeTab);
  }
  __name(tabs_1_activeTab_binding, "tabs_1_activeTab_binding");
  function setting0_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.INVERT_SHEET_OPEN], value)) {
      settings[SETTINGS.INVERT_SHEET_OPEN] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting0_data_binding, "setting0_data_binding");
  function setting1_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.HIDE_ACTOR_HEADER_TEXT], value)) {
      settings[SETTINGS.HIDE_ACTOR_HEADER_TEXT] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting1_data_binding, "setting1_data_binding");
  function setting2_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.HIDE_ACTOR_HEADER_BUTTON], value)) {
      settings[SETTINGS.HIDE_ACTOR_HEADER_BUTTON] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting2_data_binding, "setting2_data_binding");
  function setting3_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.PRELOAD_FILES], value)) {
      settings[SETTINGS.PRELOAD_FILES] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting3_data_binding, "setting3_data_binding");
  function setting4_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.DEBUG], value)) {
      settings[SETTINGS.DEBUG] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting4_data_binding, "setting4_data_binding");
  function setting5_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.DEBUG_HOOKS], value)) {
      settings[SETTINGS.DEBUG_HOOKS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting5_data_binding, "setting5_data_binding");
  function setting0_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ENABLE_DROPPING_ITEMS], value)) {
      settings[SETTINGS.ENABLE_DROPPING_ITEMS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting0_data_binding_1, "setting0_data_binding_1");
  function setting1_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ENABLE_GIVING_ITEMS], value)) {
      settings[SETTINGS.ENABLE_GIVING_ITEMS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting1_data_binding_1, "setting1_data_binding_1");
  function setting2_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ENABLE_TRADING], value)) {
      settings[SETTINGS.ENABLE_TRADING] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting2_data_binding_1, "setting2_data_binding_1");
  function setting3_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.SHOW_TRADE_BUTTON], value)) {
      settings[SETTINGS.SHOW_TRADE_BUTTON] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting3_data_binding_1, "setting3_data_binding_1");
  function setting4_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.INSPECT_ITEMS_IN_TRADE], value)) {
      settings[SETTINGS.INSPECT_ITEMS_IN_TRADE] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting4_data_binding_1, "setting4_data_binding_1");
  function setting5_data_binding_1(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.OUTPUT_TO_CHAT], value)) {
      settings[SETTINGS.OUTPUT_TO_CHAT] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting5_data_binding_1, "setting5_data_binding_1");
  function setting6_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.DELETE_EMPTY_PILES], value)) {
      settings[SETTINGS.DELETE_EMPTY_PILES] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting6_data_binding, "setting6_data_binding");
  function setting7_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.POPULATION_TABLES_FOLDER], value)) {
      settings[SETTINGS.POPULATION_TABLES_FOLDER] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting7_data_binding, "setting7_data_binding");
  function settingbutton0_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.PRICE_PRESETS], value)) {
      settings[SETTINGS.PRICE_PRESETS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(settingbutton0_data_binding, "settingbutton0_data_binding");
  const func2 = /* @__PURE__ */ __name(async () => {
    await resetSettings();
    getSettings();
  }, "func");
  function setting8_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ACTOR_CLASS_TYPE], value)) {
      settings[SETTINGS.ACTOR_CLASS_TYPE] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting8_data_binding, "setting8_data_binding");
  function setting9_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ITEM_QUANTITY_ATTRIBUTE], value)) {
      settings[SETTINGS.ITEM_QUANTITY_ATTRIBUTE] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting9_data_binding, "setting9_data_binding");
  function setting10_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ITEM_PRICE_ATTRIBUTE], value)) {
      settings[SETTINGS.ITEM_PRICE_ATTRIBUTE] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting10_data_binding, "setting10_data_binding");
  function settingbutton2_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.CURRENCIES], value)) {
      settings[SETTINGS.CURRENCIES] = value;
      $$invalidate(2, settings);
    }
  }
  __name(settingbutton2_data_binding, "settingbutton2_data_binding");
  function setting11_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.CURRENCY_DECIMAL_DIGITS], value)) {
      settings[SETTINGS.CURRENCY_DECIMAL_DIGITS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(setting11_data_binding, "setting11_data_binding");
  function settingbutton3_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ITEM_FILTERS], value)) {
      settings[SETTINGS.ITEM_FILTERS] = value;
      $$invalidate(2, settings);
    }
  }
  __name(settingbutton3_data_binding, "settingbutton3_data_binding");
  function settingbutton4_data_binding(value) {
    if ($$self.$$.not_equal(settings[SETTINGS.ITEM_SIMILARITIES], value)) {
      settings[SETTINGS.ITEM_SIMILARITIES] = value;
      $$invalidate(2, settings);
    }
  }
  __name(settingbutton4_data_binding, "settingbutton4_data_binding");
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(1, form);
    });
  }
  __name(form_1_binding, "form_1_binding");
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  __name(applicationshell_elementRoot_binding, "applicationshell_elementRoot_binding");
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [
    elementRoot,
    form,
    settings,
    activeTab,
    userIsGM,
    getSettings,
    requestSubmit,
    updateSettings,
    resetSettings,
    tabs,
    tabs_1_activeTab_binding,
    setting0_data_binding,
    setting1_data_binding,
    setting2_data_binding,
    setting3_data_binding,
    setting4_data_binding,
    setting5_data_binding,
    setting0_data_binding_1,
    setting1_data_binding_1,
    setting2_data_binding_1,
    setting3_data_binding_1,
    setting4_data_binding_1,
    setting5_data_binding_1,
    setting6_data_binding,
    setting7_data_binding,
    settingbutton0_data_binding,
    func2,
    setting8_data_binding,
    setting9_data_binding,
    setting10_data_binding,
    settingbutton2_data_binding,
    setting11_data_binding,
    settingbutton3_data_binding,
    settingbutton4_data_binding,
    form_1_binding,
    applicationshell_elementRoot_binding
  ];
}
__name(instance, "instance");
class Settings_shell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { elementRoot: 0 }, null, [-1, -1]);
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
}
__name(Settings_shell, "Settings_shell");
class SettingsApp extends SvelteApplication {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: `item-piles-application-system-settings`,
      title: "Item Piles Module Configuration",
      width: 600,
      svelte: {
        class: Settings_shell,
        target: document.body
      },
      zIndex: 100
    });
  }
  static getActiveApp() {
    return Object.values(ui.windows).find((app) => app.id === "item-piles-application-system-settings");
  }
  static async show(options = {}, dialogData = {}) {
    const app = this.getActiveApp();
    if (app)
      return app.render(false, { focus: true });
    return new Promise((resolve) => {
      options.resolve = resolve;
      new this(options, dialogData).render(true, { focus: true });
    });
  }
}
__name(SettingsApp, "SettingsApp");
class SettingsShim extends FormApplication {
  constructor() {
    super({});
    SettingsApp.show();
  }
  async _updateObject(event, formData) {
  }
  render() {
    this.close();
  }
}
__name(SettingsShim, "SettingsShim");
function registerSettings() {
  game.settings.registerMenu(CONSTANTS.MODULE_NAME, "configure-settings", {
    name: "ITEM-PILES.Settings.Configure.Title",
    label: "ITEM-PILES.Settings.Configure.Label",
    hint: "ITEM-PILES.Settings.Configure.Hint",
    icon: "fas fa-cog",
    type: SettingsShim,
    restricted: false
  });
  for (let [name, data] of Object.entries(SETTINGS.GET_DEFAULT()).filter((setting) => !setting[1].post)) {
    game.settings.register(CONSTANTS.MODULE_NAME, name, data);
  }
}
__name(registerSettings, "registerSettings");
async function applyDefaultSettings() {
  const settings = SETTINGS.GET_SYSTEM_DEFAULTS();
  for (const [name, data] of Object.entries(settings)) {
    await setSetting(name, data.default);
  }
  await setSetting(SETTINGS.SYSTEM_VERSION, SYSTEMS.DATA.VERSION);
  await patchCurrencySettings();
}
__name(applyDefaultSettings, "applyDefaultSettings");
async function patchCurrencySettings() {
  const currencies = getSetting(SETTINGS.CURRENCIES);
  for (let currency of currencies) {
    if (currency.type !== "item" || !currency.data.uuid || currency.data.item)
      continue;
    const item = await fromUuid(currency.data.uuid);
    if (!item)
      continue;
    currency.data.item = item.toObject();
  }
  return setSetting(SETTINGS.CURRENCIES, currencies);
}
__name(patchCurrencySettings, "patchCurrencySettings");
function applySystemSpecificStyles() {
  if (!SYSTEMS.DATA?.CSS_OVERRIDES)
    return;
  const root = document.documentElement;
  Object.entries(SYSTEMS.DATA?.CSS_OVERRIDES).forEach(([style, val]) => {
    root.style.setProperty(style, val);
  });
}
__name(applySystemSpecificStyles, "applySystemSpecificStyles");
async function checkSystem() {
  if (getSetting(SETTINGS.PRECONFIGURED_SYSTEM))
    return;
  if (!SYSTEMS.HAS_SYSTEM_SUPPORT) {
    if (getSetting(SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN))
      return;
    let settingsValid = true;
    for (const [name, data] of Object.entries(SETTINGS.GET_DEFAULT())) {
      settingsValid = settingsValid && getSetting(name).length !== new data.type().length;
    }
    if (settingsValid)
      return;
    TJSDialog.prompt({
      title: game.i18n.localize("ITEM-PILES.Dialogs.NoSystemFound.Title"),
      content: {
        class: CustomDialog,
        props: {
          content: game.i18n.localize("ITEM-PILES.Dialogs.NoSystemFound.Content")
        }
      }
    });
    return setSetting(SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN, true);
  }
  if (getSetting(SETTINGS.SYSTEM_FOUND)) {
    const currentVersion = getSetting(SETTINGS.SYSTEM_VERSION);
    const newVersion = SYSTEMS.DATA.VERSION;
    if (isNewerVersion(newVersion, currentVersion)) {
      await applyDefaultSettings();
    }
    return;
  }
  await setSetting(SETTINGS.SYSTEM_FOUND, true);
  if (getSetting(SETTINGS.SYSTEM_NOT_FOUND_WARNING_SHOWN)) {
    const doThing = await TJSDialog.confirm({
      title: game.i18n.localize("ITEM-PILES.Dialogs.SystemFound.Title"),
      content: {
        class: CustomDialog,
        props: {
          content: game.i18n.localize("ITEM-PILES.Dialogs.SystemFound.Content")
        }
      },
      buttons: {
        yes: {
          icon: '<i class="fas fa-check"></i>',
          label: game.i18n.localize("ITEM-PILES.Dialogs.SystemFound.Confirm")
        },
        no: {
          icon: '<i class="fas fa-times"></i>',
          label: game.i18n.localize("No")
        }
      },
      modal: true,
      draggable: false,
      rejectClose: false,
      defaultYes: true,
      options: {
        height: "auto"
      }
    });
    if (!doThing) {
      return;
    }
  }
  return applyDefaultSettings();
}
__name(checkSystem, "checkSystem");
Hooks.once("init", async () => {
  registerHotkeysPre();
  registerLibwrappers();
  registerSettings();
  registerUIOverrides();
});
Hooks.once("ready", () => {
  setTimeout(() => {
    ItemPileSocket.initialize();
    PrivateAPI.initialize();
    TradeAPI.initialize();
    ChatAPI.initialize();
    game.itempiles = {
      API,
      hooks: HOOKS
    };
    window.ItemPiles = {
      API
    };
    if (!game.modules.get("lib-wrapper")?.active && game.user.isGM) {
      let word = "install and activate";
      if (game.modules.get("lib-wrapper"))
        word = "activate";
      throw custom_error(`Item Piles requires the 'libWrapper' module. Please ${word} it.`);
    }
    if (!game.modules.get("socketlib")?.active && game.user.isGM) {
      let word = "install and activate";
      if (game.modules.get("socketlib"))
        word = "activate";
      throw custom_error(`Item Piles requires the 'socketlib' module. Please ${word} it.`);
    }
    if (!isGMConnected()) {
      custom_warning(`Item Piles requires a GM to be connected for players to be able to loot item piles.`, true);
    }
    registerHotkeysPost();
    ChatAPI.disablePastTradingButtons();
    Hooks.callAll(HOOKS.READY);
  }, 100);
});
Hooks.once(HOOKS.READY, async () => {
  setTimeout(async () => {
    if (game.user.isGM) {
      await checkSystem();
      await patchCurrencySettings();
    }
    applySystemSpecificStyles();
  }, 100);
});
Hooks.on(HOOKS.RESET_SETTINGS, async () => {
  for (let setting of game.settings.storage.get("world").filter((setting2) => setting2.key.includes("item-piles"))) {
    await setting.delete();
  }
  checkSystem();
});
//# sourceMappingURL=module.js.map
